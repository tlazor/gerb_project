The table structure of your scratch table has to line up with the main table, including indexes.  Then you swap the partition out and drop the table.
Removing partitions is a bit fiddlier - you will have to make a table with the correct schema and a check constraint on your partition key then do an alter table swap partition.  Getting the partition ID can be a bit fiddly but you can do it from the data dictionary.  I also did it once by making a 'bellwether' table with one row for each partition on the same partition scheme and selecting $partition.{partition function} from that table where the key is the appropriate value.
I have, sort of.  Partitioning on SQL Server 2005 is somewhat fiddly and probably not worth the trouble unless you have enough data to get a real performance win.  Rather than creating partitions on the fly you should just create partitions until some period in the future.  The don't cost anything until you put data into them.
I think the paint is still a bit wet on partitioning for SQL Server 2005.  There are several missing features, for example you can't easily build indexes on a specific partition; the only way to avoid building and rebuilding indexes for the whole fact table is to do a similar trick with swapping the data in and out of the scratch table.  SQL Server 2008 also gets the facility to move tables between filegroups without doing the clustered index trick.
However, I'm not aware of anything downloadable to automate this.  Everything I've done for this id DIY, and yes it is a pain in the arse.