When the player removes a tower, set the movement value to one more than the lowest adjacent square and repeat the process above.
For a start you could change your array to a vector - should give you some speed improvements. Post the code and we might be able to suggest more optimisations.
Instead you should spread out the load over a few frames. Stagger your AI updates so different characters update their path on different frames. It would be really noticeable if a character didn't react until a second later, but just one frame is not going to cause bad reactions.
When the player places a tower, update each of the eight adjacent squares: for each square, set it's movement value to one more than the lowest adjacent value. If the value changes, repeat the process centred on the updated square. Then, to check that the route to the exit is not blocked, ensure all squares are adjacent to a square of a lower value.
Make your search algorithm such that it can be updated in multiple steps, so that when you place a tower and play an animation, you can do a little bit every frame and you'll have somewhere between half a second and a second to update your A* without a noticable pause. 
It's latency - iF you can't speed it up, find a way to hide it. Playing an animation while placing a tower would be natural for a game and imo a good place to hide it.
I would guess that your slowdown is because you are calculating a path for all characters simultaneously. Calculating a path for one character is fast but if there are two dozen characters in the scene then that can bog down.