The simplest way I know of to find which system objects are used is to issue SET STATISTICS IO, TIME ON; before running the query. For example:
It looks like you're getting too caught up on the fact that you need to use the system views. Think of it like writing code against views provided by a vendor that you can't modify. You can use almost all of the same optimization techniques that you can use against other queries. I think that you just can't create indexes or statistics on the hidden system tables.
Perhaps the problem here isn't that it's a recursive query. What other things can you try to make the spill go away?
I've seen trace flag 9481 improve the performance of queries against the system views. If you think that you have a cardinality estimate issue it's one thing that you can try.
Warnings in query plans are only a problem if the query does not perform at an acceptable level. If I have a query that finishes in 10 ms then why spend time as a programmer trying to make it go faster just to make a warning go away? In fact, any query that spills to tempdb will throw a warning. I would be interested to see a system in which queries never spill to tempdb.
In SQL Server 2016 this is fairly easy with the new MIN_GRANT_PERCENT query hint. On older versions it's a bit harder. You would need to write logically equivalent code that increases the estimated number of rows returned. 
As you experienced that might not be enough to make the spills go away. I suspect that the problem here is that you wrote a recursive query. The SQL Server query optimizer often has trouble estimating exactly how many rows will be returned by a recursive query. To me, this seems like a reasonable limitation. It feels like something that would be very difficult to model.
Erik already covered your question about the data type conversion warning so I will focus on the other questions.
Also, there are a variety of possible causes for a spill to tempdb. In fact, sometimes SQL Server will deliberately spill to tempdb. Depending on the system, updating statistics on underlying tables can be a reasonable step towards addressing the issue. However, that will certainly not always fix the issue.
Cardinality estimates often get worse as rows flow through the query plan. You may be able to put some of the results of the query into a temp table and reference that temp table in the query instead. For some queries you can get dramatically better performance and estimates just by putting a small result set into a temp table.
I haven't looked at your code to see how difficult this would be but I think this suggestion is self evident.
In terms of other trace flags to help with spills, I only know of trace flag 7470, which is unlikely to apply to your situation.