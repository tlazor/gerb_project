The MVC is what will help you decouple though. try to think of it this way. What if you wanted to switch libraries. Try to write your code so that the underlying data structure doesn't know or care how it is presented. Then you could theoretically switch from say SFML to SDL or some hand-rolled library or anything you'd like. You'd have to define your Cells in abstract manner. Maybe a 2d Matrix or a flattened matrix. The update method here would run your check_neighbors() or apply_rules functions and update all your cells accordingly.
The way I would implement the Update Method would be to build your GOL class as an application level class. At its core this pattern boils down to:
I think that you are correct to be concerned about the coupling. I also think that decoupling your program would make it easy to test, debug, and profile for performance issues. With that in mind I suggest you use the MVC Pattern or closely related MVVM or MVP and the Game Loop.
Now to build your View and Controller. In this case because its the same library and the Controller is so small I personally would make them the same class. Just shove your three user events into the input() function and move on. You will want to pass the Model as a reference to the View so it can know what to present. Here you will keep your sf::RenderWindow as well as your std::vector<sf::Vertex>.
This might seem like over-engineering and for such a small project it very well may be. However, you are having a performance issue that you can't narrow down and a little further abstraction will make that easier. Once you have a render() function you can profile and test it. You can do the same with an update() function.