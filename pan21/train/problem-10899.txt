So the advantage of lazytime is that you get back your POSIX compliance, and it also suppresses mtime updates for non-allocating random writes into a file (e.g., in the case of an enterprise database tablespace file, such as what Oracle or DB2 might use).   However, with lazytime, it's possible ot have one timestamp value while the system is running, and if you crash (as opposed to cleanly unmount the file system), you'll get a different timestamp value after you reboot.   This is allowed by POSIX, which only makes consistency guarantees after an fsync(2) or a umount(2), but it's possible this might surprise some applications.
In Linux 4.2 and newer kernels, there is also the "lazytime" mount option, which will update the all of the timestamp fields field in memory (so it is always accurate) while the system is running.   The timestamps on disk is updated (a) when the file system is unmounted, (b) if the timestamps are more than 24 hours stale, (c) if some other inode field in that inode needs to get updated --- e.g., i_size, i_blocks, i_mode, i_uid, etc ----, or (d) (an ext4 optimization only), there is an adjacent inode in the same inode table block which is getting updated on disk.
By default Linux uses the "relatime" mount option for all file systems, which only updates the atime field if it is more than 24 hours stale, or if atime < mtime (since some mail readers use this to determine whether three is unread mail in a /var/mail/XXXX file).    This significantly reduces the number of metadata writes.   There is also the "noatime" mount option, which completely disable the writes.  The relatime and noatime fields technically break POSIX compliance, although most people don't care about strict POSIX compliance these days.