You don't need class _node at all.  The m_lruList should store only the keys and not the values; its role is just to keep the order in which the keys were accessed.  The m_lruMap should be a simple map from key to value.  So:
In your Get function, you assume that an object of type T can be constructed from the integer 0.  This limits the sorts of objects you can track in your cache.  Returning a default constructed object would be better since it will still return 0 for built in numeric types while supporting a wider variety of objects.  You can get rid of val and just either return the located value, or the default object (return T();).  And you misspell guard in this function.
The LRUCache constructor should be explicit, to avoid declarations like LRUCache c = 7;.  The copy constructor and copy assignment operator should be deleted (declared with = delete) since the compiler generated ones will not work properly because the iterator stored in m_lruMap will refer to the original object and not the new one.
Another minor point is that in both Get() and Set() you have to reset the accessed key at the head of the queue, if it is already in the cache.  I would write a method resetHeadKey(int key) which would be called in both Get() and Set() if needed.
In Set, the check for removing an element in a full cache needs to only be made if a new element was added.  This check could be done before adding the new element, which would better restrain the total size used, and allow possibly reusing the removed _node object rather than allocating a new one.
Another point is that Get() should not return 0, but maybe instead null.  The line T val = 0; unfortunately does not trigger a compiler error, but it will trigger a runtime error if for example you use strings for T.  If you do choose to return null when Get() does not find the key, you should modify Set() so that it does not accept null as a value.
The code is too complex because of class _node and using ListIterator = typename std::list<_node>::const_iterator;.  This is all unnecessary.  I believe you went that route so you could use list.splice() which takes a const_iterator as one of its arguments.
The bug arises in Set(): if you reset the value for a key which is already in the cache, it does not update the value at all and just keeps the original value.  And you can't just fix it by adding one line of code, because the variable you are working with at this point is mapIter->second which is a std::list<_node>::const_iterator, which cannot have its value modified.