Now hightlight just your select statement and run it and also the DMV queries again. Nothing has changed! What happened to the S locks? Well, running under the default READ COMMITTED isolation level the locks are release as soon as the DB engine has finished processing the particular row. See section "SQL Server Locking Read Committed" here. So the S locks were taken while the query was execution but had been released by the time the DMVs were examined again. (You can see the locks and releases happening using extended events. There are queries in this answer which you can modify to see this for yourself.)
Run just the UPDATE statement. The shared (S) locks have become exclusive (X) locks.  Because these locks are protecting altered data they are always held until the end of the transaction - no additional hints are required.
Run just your BEGIN TRAN A; statement and re-run the DMV queries. You'll see there's a new transaction with name=A but no further locks.
Every row lock is taken or converted exactly at the moment when that row is  accessed by the transaction. The share lock on the row WHERE productid = 2 will be taken at some time after "time a", but before "time b". The update lock on the row WHERE productid = 3 will be taken _at some time after "time b", then converted to the exclusive lock shortly after. 
We can make the locks remain to the end of the transaction using the HOLDLOCK table hint. Change your SELECT to ..FROM Production.Products WITH(HOLDLOCK).. and re-run the SELECT and the DMV queries. You will see shared locks on the table (and other objects).
This is the reason why deadlocks are possible -- if all locks were taken in advance, deadlocks would not happen.
For your original question - when was the exclusive lock taken on row with productid 3 - the answer is, when the query processor came to that particular row as it was working through the query plan generated for that update statement.
SQL Server (or any other DBMS for that matter) can do no such thing, because at the start of a transaction it is unknown if rows that possibly match statement predicates even exist. You need to go and try and find them first, one at a time, which is the natural place to put the necessary locks on them.