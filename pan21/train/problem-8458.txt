The way an RPN calculator normally works is, it starts with an empty stack.  When it encounters a number, it pushes it onto the stack.  When it encounters an operation, the operation pops the necessary number of operands from the stack and pushes the result onto the stack.  The stack only contains numbers — never operators.
You are confusing the RPN expression (the stream of numbers and commands) with the stack that the RPN calculator operates on.
Also, contrary to common belief, division by zero is not an error in IEEE 754 floating-point — it results in infinity (or negative infinity, if dividing by negative zero).  Therefore, you would get better functionality by removing the check for division by zero.
Finally, creating a result of 0.0 when faced with invalid input is reckless.  The user will see a seemingly successful computation that is not what was intended.  When encountering invalid input, the function must indicate an error.  A good way to do that is to throw an exception.
Therefore, your RPN calculator should either create a stack, or take an (empty) stack as a parameter.  I've chosen the latter option for greater flexibility.
There are some other improvements you could make.  One is to write all of the operators as blocks in a dictionary, and do dynamic dispatching by looking up the operator by name.  That is more elegant than a long chain of else-ifs.