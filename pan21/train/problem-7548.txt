Each shader would have an instance of this struct, and when you load a shader you'd query it for the locations of all the parameters, using glGetUniformLocation and standardized names.  Then whenever you need to set a uniform from code, you can check if it's present in that shader, and just look up its location and set it.
For uniforms, if you can use OpenGL 3.1 or later it's a good idea to use uniform buffer objects (the OpenGL equivalent of D3D's constant buffers).  Alas, GL ES 2.0 doesn't have those, so uniforms have to be handled individually.  One way to do it would be to create a struct containing the uniform location for each parameter you want to set - the camera matrix, specular power, world matrix etc.  Sampler locations could be in here too.  This approach depends on there being a standard set of parameters shared across all shaders.  Not every shader has to use every single parameter, but all parameters would have to be in this struct.
There are a variety of ways to do this; for instance, you could have a standard set of names for the attributes in the shader ("attrPosition", "attrNormal", etc.) plus some hard-coded rules like "position is 3 floats".  Then you use glGetAttribLocation or similiar to query which attributes the shader uses, and apply the rules to build the vertex format.  Another way is to have an XML snippet defining the format, embedded in a comment in the shader source and extracted by your tools, or something along those lines.
First the disclaimer: a data-driven system can make it easier to add new shaders, but on the other hand it comes with costs in terms of the increased complexity of the system, which makes it harder to maintain and debug.  So it's a good idea to think carefully about just how much data-drivenness will be good for you (for a small project, the answer might well be "none"), and don't try to build a system that's overly generalized.
Where does the data to populate this description come from?  Conceptually, I think the cleanest way is to have it belong to the shader.  When you build the vertex data for a mesh, you would look up which shader is used on the mesh, find the vertex format required by that shader, and build the vertex buffer accordingly.  You just need some way for each shader to specify the vertex format it expects.
It's possible to make your shader system more data-driven, so that you don't have so much shader-specific code laying around for uniforms and vertex formats, but rather set them programmatically based on metadata attached to the shaders.
Okay, let's talk about vertex formats (attributes) first.  You can create a data description by making a struct that contains the data to pass to glVertexAttribPointer - the index, type, size, etc. of a single attribute - and having an array of those structs to represent the whole vertex format.  Given this information, you can programmatically set up all the GL state related to the vertex attributes.