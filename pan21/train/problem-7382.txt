So we have a class with two template arguments: the type your deque will contain, and the size of inner arrays. The user might want big arrays if speed is more important than memory, or the opposite. I've chosen a default size without putting much thought into it.
There are a number of things that could be improved here, and none of them have to do with the efficiency of the program.  The problems with this code are more fundamental.
However, the trade-off would be that random-access operations on your queue (if you need them) would become an order of magnitude worse.
No difficulty here, a simple constructor ensures the queue is ready to use by allocating a first array, and initializing the iterators to the first and last element. They're equal, meaning the queue is empty.
Putting using namespace std at the top of every program is a bad habit that you'd do well to avoid.  
There are a few weaknesses in your code, that @Edward already pointed out, such as using namespace std and, worse, #include <bits/stdc++.h>. But I really like that you tried to rely on std functionalities. Building your queue upon std::vector is almost right.
Imagine there are a million items in your queue (and therefore the vector). Now imagine popping an item off the front.
In order to push a new element, you need to be sure that there's some room left. last is increment after every push, so you need to verify it hasn't reached the end of the last allocated array. std::rbegin returns an iterator to the last element (!= std::end, which returns an iterator past the last element).
Whenever you have some data structure and associated actions (such as push and pop in this case), you should be thinking object.  In this case, it's quite simple to create an object from the code you have.  I'll leave that fun to you.
We could, rather than maintain one huge vector, perhaps maintain a list of structures that represent a 'chunk' of 10 items. Such a chunk would be able to record where the first and last item is within the vector. Once we determine that the chunk is no longer needed (it's become empty), we could store it in a 'free chunk cache' or destroy it. Either way we'd remove it from the beginning of the list. We might even want the chunk size to adapt itself to reduce memory usage while maintaining good data locality - however these concerns are probably beyond the scope of your question.
std::deque is the standard multi-purpose queue container. If you look at the documentation you can see the complexity tradeoffs in action. You will also notice that this container does not allow random-access operations. 
A queue is a "FIFO" container: the first element in is also the first element out. It means that you won't discard elements from the end you insert them into: so the right container isn't std::vector, which is optimized for insertion/deletion of the last element, but std::deque, which provides fast insertion/deletion at both ends. With std::vector, you need to reallocate memory every time you delete the front member, and that's inefficient.
It means we're going to destroy one int (zero cost) followed by 999,999 assignments as the remaining items are shuffled to the beginning of the vector.
Finally, there's the obvious: one could use std::queue.  I am assuming that you did not because you are still learning C++ and wanted to try to create a queue yourself.  That's fine as a programming exercise, but of course in real code, it's almost always better to use part of the standard library.
Looking at some documentation for this method on cppreference.com (a reasonable first port of call):
The code as posted has inconsistent indentation which makes it hard to read and understand. Pick a style and apply it consistently. 
pop() would now be performed in O(1) time, which for this particular operation would now be (literally) an order of magnitude better.
For a vector of ints this may not be a huge problem, depending on your application. In the general case, doing a million of anything every time we dequeue a value has a bad feeling about it. For a vector of something more heavyweight it could start to become a noticeable performance burden.
Of course, you might not want to use std::deque directly, especially if you're looking for a good exercise. Then I'd suggest you implement your own. As cppreference says: