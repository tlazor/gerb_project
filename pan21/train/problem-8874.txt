Using traditional image formats (TGA, BMP, PNG, etc) you're going to solve one or two of these bottlenecks, but not the other(s).  I'd recommend that you solve them all before looking at threading/etc and there is one texture image format that is going to do this for you: DDS with DXT/S3TC compression.
Of course there's no such thing as a free lunch, so it's necessary to warn you that this is a lossy compression format, and so you may see some compression artefacts.  On the other hand, if it's good enough then it's good enough, even if lossy.  It's also necessary to warn you that S3TC texture compression is burdened by IP and so may not be available in all drivers, but in practice it's ubiquitous outside of open source implementations.
In general terms you'll have the following bottlenecks for texture image loading (since you mention MacBooks I'm going to assume that you're using OpenGL):
Despite the name ("Direct Draw Surface") this format is in reality just a normal binary image format and can be easily loaded by OpenGL too (using the GL_ARB_texture_compression and GL_EXT_texture_compression_s3tc extensions or GL 1.3 or higher).  It provides the following advantages for you:
Have the ImageLibrary manage background task(s) to load images from disk steadily (individually, so they can be retargeted if necessary as the front end demands specific images that have not been loaded yet).
Create an ImageLibrary class responsible for loading images from disk, and supplying them to the front-end on demand. 
I suspect the bottleneck is not disk I/O, but rather the current need to perform all the IO serially. Parallelizing this task should help.
Decompression can be solved by using image formats that are fast to decompress, or that don't need decompression at all.  Here your use of PNG is working against you as PNG is quite slow to decompress.  This will be one of your primary bottlenecks.  Note here that not needing to decompress at all and smaller file sizes are not mutually exclusive; we'll discuss that later.
This framework could also morph into a disk cache over time, by tracking a most-recently-used time for each image, and retiring the oldest as needed to make room for newly demanded images.
Disk I/O can be solved by using faster hard disks or smaller image file sizes (this includes those that compress well) and from your question you appear to have that well in hand.
Load to GL/hardware overhead at first glance looks like just a bandwidth limit, but that's not all.  Since most GPUs like texture image formats to be laid out in BGRA order, if you're loading any other format your GL driver has to do a lot of extra work to convert it to what it likes.  In particular, the frequently seen GL_RGB format is a worst-case format, as it may require the driver to both expand to 4-component and to reswizzle the data.  This is further discussed here: http://www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads and here: http://www.opengl.org/wiki/Common_Mistakes#Slow_pixel_transfer_performance and is likely to be another one of your bottlenecks.