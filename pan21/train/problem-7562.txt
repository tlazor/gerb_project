Note that in some cases you may need to expose "debug only" APIs out of a subsystem to implement these commands. Languages with preprocessors, like C or C++, can help you ensure that relevant code is only available in debug builds if you like. In other cases, the second of the above two options often lets you expose debug commands that otherwise access private APIs of the subsystem since the subsystem itself is doing the registration.
As for actually hooking up the commands? There's no magic. At some point you're going to have a big list of DebugConsole.AddCommand("spawn", new SpawnCommand(currentMap)) style code. The two basic options are
There are pros and cons to both. Depending on what information you need each command implementation to have available, it may make more or less sense to take one approach over the other. 
The debug console API should have a method to associate commands the user types in it (such as spawn zombie) with actions. The command pattern, which you've already discovered, is one such method of implementing that association. The debug console exposes an addCommand(string, ICommand) method which associates a string ("spawn") with an instance of a command -- which could just be a delegate or function pointer, it need not actually be some concrete ICommand subclass or whatever. That command is invoked by the console, and the command parses the remaining arguments the user typed ("zombie") to determine what to do.