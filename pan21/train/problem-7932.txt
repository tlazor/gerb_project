When you delete and re-insert LOB values, it will allocate new pages for new LOB values, but I repeat, even if there will be contiguous pages, the reading will be slower than in-row data pages 
If you ask about LOB pages themselves, even if SQL Server allocates pages for them in contiguous pages it will never read them efficiently. LOB data storage is not optimized, and server always spent more time to read them. When LOB value has more than 5 pages, LOB data is organized as a binary tree but it's not an efficient tree as used for indexes. And even when LOB value is less than 5 pages and the pointers themselves are stored in row, reading LOB data is slow.
If you ask about PK fragmentation the answer is yes, it's possible. Your binary values are about 10kb~17kb, as you said, and those never go in row but always go to LOB pages. When LOB data (varbinary(max)) fits in 5 pages (32Kb, your case) all the (max 5) pointers to LOB data go in row, so if you pass from image of 8Kb to 16Kb, your row grows at 1 pointer size; when LOB data size is greater than 5pages it's different, only 1 pointer goes in row that poits to the LOB structure root(which contains other pointers to LOB pages), but it's not your case.