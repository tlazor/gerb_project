You should read in a byte[] from both positions in the input file, merge into a third byte[] and then write that out to memory. The aim is to chose byte[]s that fit in memory but are large enough to cover the costs of IO calls.
I recommend that you re-work that part of the solution, then re-post as a 'follow on', but then also include the calling part of the function in to your question so that more of the overall structure of your solution can be reviewed.
Of course, this is what a buffered stream will do for free. You could just have two buffered streams into the input file and one into the output file. The main problem is j--, which isn't really possible in a buffered stream without throwing away the buffer all the time.
I struggle to understand the difference between the a and b files. It appears that you are copying the first chunk of data from the a-file to the b-file, and then merging from two different places in the b file back to the a-file.
I would recommend instead having two read-poitns on the b file and then write back to the A. The extra copy is slowing you down too. There's no need to copy from a-to b if you can jsut swap them...
Two input buffers of length 4096 and one output buffer of length 8096 will probably do fine. Then use read(byte[]). You might get smaller reads than the 4096-at-a-time, so be sure to check the return value.
The variables a, b, l, r, m i, j, and k are also all horrible names... you should rename them to be 'self-documenting'. They should be called what they are. The variable l is particularly problematic because it is so easy to confuse with 1.
as the writeInt moves you on for you. Note that not seeking is important when using buffered streams if you want them to stay fast (hence the need for two buffered streams on the input file, rather than 1 with seeking).
The most glaring problem in your code here, is that you open and close the file on each call to the merge function. You should instead open it once in the calling function, and pass in the already-open files to the merge method. The open and close operaions are both slow, and should be minimized.