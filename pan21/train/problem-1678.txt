I am very curious, if this code follows common best practices and I am wondering how to improve the code in terms of performance and readability. 
Long multi-line comprehensions can be hard to read. In 6 months will you remember why the range is (x-1, x+2) and what all the inequalities are checking.  For things like this, I find something like this more readable:
I don't think you're making good use of functions here. For the most part, you have everything tucked inside of update. I think that function is far too large, and doing too much explicitly. I would, for example, create a function called should_live or something similar that is passed the cell's current state and number of neighbors, and returns if the cell should be alive the next tick or not.
You do break some of that functionality off into a local function neighbors, but I don't think it's ideal the way you've done it. I would make that an external function, and I would call it n_neighbors or count_neighbors or something similar to make it clearer that it's a function that counts neighbors, not a collection of neighbors. You could also clean up that long list comprehension guard by creating a is_inbounds function that checks if a point is i bounds or not. 
I'd also rename update, as is isn't actually updating anything. It's gathering information then returning a decision. 
I took awhile to understand the logic for setting new_val.  Add some comments to explain the logic.  Maybe rearrange it to make it easier to understand when you look at it in a year:
If you want to give the function a name, then it shouldn't be a lambda.  They are generally good for very short functions to pass as an argument to another function.  For example, sorted(list_of_tuples, key=lambda t:t[1]) to sort on based on the second element of a tuple.
I would not have code top-level like you have it here. Having the code run just because you loaded it will get annoying if you ever change your workflow to involve a REPL. I would tuck the routine into a main function, then maybe call that function from a if __name__ == "__main__" block.
These libraries are full of functions for operating on arrays.  You could write this using np.where and scipy.ndimage.convolve like so:
As a practice exercise, I implemented a cellular automaton (Conway's Game of Life) in python (with help from this tutorial).