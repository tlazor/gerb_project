If you must have them separated into two tables, go with option 2 but leave off the id field and give the tables a true 1:1 relationship by assigning the same (guest_id, event_id) primary key to both records when you create them.  That's called a "horizontal split" of the event_guest table by breaking off the settings field into another table.
Guest and Event make up a Guest_Event entity, that may (potentially) exist without a Setting. So in Guest_Event table you'll enforce constrains on 2 columns Guest_ID and Event_ID.
If there is always an event_guest entry for each settings entry, why not combine them?  Simply have a event_guest table with a compound primary key (guest_id, event_id) and a settings field.
It depends on how the application will be using these tables. Single column ID for Guest_Event and Setting will do if you'll be extracting these IDs and then reusing them in Where clause.
It looks like event_guest is a many-to-many relationship table.  The id field is redundant, you only need a compound primary key (guest_id, event_id).  That will guarantee that all guest/event pairs are unique.  Then put an index on event_id so you can do a reverse lookup (from event to guests).
Covering indexes (ones including all key columns in all combinations) will help your performance, if you have enough space to store them and time to update them.
Another question is How to define keys for Guest_Event and Settings objects: as 2-3 separate columns or a single column? 
After your description, settings come to existance upon the condition that a guest and an event are already linked, therefore option 1 would be choice, for that model will convey that concept to anyone viewing it.
Your schema has no object specific data in Guest_Event table: if Guest_Event table has only keys, then it is not needed: you can use Settings table to track Guest_Event by using Setting like "G_E Instance Number ## Exists".
There is some talk about surrogate vs composite keys. Anyway, Smaller PK => smaller indexes, but as in your case you'll be going with int surrogate keys for guests and events tables, then the composite key will also be small, meaning that performance loss potential against surrogate key is small, especially if you'll be searching by guest/event.
However if you need to get a Setting and application always knows Guest_ID and Event_ID, then getting individual Setting ID is an unnecessary step.