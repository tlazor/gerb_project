Now, you have device files that let you talk to storage devices on a low level (/dev/sda, etc.), but storage devices are really stupid.  All they can do through the UNIX API is give you a LBA, or block, of data (512, 2048, or 4096 bytes) or store it (modern hard drives have tens of millions of LBAs, if not more).  They don't organize it into files by themselves.  For example, writing to a file might involve writing to many LBAs, and you need a system to keep track of which LBAs belong to which file.  This is the job of the filesystem layer of the kernel, translating requests for operations on files to requests for operations on devices and using part of that device storage to keep track of everything.
The device is a piece of hardware either directly connected to the CPU (rare unless it's a bus) or indirectly connected via a bus (which is itself a device).  Devices can communicate with the CPU using any of four methods: memory addresses, I/O addresses, DMA channels, and IRQs.  (The age where you had to be concerned with those is long gone, it died with ISA).
If you issue requests for these operations on a device file, the requests don't go to the filesystem layer of the kernel, but directly to the device.
One of the reasons we have operating systems is to provide a common interface to talk with types of hardware.  So, those who write programs can use this common interface instead of being knowledgeable about the low level details of each specific device.  This makes programming quicker and easier.
Linux, being a UNIX-style operating system, uses one particular "common interface" called the UNIX API.  One design goal of UNIX is to make everything look like a file.  The operations you can perform on files are: create, read, write, seek, and close.  For things that don't fit neatly in these concepts, there is another operation called ioctl that's sort of a "catch-all" for everything else.
The filesystem layer is what implements the whole directory system.  It's a tree structure, and you can attach, or mount block devices at various points in that tree.  The filesystem layer needs to know what "low-level" device that has files, and that's why you need to mount it.
The driver is a piece of software that presents that common interface to the application side and then translates requests using that interface to a form the device can handle (using the aforementioned memory addresses, I/O addresses, DMA channels, and IRQs, or possibly calling other drivers), and back.