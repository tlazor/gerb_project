This all works for event-based input.  Game logic controllers for player avatar handling should be built specifically for polling input; also for key bindings.  The playing state might take all raw input messages and deliver them into a PlayerInputController class which looks up keybindings, handles analog vs digital inputs, etc., and then maintains an internal state like IsMovingLeft or whatnot.  The actual game logic can then receive events from the input controller, if you prefer that method, or it can poll the input controller every frame with something like if (m_InputController.IsMovingLeft()) move_player_left();
For UI elements, a UI controller manages all the complexity of focus, tabbing, etc.  UI states like PausedState or whatnot is responsible for taking any input messages and forwarding them to the UI.  This allows UI elements to be visible while the UI is inactive, which for instance is handy with a layered UI system (e.g. a state for inventory management might keep drawing while a pause screen is active with a small pause menu in the middle of the screen).
Input has "controllers" which register themselves.  There are implicit priorities where state controllers are run in state stack order.  A DOM Events model is used.  The input event is delivered to each controller in order until one "consumes" it.
For keyboard and mouse DOWN events (a key/button is pressed), the controller that consumes that input is then recorded for that specific key.  The corresponding UP event is delivered directly to that controller and then the registration is cleared.  Also cleared during app focus switch to avoid alt-tab bugs.  It can also be handy to clear them when the registered controllers change, so e.g. holding the left arrow doesn't keep moving the player when a menu pops up.  If a controller is bound to a key and is removed for any reason than an actual UP event, one is synthesized and delivered before the controller is unbound.
The PlayingState controller is responsible for player game input rather than a particular game object.  The state moves the player avatar rather than the avatar moving itself.  It is possible and not all daft to have the objects manage input themselves, especially if you use a heavily component-based object system for menus and complex gameplay features, but I've personally felt that input game logic is much easier if all gameplay input handling is in a single place instead of strewn around a variety of objects, plus it ensures that the player avatar ceases to receive input when menu pops up.