THE PROBLEM with this is twofold: 1) It's very Ubuntu/machine specific right now (assumes card is at sdb, etc 2) It needs an actual card, so doesn't lend itself to a build machine.
You can basically think of -P as the "pretend this file is a disk" option. An example should make this clear. This command creates a 4GB image file filled with zeroes:
After that, the auto mounter seems to kick in and get the sd card remounted, so we can do things like:
So, all in all the accepted answer remains 100% correct, and provides valuable insight into what's going on under the covers. But if your distribution's losetup supports the -P option, you can just use standard partitioning tools and let Linux handle creation (and deletion) of the loop 'sub-device' for each partition.
After one of us does that, then we can use dd to copy the contents of the card and share it with each other, making more sd cards using dd.
The accepted answer to this problem is factually correct, but—as I write this five years later—there's a simpler approach that ought to work for most people. Manually juggling offsets and creating multiple loopback devices is, in general, no longer necessary. The 'secret weapon' for creating virtual filesystem images in most Linux distributions nowadays is the -P option to the losetup command:
I tried using dd to just make an 8G file and then ran sfdisk on that (everything's a file, right?) and that part worked. But it's not clear how I'd run the mkfs parts to work, they seem to want to work on block device files, not sub regions of a single file that has a partition table embedded in it. And then I have the problem of mounting it. I assume I use some incantation of mount -o loop, but again, not sure how to do that on the sub region of the virtual image file, I've always just down that with .iso files.
To populate these partitions, you can create filesystems using the loopback devices /dev/loop0p1 and /dev/loop0p2, then simply mount them, and copy files into the mount points. The process looks sorta like this:
Note that Linux created new loopback devices on your behalf for each of the two partitions: /dev/loop0p1 and /dev/loop0p2. You can see their relationship with /dev/loop by running lsblk:
We have a scripted process that builds up an embedded install of Debian Jesse on an sd card. The relevant parts of the script look like this:
The following command maps the first available loopback device to this file, and does so in a way that the kernel interprets the bytes at the beginning as a partition table:
(Feel free to be pedantic, I am not an expert (obviously) with this kind of stuff. I get some of it, and other parts seem a bit magic...)
It may seem like a small thing, but passing -P means that you can now use tools like fdisk to partition the 'disk' mapped via /dev/loop0. Here, I create a 128 MB partition at the beginning, and a second partition to house all the remaining space: