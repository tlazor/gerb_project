I don't wanna have to guarantee super fast server response to keep the game going lag free. I'd rather go with more loose discrete control of key variables and instances. Like store user's action on a fifo buffer on the client, and push that actions to the server gradually. 
I don't wanna waste to much resource on this matter, since it's going to be initially a single player game, that I may or would like to introduce some kind of ranking, trading system later on. I'd rather deliver better more cool game features instead.
To continue from where we left off - the ideal solution is to do all the important work on the server. Since you haven't really said what your game is (Action RPGs can be along a wide spectrum) here are thoughts on how to hide the delays for the user without compromising security in a general way.
In order to decide if a player is cheating or not, the server will be taking as input a series of key info data that may be evidence against the cheater on some consistency checks that will process at each request.
Well, I've been busy lately and wasn't able to implement or even plan nothing really solid. But I've come up with some ideas that will probably disencourage most of the cheaters in the first builds.
 if  (euclideanDist(enemy.X, enemy.Y, last.enemy.X, last.enemy.Y) > (timeDiff *hero.moveSpeed) + tolerance )
Now I wanna measure roughly how hard it is to implement a server side checking that is agnostic to client input, that does not mess with the game experience so much. 
It is worth it to investigate what working on games in the DOS era was like. A lot of the solutions that were devised to do an RTS on such limited hardware apply here for the delay introduced because of HTTP.
It is worth bearing in mind that not all games can be made this way. It doesn't make much sense for many of the more complex action games to do everything on the server. However there are some general tricks to speed things up:
There are no silver bullets here. Network gaming is some of the hardest stuff you can endeavor to build as a programmer. And you will mess things up. Keep your source un-obfuscated and offer in-game or out-of-game rewards to people that help you find errors with the game. Rather than cheating, some of the crackers will turn their exploit in for the bounty.
As I told on one of my comments, the game will have no Exp/Leveling system, and I'll have character progression more dependent on loot/craft/equipment (there will be other stuff, but that's the core). That's interesting cause, since almost everything players cheat on boils down to killing mobs and getting the drop, and since loot is generated randomly on the server, I can ruin the drop if I detected or suspect that player used some sort of cheating.
Well, yesterday I asked on anti-cheat JS, and confirmed what I kind of already knew that it's just not possible.
I'd love to see a elegant, generic solution that I could plug into my client game logic root (not having to scatter treatments everywhere in my client js) - and have few classes on Node.js server that could handle that - without having to mirror/describe all of my game entities a second time on the server.
I'll process and keep on the server, of course, some of the keys actions for gameplay, the ones that players I'll be most interested on cheating. Like spawning, shopping, dealing/taking damage, killing/generating monster loot.
The more info I get as input along with request, more checks I'll be able to do.  And depending on how much a I player do suspect actions, I can ban his IP or apply cloaked gameplay penalties on the server side.
I don't wanna do monsters AI and/or track it's movements in the server, or do collision detection or anything that may overload the server with requests or processing.