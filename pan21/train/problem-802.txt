Use: When I'm making code changes I test and commit often. This allows me to go back as far as necessary when I screw up. Plus, by comparing various revisions and copying parts of the code I don't have to lose every change just because I need to revert to a previous version to fix some stuff-up in another part of the code.
If you go with the "checkout directly into the customer's site" distribution model, you'll want to be sure that your server excludes access to the version control directories so that people can't browse to http://example.com/.git/ and peek into your internals. Also, I would definitely have a test and production virtualhost for each client in order to make sure that a site update doesn't go haywire.  Especially if you're making custom changes to individual clients' files, then you'll need to handle conflicts before changes go live.  In this case you'd checkout/update the test virtual host, and when everything works right, you'd copy the test virtual host to the production virtual host.
Deployment depends on how much you have to "customize" for each of these sites.  If they're identical except for a config file or two, you can just check out a copy of the code to them, and make minor changes.  As needed, run your version control's update command for each of the clients.
If you decide to go with subversion can I recommend trying the Bitnami Trac stack;  http://bitnami.org/stack/trac
Deployment: I currently use subversion hosted on Windows boxes, both at work and at home. Windows only because that is what is available. Otherwise it could just as easily have been another OS. The key for non-tech users i to give them a simple GUI based tool to handle imports, exports, commits, diffs, etc. What tool to use will depend a bit on the OS and VCS system used.
At the end of the day the tool is less important than the mindset you need to instil in your developers. Hopefully they'll soon see that version control is A Good Thing becuse it stops them losing work and allows them to revert from dead ends that are leading them nowhere back to known good states. The benefits outweigh the (slight) overhead.
If you're just starting out, I'd strongly suggest using a distributed version control system like git or mercurial. This is the general trend in the world, and there are a lot of advantages. It's easy to work in a disconnected mode, with no network dependency and the ability to do private, unpolished work still under version control, checking everything in centrally when it's ready. 
It's helpful to have everything versioned, even for designers. And if implemented well with good training, I think they'll find it more helpful than burdensome.
Pitfalls: I personally haven't come across any during my admittedly fairly limited use of version control.
It simplifies setting up subversion for you, comes with a ticketing system (which you can choose to use at this stage or not) for keeping track of changes & bugs, and a wiki which you can use to document how you want your developers to use the system.
Added benefit: You can give access to the source repository over a VPN or secure connection, allowing users to work from home or elsewhere. e.g. I might get an idea at home and edit my work code there and then, before I lose the thought.
Version control everything. There's no point having HTML files under version control and then having a site completely screwed because of a change in CSS that is not being controlled, and therefore cannot easily be reversed.
And, not to resort to appeals to authority or anything, but check out what Joel Spolsky has to say on the topic. (Choice quote: "Subversion = Leeches. Mercurial and Git = Antibiotics.") Among other things, he makes the interesting point that these new systems use a new mental model, different from traditional version control â€” which is why getting into this kind of approach from the beginning is a win.