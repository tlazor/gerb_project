Here, we run this code in as many query windows as possible, in order to test the upsert procedure for deadlocks and to get a sense of performance.  The GO 10000 will execute the INSERT statement 10,000 times, simulating quite heavy activity on the table.  The more concurrent executions of this statement the better.  I was able to get at least 5 sets of this code running concurrently, and experience no deadlocks, no errors, and the 50,000 executions completed within 8 seconds on my development machine:
You may notice that I'm not using @@ROWCOUNT to determine if the update was successful, as Aaron used in his answer.  You could decide to use @@ROWCOUNT since it will be slightly quicker for SQL Server to run the stored procedure; however I chose to use a table variable since it makes the code more robust if you decide in the future to add code between the update and the insert code that might affect the @@ROWCOUNT value.
Since this table is quite likely to be very active if you have update history for multiple tables stored in it, I've added a column PadOneRowPerPage that is a char(5000).  This column ensures only one row is created per page, which will reduce allocation and write contention on this table.  You will also note I have DATA_COMPRESSION set to NONE; since we are intentionally filling each page with only a single row, data compression is not required and may in fact be detrimental.
Here is the stored procedure to do the actual upsert.  It includes a parameter @CallLevel which is used to control nesting into the procedure to a maximum of 5 levels deep.  This allows the procedure to call itself in a retry mechanism if it could not obtain an app lock:
I prefer to be a bit more defensive when performing an upsert, so I use sp_getapplock and sp_releaseapplock to ensure exclusive access to the upsert'd table.  