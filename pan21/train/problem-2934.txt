you method is doing a search, a filtering and a conditional grouping, these are different tasks and need to at least be method separate, certainly not be all on one or two lines.
could the OrderByContainer method not even be a method on a ContainerOrderer interface of some kind defining the rules for deciding relevancy? would that not separate your concerns, make testing easier and over all make it clearer what each piece of your code is doing?
You are trying to define relevance in your story entities, I get it, but a hard coded nest of grouping ids is scary to read and very easy to mess up. 
Of course if I implement it as an enum, then I will have to do more casting to persuade the compiler to allow integer values and enum values to be interchanged, but the code for RelevantContainer itself is much simpler. Is there a clear choice for which approach to use here? If it matters, this is a Xamarin Android project.
I'm writing a text adventure editor that identifies various StoryEntity instances by name, among other means, but the name is the primary way for the user or player to refer to them. The name doesn't have to be unique. For example, there may by many instances of "North" which each refer to a different StoryEntity depending on where the player is, or the context of which container you're referring to. Sometimes I know the name will be ambiguous, but I want to give preference to names of entities that are near the player. Other times, like when the user types Edit North, they may be dealing with a design-mode copy of the data where the player is always in its designed starting location, but I have another way of identifying the "current location". Still other times, I don't want to waste time sorting the results at all because I will handle all of them equally. So I updated the function that retrieves a StoryEntity by name to include a parameter indicating whether and how to sort the results by relevance:
Unless I am mistaken you are dealing with a int32, string key value pair, why not use a simple struct consisting of an int and a string?
A level down from that is, if the current gamestate and name match a certain condition, filter the returned Entities. 
I have devised the following solution based on apieceoffruit's answer, and am interested to know if this is a step in the right direction and if there are further refinements to make. (I tried to apply this as an edit to that answer, but that got rejected -- too much new content I guess.)
you are basically talking about a rule engine, Given a name and a gamestate, find the right StoryEntities.
I didn't understand how you could have a void function be a parameter to OrderBy, so this was the next best thing I could work out. Also, I don't know if it seems redundant to pass a StoryData-based object to a StoryData function as a parameter rather than assume the same context, but there are cases (the last example above) where the player and container information need to come from a different instance of StoryData due to the different player location, so I think it makes sense.
although as this is CodeReview I have to say, your use of ternary operators nested in linq statements with more terniaries is damn near illegible.
Now my question is how can I best define RelevantContainer so that it allows pre-defined values as well as arbitrary int (container ID) values? I can imagine implementing it as an enum or a struct: