Lines will be seperated by newline characters - \n. Since /dev/zero doesn't return any newlines, all data (all the null-bytes read so far) is still considered to be the first line, and thus kept in the buffer. And tail will continue until it found the end of the file, which will never happen for /dev/zero. So you'll never ever get any useful output from tail /dev/zero.
tail (with default parameters) will return the last 10 lines from the argument. Since /dev/zero is a character device, it will start reading chunks of data from it, until the end (regular files are scanned backwards). The read data is kept until 10 lines have been found, then the first lines are evicted from the buffer.
Luckily, you're on a 32-bit system and have plenty of free memory, so the memory available to a single process (typically 2 GiB, but might be different depending on kernel configuration) is exhausted pretty quickly and without swapping, and the command is aborted. If you try the same on a system with less free memory or a bigger address space (64-bit system), tail will eat up all memory it can get, get the kernel to swap out as much as possible and eventually you'll still get a memory allocation error. Or trigger the OOM-killer. But still no null-bytes on stdout.