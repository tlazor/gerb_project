We are implementing a clustered index on gn_Time and the Instant File Initialization - both are beneficial independently from this specific problem  - thanks!
We discovered this because we were able to have a look at the locks when we got a time-out, and we noticed the table lock. We are moving the delete gn_AuditTable . . . out of the transaction, and possible split it into smaller batches, not to trigger a table lock.
As for the design of your table: time series are usually clustered by the time value, because most queries cover time ranges (eg. 'select all events in the past 3 days') so that would make gn_Time your likely non-unique clustered key candidate. 
Is your database large enough? Are you sure your INSERT don't trigger auto-growth? If your deployements don't have Instant File Initialization enabled then this is exactly the behavior one would expect when a database file growth is triggered: random blocking of writes for the duration of file growth and initialization. You could also be experiencing log file growth (this at least can eb quickly identified by looking at the Log Growths performance counter) but for log growths to occur you need to have a non-simple recovery model and a backup strategy that is basically absent (ie. log truncation does not occur).