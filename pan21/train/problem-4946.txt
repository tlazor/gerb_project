This is how stored procedures work by default.  The stored procedure isn't wrapped within a transaction automatically.
By creating an Extended Events session to monitor the sql_transaction event, here is the output from executing dbo.ChangeValues:
A transaction is a statement or set of statements that will either succeed or fail as a unit.  All DDL statements are in transactions themselves (i.e. if you update 100 rows but row 98 throws an error, none of the rows are updated).  You can wrap a series of statements in a transaction as well using BEGIN TRANSACTION and then either COMMIT or ROLLBACK.
If you want the stored procedure to stop when it hits the first error you'll want to put some TRY/CATCH login in there to return in the event of a problem with command 2 for example.
separate each of the parts with a BEGIN TRAN and to a check if the transaction was successful. if it was commit it, otherwise do a rollback, since they are all executing from the same level you will be able to commit each section separately without having to rollback all if one fails.
A batch is a series of statements that are executed together.  A stored procedure is an example of a batch.  In a stored procedure, if one statement fails and there is error trapping (normally TRY/CATCH blocks) then the subsequent statements will not execute.
I suspect your issue is the batch is getting cancelled when an error occurs because either the stored proc itself or an outer scope (like the application or stored proc that calls this procedure) has error trapping in it.  If that is the case this is trickier to resolve since you need to adjust how you handle errors at whatever scope is trapping them.
As you can see in this above screenshot, there are separate transactions for each of the four statements.  The first 3 commit, and the last one rolls back because of the error.