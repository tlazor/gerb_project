If you were to open the file in binary mode (i.e. with "rb"), you would have a different problem; a binary stream is not required to support SEEK_END.  So you're between a rock and a hard place here - in fact, CERT FIO19-C says
A decision to exit is very important, and it shall not be delegated to an utility function. Consider returning an error code instead.
Your code allocates memory with malloc(), which the user is required release with free().  This prevents you using a different allocator in future, or for specific platforms (e.g. you might use mmap() on platforms that have it).  You should either
You open the file in text mode, but you attempt to use ftell() to measure the size.  But the meaning of this result is not specified for a text stream, only that it can be used as input to fseek() to return to the same place.  On systems where text and binary files have different representations, this could cause your code to fail.
The function read_certificate_file() should make sure char *file_location is not empty before using it. Never depend on input being the proper value.
You're assuming that the file you're reading does't contain any nulls.  This may be OK, as you're not opening the file in binary mode, however if you decide to reuse the code for binary files, returning a null terminated buffer without a size field is going to cause issues.
As forsvarir points out fseek() and ftell() may not give the results expected in all cases. See this reference.
I know your main is just a test harness to demonstrate the code, however it's best to always use appropriate memory management.  Your function is allocating a buffer using malloc, you should be freeing it in your main.  By including this in your example it demonstrates that you recognise responsibility for the returned buffer is sitting with the caller.
The code would be much more readable and maintainable if the function read_certificate_file() was broken up into additional functions. Each of the variable assignments in this function should be a sub-function. This is known as the Single Responsibility Principle (SRP).
Printing error messages from inside an utility function is less critical, but is also dubious. For example, the function cannot be used in a GUI application.
Your function doesn't return the number of characters read.  It might not matter for you, if your files are known not to contain NUL characters, but for a general file reader you can't depend on that.  The fact that you open it text mode suggests you're expecting printable characters, but I can't tell that from the name or comments.