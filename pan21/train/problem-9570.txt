It seems so clean, so simple, and so easy. Except that it doesn't compile! That's because std::chrono::high_resolution_clock::time_point is not the same as BaseClock::time_point (and cannot easily be converted, if at all possible).
One aspect that's missing is that this interface only gives access to now() - it doesn't handle the other clock-related actions that can cause slow tests.  In particular, you'll want sleeps and network- or mutux-related timeouts to respect the mock clock's idea of time.  To achieve that, you'll need to redirect those timeouts to mockable methods.  That's a bigger job, but will give you a much more useful test regime.
I really don't like the Clock singleton. Yes, it is easy to just ask a global clock. Yes, it is also easy to screw all code depending on this clock by changing the underlying instance.
For example, a test setting Clock to a mock but not restoring the original clock breaks all other tests that assume the default clock implementation - making test failure dependent on test execution order.
I think that when I made something like that (many years ago, and in a different language), I ended up with the MockTime storing an ordered list of future events; whenever control entered its code, it could advance the time to match the next event (which could be the end of a sleep, release of a mutex, or an interrupt from an external (mocked) thread, for example).
But in most cases, a simple Timer abstraction can fulfill all clock needs (comparing some time_points with some relation). A simple Timer interface could look like this:
Instead, take a reference or pointer to a timer as parameter. This allows you to pass in a clock where needed, without changing (or corrupting) everyone elses timer.
The use of a singleton will limit your possibilities, as hoffmale's review points out.  It completely prevents concurrent testing.  However, you'll find that getting the Clock instance to the code that needs it can easily add lots of "tramp data" to intermediated method signatures.  I try to limit that by passing a factory/registry interface that allows classes to access the system interactions they need - time, filesystem, network, etc.  In the tests, populate a mock-factory with the necessary mock objects, and in production, pass a concrete-factory that gives out objects with real system access.
Now the only exposed part of the interface is the duration. And it is easily extensible to other time sources (e.g. Win32 QueryPerformanceCounter) or mockable.
While I think the underlying idea is quite nice, the actual implementation and design has some issues.
The only reason to expose time_point values is to extract time differences between them. But that only matters if arbitrary time_points are to be compared.
Let's start with the less obvious one: How would you actually use Clock or BaseClock with std::chrono::high_resolution_clock or std::chrono::system_clock?