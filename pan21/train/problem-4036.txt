No modification turns out is a big deal even without the constraint of functional languages. For example, such a data structure is "persistent", if you are willing to save all the previous versions, we can go back in time to see what it was. We can also freely parallelize it because all memories are write only once and stay there forever (until it is garbage collected of course)
But isn't inserting into a binary tree also a modification - yes, it could be - but with smartness, one can simply return a clone of the node with a new sub-tree, that way we can avoid the problem of modification by returning a new tree instead. If we use the same trick for the hash table, we would have to copy the hash table, but all we have to do now is to clone the path (which is a constant size)
The Achilles' heel of hash table is that it requires modifying an array entry (or insert to the overflow list) by modifying it. This is not functional language friendly.
But we still love to have the expected constant time lookup/insert/remove, so we compute the hash code of the item as usual, and then we insert it into a binary tree by following the binary digits. For example, '0' goes left and '1' goes right. 