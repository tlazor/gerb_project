To expand a bit on Peter's answer, this .d pattern allows for simpler addition and removal of configuration files: for a given .d program, the admin has the ability to simply copy or remove a file into the .d directory without having to edit an existing config file.  
For instance, if you wanted to add a cron job to your system, you could edit /etc/crontab with your new scheduled job using your favorite text editor.  This is fine for a single server or handful of servers, but try doing that on 100 servers if you work in a datacenter/cloud environment.  In the latter case, you could use something like sed with a temp file or a tool like ex to write the file in place, but there's a bit of risk here if you haven't crafted your command properly.  Indeed, I've seen config files completely nuked due to a typo in these edit commands.
Finally, every program that has a .d directory may have their own implementation as far as how the files are sourced, such as include order and configuration overriding.  So whenever you decide to place a file in a .d directory, always verify that it does what you want and don't just assume it works like it does for another program that has a .d directory. 
Now compare that to placing a file with your scheduled jobs into /etc/cron.d.  You just copy the file into it, and the next time cron runs (typically every minute), it'll see the new file and will source/process it accordingly.  This is great as Peter states if you like to roll your own packages:  the /etc/cron.d file is just another file in the package archive that gets installed.  On removal of the package, the cron.d file is removed and your cron no longer runs.