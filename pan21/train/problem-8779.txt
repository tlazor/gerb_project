There's no difference in nodes with 2 links or 1 link. If it's the first node in a list it just means prev=null and if it's the last next=null.
standard java LinkedList implementation. Notice which of their complex methods became easier in your implementation, and which things are super simple in their implementation but where you are struggling.
If you start implementing the different methods for adding, removing, etc. you might have on singly and doubly linked lists, you will find the implementations are quite different.  So much so that I think it would be simpler to have two completely separate classes.  They could both implement the java.util.List interface.  I'm a huge fan of code reuse, but I don't think it's a good idea in this case.  Trying to share some code between singly and doubly linked list would end up making the code less readable.  This is just a guess since I have not actually tried implementing them.
Usually linked lists keep most methods as private and the actual nodes cannot be accessed by the public API.
Like you have noticed yourself you're violating Liskov's substitution principle. The easiest way for me to think about this is by imagining a method taking the base class as input: 
Don't use inheritance if it's just to write less code. Use inheritance if it makes sense to add behaviour to a valid base class.
The answer has to be no. It should have exactly the same methods as the BaseClass (I mean, the name, parameter types and return type. The implementation can of course differ). 
If we take a quick look at the standard library we find the LinkedList class. Creating a list, adding/removing elements, getting an iterator, etc... are all called on this class. The internal representation of a list however, is a Node based.
You want to implement SingleNode in terms of a Node interface. The public API would accept Nodes (never SingleNodes), and would return Nodes. That gives DoubleNode's getNext() license to hand back a doubly linked object, which is a Node.
If there are methods that are the same for all of these classes you can choose to change the interface into an abstract class that implements those common methods. That way you reduce the amount of code you write in a way that actually makes sense.
It could be a fun exercise to write your own implementation of a linked list where you do handle special cases with specialised classes (be sure to implement the List and/or Deque interfaces). In that case I would start with a Node interface like J H suggested. This interface should contain ALL the methods you expect from a node (for example: hasNext(), hasPrevious(), add(), ...).
Then think about which cases you want to handle with different classes. (Like FirstNode, LastNode, DoublyLinkedNode, EmptyNode).