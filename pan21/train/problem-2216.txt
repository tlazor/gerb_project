Which processor (be it real, core or hyperthreaded) a process runs on depends entirely on the operating system's scheduling system.  It is this scheduling system (influenced by the affinity settings) which decides where a process should run and when.  Processes and threads can switch between processors and cores at will as the scheduler sees fit.
For example lets assume we have two processes with two threads each and a single threaded application, all working hard on a dual core processor (or dual CPU, makes no difference here)
As far as the operating system and applications are concerned each core is a separate processor and is subject to the same affinity rules as having multiple processors.
I understand that a multi-core processor can run multiple threads of the same process at the same time using its different cores.
If we then go and set up processor affinity for Process B to limit it to one CPU then all the threads of that process are bound to that CPU as well and will not run on any other CPU.  Doing the same to Process C will result in no real change as it can only run on one CPU at a time.
From my limited knowledge of operating systems I believe that every process has at least one thread, and it is these threads that get scheduled, not the processes themselves.  The process simply holds information about the program and the threads that it has set running.  This way a single threaded application gets the same treatment as a multithreaded application, but the multithreaded application can use resources better.
Processes and threads (as in multi-threading) are OS level constructs. Once you get low level enough in the scheduling these disappear and you only have a bunch threads of execution queuing to get execution time. 