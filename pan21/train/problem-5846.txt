I have set up a class for input handling that allows me to create key bindings with different key behaviours such as single press action bindings where the action will only happen once if the key is held, and state like actions to make things happen more than once.
Are there any other solutions to this problem that wouldn't involve changing the signature of the methods to accommodate the member function?
I know of solutions that involve making the members static but my problem here is that doing so would require for me to change the signature of every method which has to take the pointer as a parameter and doing so would impact upon the re-usability of my input class for other projects.
In the constructor of the key handler class I pass in the value of the key to bind to and a pointer to a callback function to be called as necessary. My problem comes when I try to pass the pointer to the function in to the constructor since the method I am trying to pass is a member function of my main game class.
Don't get carried away, there is a performence cost :) Unnoticeable for input handling, but no so cool for commonly executed code (for example, I got burned by using boost::bind for collision detection once. Silly idea anyways).
Dispatching raw input is relatively straightforward, and providing the ability to react to specific events allows you to decouple your application code from the input itself. For instance, if you have your "CharacterController" class (which would implement an input listener interface) listening for jump events, then the character controller doesn't care in the slightest bit whether jump is space bar, or left-ctrl. Without this event based decoupling, any changes to your input map would require additional changes to your game specific code.
Writing an input manager that acts as a central dispatcher, and uses an input map (a list of keys mapped to actions) to distribute events to classes that implement an input listener interface is the summary of my proposal. At its simplest the listener is just a pure virtual function accepting an input event, and the input map a set of key/event-list pairs.
This is the approach i've seen implemented in a number of games, and while it isn't a quick and dirty approach, it is a relatively good design I feel. When reacting to input within the game, you want to provide the ability to bundle functionality into particular events or actions, as well as provide access to raw values for something such as mouse positions. 
That is, a delegate can act as a pointer to method + pointer to the object on which the method should be invoked. Boost::bind can actually do much more than that, because it can bind any almost any variable and allow functions with arguments and return types (like a clojure):