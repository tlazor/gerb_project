Dekker's algorithm will not be sequentially consistent on distributed shared memory hierarchy based multiprocessor but it is very much possible as the memory updates propagate not in step with local memory (cache) update but asynchronously through Cache Coherence protocols like MESI (Weaker memory model).
This paper might also help in understanding, as its title suggests about the difference between the two consistencies you mention. (However, it is in large parts about the implementation of SeqCon and StrictCon shared objects in message-passing, which is one way to think about the lag you mentioned.)
You already have the correct answer.  The second execution is not sequentially consistent because "there is no total order that can give this result".
On a uni-processor on which Dekker's algorithm this is not the case and it will be strictly consistent.
Sequential consistency demands that all events happen in some sequential order and that what happens on one process is always consistent with time. 
This is correct. The propagation can be slow.  Sequential consistency allows one thread not being aware of what other processes are up to (for whatever programs).  However, sequential consistency does not allow every thread not being aware of what other processes are up to (for some programs, including the Dekker's algorithm).
is not possible, is that there has to be some global sequence, e.g. W1(x,1) R1(y)0 W2(y,1) R2(x)?. In this sequence the last read can clearly not return 0. This sequence does not have to be consistent with real-time though. It is entirely possible (sequential consistency) that in real-time the sequence of events was W1(x,1) W2(y,1) R1(y)0 R2(x)1. This sequence is illegal for strict consistency (as R1(y) did not return the value of the previous write). 
even under sequential consistency, if the threads do not use shared memory, no thread is aware of another thread's behavior.