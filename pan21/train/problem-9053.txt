Also, the references to the 'attribute' table seem unnecessary since there's an apparent case of transitivity with t1.attribute_id = t2.id = t3.attribute_id.
What we need, then, is a query that can evaluate all of the necessary conditions for each product on one single row.
So, for each row we're building, the query needs to reference each of those 4 tables twice, and, I would suggest, should actually start with the "entity" table on the far left (presumably, that's the name of the table where t1.entity_id is the primary key).  It could be done without this, though you'd end up joining t1y to t1x on entity_id which seems unintuitive to me and "entity" may also have some "entity type" column that should be included in the query.  (speculation)
I've rearranged the ordering of the tables, since t1 is where entity_id is referenced and there's no point in looking for "france" until we know we're looking at "country".  Of course, that's mostly for clarity, because with an inner JOIN, the optimizer is free to reorder the sequence in which it literally processes JOIN conditions into any order that will produce a valid result.
The AND in the join conditions involving t0x.slug and t0y.slug could be moved to the WHERE clause if that's more intuitive, and the optimizer should realize that this construct us functionally equivalent.
Essentially, though, it seems to me that for each "attribute" you need to compare, you'll need to join t1/t2/t3/t0 repeatedly with different aliases each time, in order for your AND logic to do what you intend.
The nature of the problem is that the WHERE clause applies per row.  It does not look forward or backward so there's no way to express "oh, we need to return 'this' row only if we also find 'that' row."
The query here is appears to be interested in finding only entities where there exists both a matching row (tuple) in the t0/t1/t2/t3 join where t3.slug = 'country' AND t0.slug IN ('france') ... and another row (tuple) in t0/t1/t2/t3 where t3.slug = 'type' AND t0.slug IN ('rose').
But essentially, this query should find all the records in entity with matching values for id... and t3x.slug = 'country' and t0x.slug = 'france' and t3y.slug = 'type' and t0y.slug = 'rose'... which I think is what you're looking for.
I am having a little trouble wrapping my head around filtering a query in the way that I need. My current sql:
I've rewritten the left joins as inner joins, since we're not interested in any results where we can't match rows all the way across.  This should cause a total of fewer rows to be evaluated by eliminating more rows, "earlier" (admittedly, that may be a slightly careless use of the term "earlier").  
These tables appear to be using the Entity-Attribute-Value model, which is often not the best model to use, the complexity of the queries being only one reason for this.