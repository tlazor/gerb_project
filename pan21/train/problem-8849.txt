They're identical because of the constraints that are on the tables - foreign keys, uniqueness, nullability...
The two queries are logically identical and do produce the same plan. The simplification phase of the Query Optimizer handles this.
And look the actual execution plan, it looks exactly the same in both queries. Why? I was thinking that correlated subquery is much slower because of the nested loop and the execution plan looks different? Is it because there is not much data in these tables?
I tend to write a correlated query when it makes sense semantically, and use a join when that is appropriate semantically.  Modern optimizers will generate the appropriate query.  As optimizers improve, I then to write queries for understandability, and not to try to second guess the optimizer.   (I find the optimizer usually does better than I do anyway.  There are rare cases where I know something that the optimizer can't determine from the query.)
A good optimizer will recognize when a correlated query could have been written as a join and use the same plan.  Many correlated queries could be just as easily written as a join.  In this case the optimizer is doing its job.  Optimizing the query in this manner allows plans which would not make sense using the correlated query.