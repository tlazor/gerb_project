From a class design, why would you create the same string for every instance. You could make it a static or simply inline it in your function call.
desplayAllProducts (typo?) looks like it can benefit from a range based for-loop. Oh, and don't use .at on a vector if you always know you index within bounds.
Generally the code will perform better if \n is used over std::endl. std::endl performs a file flush to the output stream and this adds time in each execution, if you use std::endl do it outside a loop after the loop has completed.
Looking at the factory, it still does naked new. Use std::make_unique as it prevents memory leaks you have in your program.
The productName string should be declared as a protected variable in the abstract class IProducts and rather than defining std::string getProductName() as an abstract function in IProducts create the full declaration of the function.
I'm not in favor of the setAttributes, it doesn't belong in this class. Do you intend to add as well the logic to read it from file, database, json, XML ... to it? Best to separate it and use a kind of factory pattern.
It might be better if each class had a .cpp file that contained the functions and only the class declaration was in the header file. This will improve compile times and not require all file to rebuild when changes are made in the executable code.
The warning is that there is a type miss-match between the variable i and allProducts.size(). To remove this warning message i should be declared as type size_t. All STL container classes return size_t from the size function. The type size_t is unsigned rather than signed, integers are signed.
Have a constructor in each of the classes that inherits from IProducts that initializes productName to the proper value. The constructor should also initialize each of the private variables to a default value. Some of the classes might require destructors as well, they can always be set to the default constructor if they don't have special functions such as closing files.
It might be better to put each class in it's own file. While several of the classes depend on the interface (abstract class) IProducts, none of the classes depend on the other classes in the header file. The header file Products.h can include each  of the product class files.
Looking closer: while (cond) { ... break; } looks a lot like an if-statement. How about using it to have less confusion?
is widely supported, it is not part of the C or C++ standard and some C++ compilers may report a compilation error or warning message. This stackoverflow question also discusses the user of #pragma once. It might be better to use an explicit include guard.
If I look at your code, it looks like you are programming in 98. C++ has evolved a lot, C++11 is the least to accept, C++17 should be the standard for this time.
Looks like you are using a factory, let's use some abstractions here. Though, ignoring those, you duplicated the strings. One small typo, big consequences.
Unlike some other languages such as PHP, the this keyword is not generally required in C++ and is generally not used. There may be certain special cases where it is required.