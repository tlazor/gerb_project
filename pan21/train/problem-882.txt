The benefit of using PHP's built-in mechanisms for representing relationships, is that we can more easily find information about these relationships. Consider the case where we want to store more information about the restaurants, such as hours of operation. Previously, we would have had to either store this information directly in the User object as another variable ($favoriteRestaurantHoursOfOperation), or look up the restaurant object by ID every time we wanted to know this information. By storing the handle to the user's favorite restaurant directly as a variable, we can add the relevent information in the Restaurant class (where it belongs) and access it by calling $mike->favoriteRestaurant->getHoursOfOperation();. This represents the relationship between these objects more visibly.
In PHP, variables act as handles to other objects automatically. For example, if I have a class User with a variable favoriteRestaurant, then I can do something like
In the database, we represented this relationship between objects by getting a handle to the McDonald's restaurant (the restaurant ID 3) and storing it somewhere associated with Mike (the field favoriteRestaurantId). Similarly, in PHP, we can represent this relationship between objects by getting a handle to the McDonald's restaurant (the variable $mcDonalds) and storing it somewhere associated with Mike ($mike->favoriteRestaurant).
This is also a good idea, and in fact is exactly what the Factory pattern is designed to solve. You can do this fairly easily by just moving around some code that you have already written. I will show an example for the UserFactory:
Once you have implemented the UserFactory as above, you can use it elsewhere by simply calling $userObject = UserFactory::createUser(2); (using 2 from your given example).
Right now we have two ways of modelling data - in the database, and in our PHP objects. Both environments are concerned with the relationships between objects, but they implement these relationships differently. We want to use the solution that fits the language we are using at any given time.
You'll need a way to use the UserTransactions class inside the UserFactory, and there are several ways to accomplish this - pass it in via constructor and create a new UserFactory each time you want a user, construct a UserTransactions instance each time you call createUser, have a globally-accessible UserTransactions instance, etc. I haven't looked at enough of your code to know how you handle this, so find the option that works best for you.
I would agree with this statement, and would actually take it further to follow "proper OOP practices". If you choose to implement your classes this way, you do not need to store the IDs of other classes - you can just store a variable that references the other class directly. So instead of $favoriteRestaurantId and $favoriteRestaurantName, you can just have $favoriteRestaurant and then access all the relevant properties of Restaurant through that variable i.e $favoriteRestaurant->getName().
In the database, we model relationships with unique identifiers. In your case, these are unique integers for each row in a given table. So in the context of the database, if I want to know the name of Mike's favorite restaurant, I would first find the user with name "mike", find his matching favoriteRestaurantId, then find the matching restaurant with that id and finally retrieve the name of that restaurant. In this scenario, the id of the restaurant is acting as a handle to a restaurant object. We can store the handle anywhere in the database, and retrieve information about the object the handle represents by finding the corresponding row in the restaurant table.