Am I right to constantly ignore Visual Studio's suggestions to not use public fields? (Note that we do use int Foo { get; private set; } where there is an advantage in showing the intended usage.)
Now, have you picked the right algorithms and structures, if they turn out to be a bottleneck, then you decide what is the best way to fix it... that could be structs with naked fields or not. You will be able to worry about that if and when it happens. Meanwhile you can worry about more important matters such as making a good or fun game worth playing.
You are right to be aware that premature optimisation is bad but that is only half the story (see the full quote below).  Even in game development, not everything needs to be as fast as possible.
For the particulars of you case (Unity and Mono for Android), does Unity takes values by reference? If it doesn't, it will copy the values anyway, no performance gain there.
So... Is your game running slow? You are better of devoting time to figure out the bottleneck and fixing that, instead of speculating what could it be. You can rest assured that the compiler will do plenty of optimizations, because of that, chances are you are looking at the wrong problem.
Yes, of course, there could be optimizations that you could do by using structs with naked fields. For example, you access them with pointers Span<T>, or similar. They are also compact on memory, making them easy to serialize to send over the network or put in permanent storage (and yes those are copies).
On the flip side, if you are deciding what to do to begin with, you should worry about what algorithms and data structures first, instead of worrying about smaller details such as fields vs properties.
I'm aware that premature optimization is bad, but as I said, in game development you don't make something slow when a similar effort could make it fast.
I have been saying client code. That means code that calls into yours. If you are not making a library (or even making library but using internal instead of public), you can usually get away with it and some good discipline. In that situation the best practice of using properties is there to prevent you from shooting yourself in the foot. Furthermore, it is much easier to reason about code if you can see all the places where a field can change in a single file, instead of having to worry on whatever or not it is being modified somewhere else. In fact, properties are also good to put breakpoints when you are figuring out what went wrong.
Structs and naked fields will ease interoperability with some not managed APIs. Often you will find that the low level API wants to access the values by reference, which is good for performance (as we avoid an unnecessary copy). Using properties is an obstacle to that, and often times the wrapper libraries will do copies for ease of use, and sometimes for security. 
But my impression is that in game development, unless you have a reason to do otherwise, everything should be nearly as fast as possible. My impression from things I've read is that Unity 3D is not sure to inline access via properties, so using a property will result in an extra function call.
First make it work.  Only then, optimise the bits that need it.  That's not to say that the first draft can be messy or needlessly inefficient but that optimisation is not a priority at this stage.
"The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming."  Donald Knuth, 1974.
Best practices are not creating in vaccum. Despite some cargo cult, in general best practices are there for a good reason.
If it does, if you are passing this data to an API that takes ref. Does it make sense to make the field public, or you could make the type able to call the API directly?
Because of that, you will often get better performance having vector and matrix types that do not have properties but naked fields.
Yes, there is value is seeing what is being done int industry. However, do you have a motivation to go against the best practices? or are you just going against the best practices – making the code harder to reason about – just because somebody else did it? Ah, by the way, "others do it" is how you start a cargo cult.