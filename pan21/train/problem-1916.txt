75 years ago there were no computers around. So one had to explain very carefully the mathematical idea of a computer.
"A function is computable if there is an 'effective procedure' for going from input to output."  When introducing this topic, I have in the past pointed out how they (the students) have an effective procedure for solving quadratic equations, but do not have one for solving equations of degree 5 or more.  This can segue into a discussion of how one might formalize 'effective procedure', but that discussion is something you want to have happen, so I think that's a feature, rather than a bug.
You just walk into the class and ask: so it there anything your iPhones can't compute? This immediately gets you into questions about bounded resources. Then you say: well suppose your machine actually had unlimited memory, is there anything it couldn't compute? And you idealize a bit more and limit attention to number-theoretic functions (because you are not interested in Facebook at the moment). You'll have to explain a bit how computers work (as mentioned in the comments, it's good if the students know a programming language because you can use that instead of describing hardware), but after that you can use all the classical arguments of computability theory to derive results. It doesn't matter that your students' mental picture of a machine is iPhone. In fact, it matters: it makes it easier and more relevant for them to know that their iPhone can't do certain things.
Then I ask rhetorically whether there are non-computable questions about concepts that can be represented in a computer, e.g. integers and graphs.  I say that yes, one example is the famous halting problem, which is about examining a description of a program and saying whether it has any infinite loops.  Intuitively, it turns out that infinite loops are like black holes, and any program that observes an infinite loop could get trapped in an infinite loop itself.  So any procedure that answers that problem may run forever, so by the definition of "algorithm" no algorithm can answer the halting problem.
I start out asking "is there any question that no computer could ever answer convincingly?" and lead the discussion toward philosophical questions such as "if a tree falls in the forest does it make a sound?" or "is there an afterlife?"  We quickly get a consensus that human language can express yes/no questions involving paradoxes or concepts that cannot be expressed mathematically, and so, yes, there are non-computable questions.
Today everybody knows what a computer is, and is probably carrying one around most of the time. This can be used very successfully in teaching because you can skip the rather outdated idea of a machine with a tape. I mean, who uses a tape? (I know, I know, you feel insulted and Turing was a great man and all that, and I agree with you).
Perhaps the point is that all of these models aimed to capture what the notion of computability is. The fact that all of them are equivalent, means that the notion they are trying to capture is robust. So although this does not escape your dilemma, this robustness gives credence to the notion that "a function is computable if there is a Turing machine that computes it".