The answer may depend on the DBMS which you're using.  However, in the DBMS I'm most familiar with (Informix), when you start a transaction explicitly as shown, I would expect that if there is an error in SP2, then an exception would be raised in SP2, and since there is no exception handling in SP3 either, the error would propagate back to the caller — and the COMMIT in SP3 would not be executed.  The caller would need to know that the transaction was started and decide whether to commit or rollback.  If the caller didn't make that decision and simply exited, the transaction would be rolled back (because it was never committed explicitly).  As a consequence of this, the actions completed by SP1 would not be automatically rolled back, and neither would the actions completed by SP2 (but the SQL operation that triggered the error would be treated as if it was never executed).
I observe that the lack of exception handling means that the stored procedure SP3 is not very well written.  Since it starts a transaction, it should handle errors and ensure that the transaction is rolled back if an error occurs (or committed if that is deemed to be the better course of action).  It should never leave a transaction in flight as there was no transaction in flight when it was called.
I believe some other DBMS take the (to my mind) draconian view that once an error has occurred in a transaction, all further operations also fail and the transaction will be rolled back.  That seems overly intolerant.  If I understand their manuals correctly, it means that if you try to insert a record and find that the record already exists, you can't do an update instead.  I hope I misread that book (or that the book was mistaken).  But it does emphasize the importance of stipulating the database you're using — different DBMS may have different answers to the same question.