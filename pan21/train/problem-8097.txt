My preference in this case would be to start out without caching, and then to implement a caching layer when you need one.  A caching layer might include something like memcached, or you could build one on a NoSQL solution like Mongo.  At that point you can look at optimizing the areas which are the largest problems.
what to do if you hit the wall will depend on your DB choice.  If you are using MySQL, your traditional answer is to look at something like memcached or create a caching layer in a NoSQL db.  If you are using PostgreSQL, you get those choices plus something like Postgres-XC which gives you an ability to do teradata-style scaling out and clustering in OLTP environments.
I would consider logging your votes to flat files, and using a script to summarize them and store them in application-ready tables.  This way, you are storing summarized data that is quickly accessible and you have access to your raw logs if you ever need to summarize your data in a new way that you didn't think about before.
Keep in mind that db's frequently do a good job of caching recent content pieces.  I would expect that MySQL can do this too.  If it can't go with PostgreSQL instead.  Don't cache it yourself in the db.
I know that MySQL and PostgreSQL are different enough to make cross-db somewhat dangerous here but I am thinking you'd want two indexes, one on content_id and one on user_id.  I am thinking this because aggregating by user_id and content_id are likely to be different queries and these are different join conditions.
There are a lot of different strategies you could use (these are not the only ones). I'd say that if you get pass the first bullet on my list, bullet #4 would give you the most benefits with the least effort.
For caching, storing the number of votes for each piece of content would be cheap and would limit the number of connections you need to the database, so I would highly recommend that.  Even if you expire the cache every couple minutes, you would only need to make one call to the database every couple minutes instead of potentially thousands.
When in doubt about scalability, it's usually useful to break data down so that there is as little contention as possible. So, I'd start by asking questions like:
I don't think the number of votes is likely to be the problem.  The questions will have to do in part with questions of how well you can index, how your db does caching, etc.  Standard performance tuning applies and that isn't really your design per se.  I will answer more below on what to consider if you run into the wall of being unable to get your design to work fast enough.