Micro-optimizing Python is a bit of a quixotic endeavour â€” if you wanted the fastest possible performance then you wouldn't be using Python. But so long as we understand the nature of the exercise, then it's just a matter of trying lots of changes and measuring the results to see which ones are improvements:
However, a solution for n > 1 cannot have horizontal or vertical mirror symmetry, because that would require both that n be odd and that all queens be on the central column/row; it can't have diagonal symmetry, because that would require that all queens be on the same major or minor diagonal; so we're left with rotations. There are three possibilities: no rotational symmetry (so totalNQueens finds 8 equivalent solutions), rotational symmetry of order 2 (it finds 4 equivalent solutions), or rotational symmetry of order 4 (it finds 2 equivalent solutions).
It may be possible to argue further that for some sizes rotations are impossible; alternatively you could try to just assume that they are possible and count them. A relatively simple modification for the "just count" approach would require shifting everything left by n bits so that you can mark "future" diagonals as used and tracking both the current row and a mask of rows which already have their queen by symmetry.
Firstly, documentation. The existing comments help a bit, but mainly as aids to reverse engineering the meaning of the variables and the helper method. Three lines of documentation explaining the arguments and return value of helper would be a big improvement.
If we consider the last one, because I think it will require the least adaptation: what symmetries can a solution have? The square has eight symmetries:
I would favour names like column_mask, major_diag_mask, minor_diag_mask, possible_columns, selected_column.