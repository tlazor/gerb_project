Layer-3 protocols have addresses, e.g. IPv4 addresses, and they have the same sort of thing as layer-2 protocols, e.g. IPv4 has the Protocol field in the IPv4 header. Layer-3 protocols don't look in the packet payload to see what it is, and this means that we can use any number of layer-4 protocols with layer-3.
Layer-2 protocols can have addresses, e.g. MAC addresses, and the layer-3 protocols register with layer-2 so that layer-2 knows where to send the payload of the layer-2 frames, e.g. ethernet has the EtherType field in the frame header. Layer-2 protocols don't look in the frame payload to see what it is, and this means that we can use any number of layer-3 protocols with layer-2.
Layers 1 to 4 comprise the network stack which OS developers have implemented in the OS, but they never actually implemented layers 5 to 7. It is up to the application developers to provide these services in their application. That means there is no standardized way for layer-4 protocols to know what is in any layer above it.
Since there is no defined layer-5 in the OS, layer-4 protocols don't have a standard way for layer-5 protocols to register with them, and there is no field in the layer-4 headers to register a layer-5 protocol. Instead, by consensus, there are well-known ports which some applications use, but that doesn't mean a different application than the one which is well known can't use one of the well-known ports if it is not currently in use. For instance, I could write an application which uses port 80 (well known for web servers). If I run my application, then try to run a web server, the web server will not work on the well-known port because it is already in use.
Layer-4 protocols have addresses, e.g. TCP ports. Applications register with a layer-4 port, saying that anything that comes to that port goes to it. Layer-4 protocols don't look in the frame payload to see what it is, and this means that we can use any number of applications with layer-4.