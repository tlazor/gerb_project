Option 2. A single quad or plane referencing a texture you create at run-time. You would essentially use your tile atlas texture to "paint" your map as one new texture. Depending on the size of your map of course, you might want to have multiple quads/planes each representing portions of your map.
For Option 2, I'd suggest watching this video series by quill18creates: 3D TileMap tutorial series by quill18creates
Option 3. Create your own mesh. This would more than likely be the method you'll like most once implemented. It'll give you tons of flexibility and probably the highest performance. You would essentially create a quad per tile and set each vertex UV to map to the tiles in your tile atlas.
Option 1. GameObject per tile. It's not completely horrible in certain cases. Depending on your needs, it could work.. well enough.
You could always use LeanPool. Its a free asset on the asset store. It does object pooling for you. Then you can do a simple cull system around the cameras view that spawns/de spawns tile gameobjects as they enter/exit the cameras view. Im not sure on how big your tilemap is going to be but Unity can handle quite a bit of gameobjects. LeanPool has benchmark scenes in Unity where you can spawn/ de spawn a thousand objects with box collision components and I think possibly a render component as well on each one and it does it very very quickly.  
As someone working on voxel/block-based project, I cannot help but think about just using the same approach, only in 2D. You can build a grid-like mesh procedurally and assign right coordinates of tile visuals in your texture atlas to UV channel. In 3D you have to do much more job than this to have high performance, but in 2D very likely it's really enough.
As you (I think) alluded to, Unity's roadmap has plans for a tilemap editor. I'm looking forward to it, because right now it's a little confusing how to proceed.
In the meantime, the best approach I'm seeing is to make your map in Tiled and then use X-UniTMX to import it into Unity. Obviously that's not procedural generation though; I'd imagine you would use the same technique as X-UniTMX is using to create the mesh.