The design of the database should built on two foundations. The first is, of course, the nature of the data itself. Analyzing the types, domains, relationships and so forth is a task that cannot be short-circuited. The second is data integrity. For Pete's sake, don't think of this as something that is a pain, an obstacle that must be avoided. If a constraint is needed, put it in. Without delay. You can thank me later.
Don't let them anywhere near the database. Not even in the same room. Don't even think about letting them suggest schema design. Ask them two questions:
So you have a bunch of app developers running around like chickens with their heads locked up in a drawer somewhere. What's else is new?
Then develop what I call a "wall of abstraction." This consists of a bunch of views and supporting stored procedures. The views will give them database objects they can access -- if they really insist on gaining direct access to "the database." I wouldn't think twice about creating an average of ten views for each table. How do they want to see the data? Write a view for it.
At one customer's site, I got there just as they were just finishing up a project that consisted of dropping a column from a table. The column turned out to be a duplicate of another column in the same table. But all the apps directly accessed the tables so there were any number of screens, forms and code all over the company (and it was a large company) that might use the column in a query or DML operation. I was surprised to learn that this particular project was started 12 months earlier. It took them a year just to drop a useless column from a table! When I suggested using views, someone said, "Yeah. But then we would have to maintain all those views," and the suggestion went nowhere.
A view is just a query. How difficult is it to maintain? But the drop column operation could have been accomplished in a two week sprint with no changes to app code!
By flexible, I mean that this abstraction layer can be developed, redeveloped, altered and grown to your (and your developer's) hearts content -- without changing the structural layout of the database itself.
Flexibility and data integrity -- you can have both. It just takes a little work and, yes, you have to maintain the views.
The stored procedures are really what developers should be wanting. These can provide an extensive and flexible API so they can perform any operation on the data they want, when they want to do it, taking (or providing) the data in whatever form easiest for them to work with. No direct access to the database needed.
I get $50/hr to go in and fix databases. Almost inevitably, a big problem that is costing a lot of time and money is traced back to a shortcut that was made during the initial design phase. At the risk of nipping a future customer in the bud, here is my advice for free: don't do it.