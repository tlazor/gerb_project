So you should be aware that you are eliminating this optimization by moving per-frame update back to the GPU. Note that, depending on the complexity of your "wind" function, you could probably instead push that computation to the GPU as well, which would give you the finer control you are after as well as obviate the need to update a vertex buffer every frame.
Then you'll have complete CPU-side control over the particle attributes, at the cost of decreased performance due to the additional cost of updating the vertex buffer each frame -- this the bottleneck that the sample describes avoiding in the description:
You can modify the baseline you have to remove all position update/animation code from the vertex shader (see ComputeParticlePosition) and move that to your application. You'll have to employ dynamic vertex buffers -- locking the buffer each frame, copying the position out of the particle system data structure and in to the buffer (although with the rest of the particle's vertex attributes), and then unlocking the buffer. You may want to remove/modify the rest of the ComputeParticleWhatever methods in the shader, since any modifications they make to the particle system will clobber any updates you do on the CPU.
The particle system you are using as a base is explicitly designed to perform all its animation on the GPU. To disable that, you need to use a different design.