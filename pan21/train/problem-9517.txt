As you stated error handling is not part of your implementation yet, but division by zero would be a great example where your Controller definitely needs a reference to the View.
Your Controller does not serve any purpose right now. It just passes the value from the View class through to the Model.
This will also help expose some typos that you have (you try to save four different buttons as self._button_plus). 
In the current implementation your program would throw a ZeroDivisionError in Model.operator(). You could catch that there, but what next? You have no means to communicate this information back to the view.
The Controller should be responsible to check for a possible division by zero. In your current implementation, Controller.operator() would be the correct place for that. In case of an error you might want to notify the View to display an error message and reset all data in your model.
With that, instead of using something like self._button_1, you would use self.buttons['1'] if you need to reference the buttons elsewhere in the code. Plus, by using a loop you reinforce to the reader that these buttons are intended to be virtually identical.
What is definitely missing is a reference to View in the Controller class. The task of the Controller is to establish the connection between View and Model and to validate the data which is sent across these two.
If you want to validate the type of a parameter beforehand you can da an isinstance check with a suitable superclass. In case of an integer, you would import numbers.Integral and check isinstance(digit, numbers.Integral). You could also directly check isinstance(digit, int), but that narrows down the possible data types to actual int, whereas numbers.Integral also allows for other compatible types which are registered as a virtual subclass of itself.
Furthermore, if your Controller holds a reference to the View, you could also get rid of the Observer pattern. Instead of letting the Model notify its View observer, the digit and operator methods can pass the value of _temp back to the View after calling the corresponding methods on the Model.
I guess that you want to make sure that the method actually received an integer. Your current implementation (taken from the Model class, although validating the inputs coming from the view should be in the responsibility of the Controller) will only detect if None is passed to it. A string, float or any other type will pass through undetected, potentially causing a TypeError in the second to last line:
Your buttons are all nearly identical, with the only difference being the character that they insert and the value they pass to the controller. You can cut down on the number of lines of code by using a loop, and storing the widgets in a dictionary:
Imports and layout have already been addressed by Bryan Oakley, so I will focus on the remaining two questions:
It is worth mentioning that in Python it is a widespread practice to not check the type at all and just put the critical code in a try ... except block and catching a possible TypeError. In your MVC example however this is not feasible since you want to validate the type already in the Controller before passing it to the Model which does the actual computation.
When you create a widget, then call grid, then create a widget, then call grid, etc, it makes it very hard to visualize the interface, and to see the logical and physical groupings. Instead, separate widget creation from widget layout. 
The Model on the other hand does all the work like checking what operator to apply and so on. But I think that's OK for now.
The same goes for other types. If you want to allow for any iterable, you would check against collections.abc.Iterable instead of list or tuple or whatever.