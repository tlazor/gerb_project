However this method isn't producing the results I want. The results I'm getting are predictable they just aren't the type I'm looking for, that is local rotation but global translation. Could someone please tell me the correct method of doing this?
4) At this point I have a third dual quaternion that should describe the object's new location and orientation. The real part of the dual is a quaternion describing its orientation and the dual part can be converted to a translation vector using the formula t = 2*dual*(real') where real' is the conjugate of the real part of the third dual quaternion.
Up until now I've handled a given object's rotation and translation separately using normal quaternions for rotation and vectors for translation. However I'd like to use dual quaternions to handle both an object's translation and rotation as I plan on using them for rigid body dynamics later. Basically I want it so I can have an object with an initial dual quaternion, multiply this dual by a second dual quaternion that describes the change in its displacement and end up with a third dual quaternion that describes its final position after the change is applied. I want a given object (I'll use a sphere as an example) to rotate locally around it's own center of mass but to move globally. Here's a video of the type of motion I'm looking for that apparently was accomplished using dual quaternions:
1) At the start of the program I have an object with an initial dual quaternion describing its position and rotation (I'll call this quaternion Q1).
2) I change the object's rotational and or translational velocity. From this I calculate a second quaternion, Q2, which describes its change in rotation and acceleration. 
3) I then multiply the two quaternions together (I've tried both orders of multiplication at this point but I believe the correct order is supposed to be Q2*Q1). The formula I'm using to multiply them together is Q1*Q2 = r1*r2 + e(r1*d2 + d1*r2).     
Unfortunately the link to this examples source code doesn't load. Now I've tried getting this to work several times however the object I'm displacing (again a sphere) will either move globally but won't rotate locally or will rotate locally but will not move globally (its movement is based on how it is rotated). Basically this sums up what I'm doing: