2D games tend to not use dynamic animation (skeletons and deformations.) Instead, the animations are often created in a 3D package and saved as a library of images.  The sprite then has a lookup table of images (either stored as a single massive sprite sheet or as a series of individual images.) During the game animation phase, the sprite determines what image to display based on the sprite's current state. For example, I have an animation of a cow (http://www.aharrisbooks.net/pythonGame/ch08/cow.py) that walks in eight direction. Each direction is an animation of ten frames.  
Although it may appear to be 3D, 'hack and slash' games (like Diablo) are really 2D games. Often the components (the sprites) are created in a 3D modeling tool, but only the 2D renders of the sprites are used in the actual game.  This type of game tends to be much more about the data interactions (the map, the player, the treasures, and the monsters) than about the visual representation.
I wonder what kind of animation techniques are used for creature and character animation in modern hack&slash type tile based games? Keyframing for different actions may be one option. Skeletal framing may be another. But how about the physics? Or do they use a totally hybrid system of inverse kinematics supported with a skeleton,physics and mixed with interpolated keyframing for more realistic animations? If so, how and for what reasons? I can think of many different solutions for the issues below but I wonder what's used and best suited for issues like:
The sample program checks the direction and frame, then displays the appropriate image. My example is written in Python, but the language is not important; the idea remains the same.
The visual aspects of being in different states (combat, wounded, etc) would be handled by simply adding more animations to the stack.
I probably wouldn't worry about soft-body dynamics in a 2D engine.  That can be added later, but it's not key to the functioning of the game.
However, the more difficult aspects of these things are the data aspects. For example, how is terrain managed. I'd likely use a variation of the A* algorithm to pick a path between where the sprite is and where it wants to go, and I'd add some sort of weight to each node to depict the difficulty of that terrain. (roads would have a very light weight, mountains and oceans would be very 'heavy')  
You could certainly build a 'hack and slash' in 3D.  However, the added challenges of 3D modeling make it harder to concentrate on the gameplay mechanics which often attract players to this kind of game.