The known_hosts file in this case does not use plaintext entries. You'll know hashed entries when you see them, they look like hashes with random characters instead of xyz.com or 123.45.67.89.
I saw so many stack overflow posts telling you to programmatically add the key blindly without any kind of checking. The more you check the key from different machines on different networks, the more trust you can have that the host is the one it says it is-- and that is the best you can hope from this layer of security.
So, that's how you stay a virgin for today. You can do the same with github by following similar directions on your own time.
If you're really sure you want to ignore checking the fingerprint, then the second best, less secure option is to use StrictHostKeyChecking=accept-new, which was introduced in OpenSSH version 7.6 (2017-10-03):
Best would be you check the fingerprint of each new server/host. This is the only way to authenticate the server. Without it, your SSH connection can be subject to a man-in-the-middle attack.
Thanks for sticking with me, here you go. I'm adding the bitbucket RSA key so that I can interact with my git repositories there in a non-interactive way as part of a CI workflow, but whatever you do what you want.
The first comment line infuriatingly shows up-- but you can get rid of it with a simple redirect via the ">" or ">>" convention.
Do not use the old value StrictHostKeyChecking=no which never checks the authenticity of the server at all. (Though the meaning of this =no setting will be flipped some releases later.)
First, install nmap on your daily driver. nmap is highly helpful for certain things, like detecting open ports and this-- manually verifying SSH fingerprints. But, back to what we are doing.
As I've done my best to obtain untainted data to be used to identify a "host" and trust, I will add this identification to my known_hosts file in my ~/.ssh directory. Since it will now be identified as a known host, I will not get the prompt mentioned above when you were a youngster.
I had a similar issue and found that some of the provided answers only got me part way to an automated solution. The following is what I ended up using, hope it helps:
So, I was searching for a mundane way to bypass the unkown host manual interaction of cloning a git repo as shown below:
Good. I'm either compromised at the multiple places and machines I've checked it-- or the more plausible explanation of everything being hunky dory is what is happening.
At this point we manually are as vulnerable as automatically-- the strings match, we have the base data that creates the fingerprint, and we could ask for that base data (preventing collisions) in the future.
That 'fingerprint' is just a string shortened with a one way algorithm for our human convenience at the risk of more than one string resolving into the same fingerprint. It happens, they are called collisions.
Don't do either of the above things, please. You're given the opportunity to increase your chances of avoiding someone eavesdropping on your data transfers via a man in the middle attack-- take that opportunity. The difference is literally verifying that the RSA key you have is the one of the bona fide server and now you know how to get that information to compare them so you can trust the connection. Just remember more comparisons from different computers & networks will usually increase your ability to trust the connection.