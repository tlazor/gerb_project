Any class that is Updateable can implement the virtual function onUpdate(float deltaTime).  onUpdate(float deltaTime) is called automagically in the derived class, such that its sole parameter tells you the time, in seconds, since the last time the timer was fired.  Note that an Updateable object tries to fire as close to the specified interval as possible, but we make up for any slow-downs or speed-ups.  90% of the timer, you should be getting the interval you specified; however, that 10% of the time where there is a slow-down, or if a Timer prematurely fires, we account for it.
A solution is to have your game run on a second thread, and use the CADisplayLink callback to signal that thread to do a frame.
In order to account for slow downs, Updateable needs to store the last time in which the Timer fired.  Then, when the Timer fires again, Updateable simply subtracts the current time from the previous time.  That is your deltaTime. You then store the previous time, and the process continues.
You don't necessarily have to use a timer but I would definitely recommend using time based animation. Find a high resolution timer (I don't program on iOS so you'll have to google for that) and just set a start time where things occur at intervals based off that start time.
CADisplayLink callbacks are called on the UI thread, so if your game logic is taking a long time, you'll run into problems.
For the specific case you're asking about, it would be far better to let the animation complete callback determine when to run your next bit of code.  This way, it'll always exactly match when that missile hits that UFO.
Timers in any language can hang up.  That's why I always have some Updateable class that uses a given library's Timer.  In the constructor for Updateable, you can tell Updateable the interval in which it should call a virtual (overridable) function.