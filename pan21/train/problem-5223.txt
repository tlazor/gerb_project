So, with interpolation, you basically replaced one problem by another. Just skip the frames and optimize the update code.
A popular alternative is to use frame interpolation in the view, but it's not a good solution.  When the update is fast enough, the difference isn't visible: it turns out that interpolation was not necessary after all and it comes with the development cost of having to implement it.  When the update is slow enough, you start perceiving weird rendering artifacts.  These artifacts come from the fact that the formulas used by the view for the interpolation step are just an approximation of what the model is doing, with big steps come big approximation errors.  E.g. you won't be implementing a parallel collision detection system in the view, because that's the job of the model to start with.
If you find that the model update is taking too long, causing frames to be skipped too often, it's a better solution to optimize that instead of overcomplicating the code trying to be smart on the view side.