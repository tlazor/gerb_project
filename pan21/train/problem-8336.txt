I ran cprofile a few times and the function call numbers are static. From the look of your code, we're seeing multiple requests to findmaxdist and math.sqrt, there might be an opportunity to clean that up.
This means all the elif len(possibles)>1: part is unnecessary, making it shorter and cleaner. Another simple optimization is changing hatch_list to a set instead of a list so that the if (x, y) not in hatch_list: takes less than O(n). Its a small change that only requires changing list() to set() and append to add. 
If we think a bit further on how does itertools.product work, it will first iterate over x and then over y. This means that the first candidate we find, is the one with lowest x and lowest y of those x. This means 2 things: you donÂ´t even need that sort, the answer will always be the first candidate. 
Your solution is right, but unfortunately the time limit enforces a certain optimization. The key of this is where it says: 
Looking at your code, regardless of speed, having it all as one giant blob instead of neatly separated into functions (look up the Single Responsibility Principal) can make your code execute faster as functions compile down neatly and very efficiently - especially when written in a functional style of programming (no state maintained in the function after the function completes).
In your case, you just append all possible candidate and then you have a very complicated way to find the lowest. First of all, this complicated way could have been reduced to sorting and returning first element. 
To specifically answer your question, you'd need to use a profiler to look at the code and see how long it takes.
There are 22 appends to a list object, which if we look at "Common Data Structure Operations" (see http://bigocheatsheet.com/), which might be an inefficient data structure for what you're trying to achieve. 
There might be more optimization to make but the one of the break is the key to the problem and the expected optimization to make to be able to not have time limit.
Other than streamlining the calls and changing your data structure, I don't think you'll see much speed improvement with the code as-in. I hope this helps somewhat?
Now if the answer is always the first candidate, why are we keeping all candidates? And why are we still calculating other possible candidates when we already have the answer? Keeping this in mind, the solution to your time limit is simple adding a break after the possibles.append((x, y)) line. This will make us stop processing when we find the answer, and will save enough time for the time limit. 