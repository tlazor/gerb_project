There are minor performance improvements possible still, short-circuitings notably, however they do not improve the worst-case complexity so I left them out to avoid mucking the algorithm.
Answering your question about how to loop over all the counting numbers, you could use a while loop or you could use generators. To show what your code might look like with a generator, see the following.
In this case, we actually don't have to write counting_numbers because itertools already has this builtin as itertools.count but because we want to start from 1 instead of 0 we will have to call count(1) instead of count() which would start from 0. We can now rewrite the above solution to
I also recommend using from __future__ import print_function so that you can be forwards compatible with Python3. Note that you will have to use parentheses with print and the new version below doesn't use print so this was left out of the code below.
As you can see, you write what looks like a normal function and then use yield wherever you want to give a value to the for loop. The generator you are writing will yield control over to the loop whenever it hits a yield statement which is why this generator doesn't cause the program to seize up in an infinite loop. You can read more about generators in their original PEP 255 or in various online tutorials. Just know that they will stop upon hitting the end of their block like a function would or a return statement. (Sidenote: don't try using return x in a generator, this is related to sending a StopIteration and doesn't make the generator return a value like you might expect.)
I recommend returning True or False instead of printing so that you can reuse this function in later problems. As a slight benefit, returning a value also removes the need for break.
An if statement that is checking a precondition for a function should avoid else because the else makes the entire function more deeply nested and adds little to the understandability when it is clear that the if statement is there to check if the provided arguments are valid.
The algorithm itself can be improved to get logarithmic complexity (ie, a logarithmic number of multiplies and comparisons).
If the exponent is an integer, then it is a perfect power. In the below code, some extra work is done to avoid floating-point rounding errors.
This answer will focus on cleaning up the algorithm you used although, as other answers have shown, there are better algorithms for this problem. I will also answer how to loop over the infinite list of natural numbers with a generator. (Although I will refer to these as the counting numbers to clarify that I am not including 0.)