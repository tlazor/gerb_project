In my mind, IMGUI is unquestionably a good thing. It gives you a much better model for reasoning about your GUI. It becomes much more functional and reactive, and you minimize the amount of mutable state that you have to reason about. On the other hand, implementing a sophisticated IMGUI library is quite a challenge, and definitely more difficult than implementing an equivalent RMGUI library. It's a tradeoff between library complexity and application complexity. If you're planning on building complex apps (or even a lot of simple apps), the tradeoff is very good. If you're doing this for one single app, and it's pretty simple, you'll probably achieve your goal faster with RMGUI.
A lot of it originates from the assumption that an IMGUI library can't retain any data under-the-hood. This isn't true at all. A sophisticated IMGUI library will in fact retain about as much data as an equivalent RMGUI library. The difference is that an IMGUI library mostly caches results, whereas an RMGUI library maintains authoritative state. In IMGUI, the application provides a function that takes the current model state and produces a GUI for that state. This is the authoritative definition of the GUI. The library is responsible for making sure that the on-screen GUI matches the result of that function. This doesn't mean that it needs to fully evaluate that function each frame and fully rebuild the GUI. That's the point of caching.
As someone with five or six years of actual experience with IMGUI on the desktop, I feel obligated to defend it. All of the responses (and the question itself) are based on a very restricted definition of IMGUI, and there seem to be a lot of questionable claims being made.
However, any half-complex GUI - for an (MMO)RPG or a strategy game, for example - inevitably turns into a horrible mess of indecipherable code, full of special cases and breaking in tons of ways. When building such a GUI, you usually have pretty specific layout that must work for any resolution and be able to show whatever data you send its way. You need things like, for example, moving some buttons lower to make way for longer text. With "retained" GUI, you can have a control that does that automatically. With "immediate" mode, there are no controls, so you have to do everything explicitly.
I can't say that "immediate" mode is definitely worse than "retained", but I certainly feel much better working in "retained" mode.
Immediate mode GUIs are tempting for lone programmers who want a quick HUD system, and for that purpose they are great. For anything else... just say no.
A while ago IMGUIs also caught my interest, as a test I wrote a couple of tutorials to familiarize myself with the techniques (start here if you're interested, but it's not much more than C#/XNA + the original 'tutorial' here).
In the end I thought that the immediateness of the GUI made it harder to separate the GUI from the data and at times I tried to decouple things more by introducing some state, breaking the elegance of IMGUIs. I also don't think that writing code for retained GUIs is more work than writing code for IMGUIs and I like that retained GUIs can be fired and forgot about, and I really like events :).
I really liked IMGUIs for a short while because the info they display is always up-to-date and correct (since there is no state you always feed to actual data). But in the end I lost interest so normally now I use retained GUIs again. 
With this view of IMGUI, you can in fact do advanced layout, and the performance is quite reasonable. You can also retain actual authoritative state if it makes the interface easier. The point of IMGUI is not to make the application retain everything. The application probably doesn't want to have to store the position of every scrollbar and the expanded/collapsed state of every tree node. The point is to be able to procedurally specify the contents of those tree nodes and their very existence.
Nay. I've done paid gamedev work on an awful 'retained mode' GUI and on an awful 'immediate mode' GUI and although both made me want to tear my eyes out, the retained mode approach is still clearly the better one.
"Immediate" approach works really good in some cases. First, when you only need a couple of buttons and labels - think shooter HUD, for example. Creating them with "retained" approach is not very hard, but its super-easy with UnityGUI. Second case is when you need to stuff lots of controls on screen, but do not really care about layout. Especially when exact controls are only known at runtime. This is not actually useful in any game, but really helpful when making tools running inside Unity editor.
Another problem with UnityGUI (not sure if it happens to all immediate mode GUIs) is that, for example, a Button() call works without considering any other GUI calls. So, if one button is on top of another, a click will press both buttons at the same time. This is definitely not what user expects, so this adds another special case to handle.
I worked a lot with Unity3D GUI system, which works just as you described. And I must say, I hate it with a passion.
However, every time someone mentions IMGUIs something inside me wants to try again, and try harder to get it right, because there really is some elegance in there, I'm just not 100% sure if it will always make your job easier. I'd say try it out, maybe try as I did and write some tutorials (I find the best way to learn new techniques is by explaining them to others).
I would go through and respond to all the IMGUI criticisms point by point, but I don't really understand a lot of them. Most of them seem to stem from some fundamental belief that IMGUI is hackish and RMGUI is well-structured, which I guess stems from the above misunderstandings. There's no inherent reason that IMGUI libraries should have trouble with complexity or have to be littered with globals or mix logic with presentation. I will say that the advantages of IMGUI become less important the more artist-driven your content is, but I'm not sure why it would actually be worse for artist-driven content. (I don't personally use artist-driven content, aside from style sheets for things like colors, font/border sizes, etc., but I don't see why it would be harder to implement than for RMGUI.)
To live with all this, I've always written my own wrapper around UnityGUI that turns it into a "retained" mode system: controls that store their own state and just call required GUI functions every frame for me.