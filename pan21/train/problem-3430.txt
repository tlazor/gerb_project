For simple reference data maintenance this may have some use.  The market for this is crowed.  Most every IDE will have a data grid with a connection behind it which will allow this sort of thing already. 
Erwin has a macro language for writing stored procedures that can be compiled against Oracle or SQL Server. You write, IMHO ugly code, with variables that will get translated to something understandable by a particular database engine, then Erwin will create a translated version for that database engine. I have not worked with Erwin in years, so I am not sure that it still has the feature. IMHO, you develop databases and applications for a specific database engine, so that you can use the best features of that database to get the best database application.
As a project it may provide a lot of personal satisfaction.  As a commercial enterprise I can't see it gaining traction, however.  Sorry. 
5-10 years ago, I would have said code generator sucks, they generate too much duplicate code and that having a data-driven user interface (where the fields on the screen, validation, etc is driven by meta-data in a database instead of coding the screens one by one) would have been a great gift to mankind that supplanted the code generators.
Today I would say - write each screen individually. Use existing framework that wire fields and model objects and possibly ORM when doing simple CRUD. But do design each screen to the exact purpose of the screen. Application screens that mirror a RDMS table too much is only good for managing lookup tables. Don't annoy the user with geeky interface that are designed against a computer storage model (RDMS)... make a screen that has only what they need. That may mean that it will save to multiple tables, etc. Who cares. The user isn't a database.
10-15 years ago, I would have said that having a code generator for quickly creating the boiler plate code for database driven applications would have been a great gift to mankind.
Any non-trivial business operation is likely to touch more than one table.  To implement these is so much more than a string of CRUD SPs wrapped in a database transaction. Capturing and generating those cross-dependencies will be difficult.