Secondly what you do with the resulting data can have an effect.  Using an image format of TGA for example means that no further conversions need to happen (if your fastest format is GL_BGR or GL_BGRA then all the better - you don't need to swap the colour components).  Just alloc a buffer of the appropriate size + 18 (which can be a one-time-only op), glReadPixels into &buffer[18], then fill in buffer[0] to buffer[17] with data for a TGA header - done.
On PC hardware I've personally found that a format of GL_BGRA gives the best performance.  On some drivers using a type of GL_UNSIGNED_INT_8_8_8_8_REV (instead of the more commonly seen GL_UNSIGNED_BYTE) is also required.  It may be the same or may be different for the iPhone so experiment.
To get the contents of the backbuffer, the fastest way is to render all your scene to an intermediate FBO, save the frame data to a file and draw onscreen.
Finally, glReadPixels will need to stall the pipeline in order to complete the readback.  If you have PBOs available you should be able to read asynchronously into a PBO and avoid this stall.  I've personally never used this method though, so can't comment any further on it.
Firstly you can experiment with different values for the format and type parameters - getting these to match the layout of your framebuffer means that glReadPixels can do a direct transfer from the framebuffer; otherwise it will have to round-trip through software to convert from the framebuffer format/type to your specified format/type.
10 or so years ago I used this method to export video from a PC game on a TNT2 and was able to get exports at maybe 30 FPS/640x480 resolution (including time spent in an AVI encoder).