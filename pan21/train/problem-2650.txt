When the optimiser is creating the execution plan it is most likely that it is considering whether available indexes are unique and the order specified in those indexes (depending on DBMS and options set). As the plan is executed rows are processed one-at-a-time so uniqueness is not an issue. Any intermediate results sets are just treated as a bucket of rows. (There's lots of complexity in there; it's very interesting; much good information in blogs.) Although temporary structures may be created to facilitate processing none make it through to the end result set returned to the client.
It is likely that there will be at least one day with more than one order and hence no candidate key. And yet the output of this query is a perfectly good table. It can be persisted, joined to or selected from as any other table could.
In theory every relation should have one or more candidate keys. In implemented RDBMSs, however, there are no requirements to declare any keys at all. As the result of any query, such as your UNION example, is just another table it follows that the system need not create a key for the result-table.
Note that sometimes rows will be made unique on disk as a processing optimisation. For example SQL Server will add a uniquifier (love that word) to a non-unique clustered index. This is to do with how they have implemented other indexes on the same table and not a requirement of relational theory per se.