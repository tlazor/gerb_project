After qsort the scan is much simpler: you only have to compare each element to the ones immediately after it. (It would be "the one immediately after it", but you have to take into account repeated values).
The type of the studentsHeights array is unsigned long long, but you are sorting as if it were an array of unsigned int.  This causes the sort to not work properly.
Note: I use unsigned long because int is only guaranteed to be 16 bits.  The problem requires values that are 32 bits long.  The maximum answer given the problem constraints is 2500000000 which fits in a 32 bit unsigned value.
To be more clear, you can do a single run through the list with two indices, one for the shorter student, one for the taller. If the difference in height between the indices is greater than the wanted height, increment the shorter index. If the difference is less, increment the taller index. If the difference is equal to the desired amount, count it and increment the shorter.
One way to restructure and simplify would be to observe that since a number pairs with numbers either Y below or Y above them, you potentially have chains of linked numbers and those chains can be separated because the elements in a chain have the same value % Y. This suggests using a radix-based comparison (unfortunately with a global variable)
Instead of checking differences with two nested loops, you should just loop over the first element a and perform binary search to find the number of elements of the form a+Y. This will reduce the complexity to \$O(X \log X)\$ which will be fast enough.
Since you sort the list, you don't have to check every height against every other. Use the structure of your data to skip unnecessary checks. In your code, the indices i and j run through the list multiple times to find the differences. But, since the list is sorted, there comes a point where j reaches numbers with too great a difference with the number at i, so you can stop and go to the next i.
Your solution works but it takes \$O(n^2)\$ time because of your nested loop.  One easy way to make your program \$O(n \log n)\$ would be to change your j loop to binary search for the start of the desired height and then count the number of duplicates of that height.  This would most likely make your program run within the time limit.  But there is actually a faster and simpler way as well.
You have a custom integer parser that is totally unnecessary.  Perhaps you thought it would make your program faster, but input parsing isn't what is making your program too slow.
Instead of sorting and counting duplicates like you are doing now, you can take advantage of the fact that the input is limited to numbers in the range 0..100000.  You can set up an array to hold the count of each number and then iterate across the array of counts.  Here is how you would do it: