If it doesn't (say the new object placement brakes the monster group into 2).  Then start with the monster that isn't on the new valid path that is farthest away from the exit.  That path, should be valid for every monster in the second group (who are not on the first path).
This will greatly improve performance, because it makes some assumptions about the general use case of the path - the monsters will already be following a valid path, whcih has now just changed in one place.  Chances are, one new path will suffice.
I have an implementation of A* working in Objective-C (C# should translate OK) on my developer's blog here.  You can see the monsters currently interacting with a changing landscape on my first post.  A* post is lower down...
Hope that makes sense.  In a very simple grid-style map system where users can place objects only 1-at-a-time, you really don't need to run a path for every monster.  Especially if they're not interacting in real-time with anything else.  (i.e. field changes in a static manner, you're not pathfinding two groups of monsters against each other).
Run the pathfinding algorithm once for each entrance & exit pair, and put each monster on that path.  Then, for each monster that is not on that path, run a pathfinding algorithm.
I recommend using A* for it's simplicity.  You have a relatively small grid, and I presume monsters can only move in cardinal (up, down, left, right) directions.