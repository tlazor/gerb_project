Hint: You could improve this a lot by using a GameSize-class as mentioned above. Furthermore you could use the builder-pattern to create a board of any imaginable shape (How about 3D Tic-Tac-Toe?).
Doesn't apply here, since you don't have any interfaces. Or does it? Maybe you should use interfaces. For example your InputReader-class, could be an implementation of an interface. Imagine the following interface:
I hoped I gave you a little insight on how you can improve your code according to the SOLID-Principles. If you have further questions (which are not "can you program this for me"), don't hesitate asking.
What is the responsability of the Board-class? A board is supposed to hold some sort of players and objects for a game. In this case: The 'X's and 'O's. Hold them, keep them, no more, no less. Your class however does the following:
Well... You can always be very dogmatic about programming principles. Your code looks rather good to me. Anyway, I'll name some examples.
Another example: Your class Player. It should be an interface that is being implemented by either HumanPlayer or BotPlayer. Your GameRunner gets two Objects, that implement the Player-interface and does not need to know whether one of them is a bot. Or both.
Dependency inversion is awesome. Imagine if your class GameRunner didn't even know which game is being played? It just says "There is a number of players, a game, and a mechanism that decides who's turn it is". It gets these three objects as parameters and boom. Completly reusable for any turn-based-game.
Lets stay with your Board-class. As mentioned in the SRP-Section, it contains the field SIZE. In case your requirements change and you want a differently shaped board, you violate the Open/Closed-Principle. You have to modify the Board-class. If you change the static field to a parameter in the board constructor however, you can easily fulfill this principle: