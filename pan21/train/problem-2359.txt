Also, the method is public and makes a lot of assumptions about the data passed in the list without checking them. A different caller of that method might pass in mixed payment_types and expect it to work. This could lead to unexpected results. I do not think changing this up to support mixed PaymentInfo objects should yield in a huge performance degradation. It is also a bit weird that the result of the method is int, but always 0 or 1, irrelevant of the number of actually inserted/updated rows. In the current model, I would prefer a bool result.
The call to ExecuteNonQuery() inside the foreach loop contains too many parameters. I do not know if the SqlCommand knows how to purge unused parameters, but I would definitely clear the parameter list before adding setting the command to this UPDATE statement, and then add the required parameters.
Your data model has a small problem regarding data consistency. If someone were to update a SalaryTrans.reference to a different value, it would be different than the one in a Payment record that's joined through the payment_id foreign key. Likewise, total_records and total_amount should probably be equal to the values that could be retrieved by aggregating SalaryTrans. A possible solution for the reference would be to introduce a SalaryTransReference table and have both SalaryTrans and Payment reference that with a foreign key. (Make it a unique key on the Payment table if there can only be one payment for a single reference.) I would also consider a PaymentType table instead of having a payment_type varchar(â€¦) column on the Payment table for similar reasons.
This is minor but good to keep in mind. C# reads like crap if it's all in-line, and so does SQL. Try this: