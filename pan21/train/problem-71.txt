Also, on the subject of names, why tempHash instead of just hash? And key for the value of a KeyValuePair is a tad confusing.
Also, are you sure that reusing arrays is worth the effort? If filesCount is small, then the savings are small as well, and if filesCount is large, then the likelyhood that a specific state has occurred before is probably very small.
In Git terms, this is similar to using multiple files instead of a single large file. Committing changes to a single file only creates a new blob for the modified file and a new tree object that references the new blob (and older blobs for unmodified files).
Another alternative is to store a change-set for each value, using a binary search to find the value for a particular commit number. This can save a lot of space, but it'll make checkouts slower. Whether that trade-off is worth it depends on the intended use of this class.
Aside from those points, I think the design is back to front. It would be simpler to do things the way version control systems actually do it: the commit version (tag) references the hash, and the hash references the data.
The hash can be updated incrementally. FWIW, real solutions do this using a Merkle tree. To make this robust you need to do something about the FilesSet property. You should only expose the data in read-only form (e.g. as IReadOnlyList<int>), and if you have a setter it should take a defensive copy and recalculate the hash from scratch. But I'd be strongly tempted to remove the property and the Update method and replace them with an indexer. 
One alternative is to divide the state into multiple smaller arrays. This limits the impact of individual changes: you only need to copy a 'sub-array' (and create a new 'array-of-arrays'), instead of copying the full state. This also increases the likelyhood that a particular sub-array has occurred before, although I do not think that is something you need to be concerned about.
There's a problem with Commit: matching hash codes do not mean that two objects are equal ('pigeonhole principle'). For example, both [1, 0] and [0, 31] have hash code 31. You can only be sure that objects are not equal when their hash codes don't match - the inverse is not true.