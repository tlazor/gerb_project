In Value types, all fields are private and final by default, and the class is also final. Getters, equals, hashCode and toString are also generated.
Several people are recommending to remove the final keyword from the private fields. I would strongly recommend against doing that. The whole point of the final keyword is to prevent accidental re-assignments to these fields from other methods in the class (private and public). So, if a Person is immutable, then all the fields in Person should be marked final. I actually have my IDE configured to automatically mark fields private on save. Immutability is a good thing to have unless you really want mutable state.
Some other things I would tweak are moving the Builder.build() method to public static Builder Person.person(){...}. This will simplify the business of creating a Person builder and you won't need to type Person.Builder.build() which looks a bit ugly to me.
Now regarding the getters on Person; if your fields are final, you might as well make them public and skip adding getter methods. Why type myobject.getFoo() when you can just type myobject.foo? The only reason to have getters at all is that is if you are depending on frameworks that still expect javabeans style getters with the naming conventions and verbose sillyness that comes with that. If that's not the case, don't add them. 
The Builder annotation will generate a private all-args constructor, a nested builder class PersonBuilder, and a public static PersonBuilder builder() in Person.
Your builder does not need getters; remove them. I would not inject the builder into the Person constructor and keep the business of building in the builder. Instead inject the individual fields from the build method. This way, you can make the Person constructor public and use it without the builder as well and you stick to the principle that constructors should not do work (other than assigning arguments).