As mentioned, the code looks pretty good to me. No obvious flaws are seen. But this is a highly algorithmic code in nature so to speak. Only an excessive set of unit- and integration tests will help getting more confidence with correctness of the solution. I'll just assume that the tests are in place and all green.
I may be very wrong, but maybe, just maybe, materializing the IEnumerable<char> into a char[] and dealing with current and possible next character via indices is a faster solution. I really doubt that using the string's IEnumerator<char>::Current or IEnumerator<char>::MoveNext() is slow, but what if it is? With char array we know for sure that element-by-index access costs \$O(1)\$. Same is true with reach-line-end check -- \$O(1)\$ if implemented based on a known current index and total string length.
Below is the "test bench" I used to compile your solution before feeding it to a profiler. If you uncomment the console output instruction in the catch block, you'll be able to see some unhandled exception which could be caused by either bad input my code generated or a bug in the parser code.
You will not like my answer. TL;DR: I could not find a specific point where a code change would lead to performance improvement. I have, however, noticed some correctness issues.
If your real code works with a string, I don't see how char[] would be a bad thing to do if it improves the performance. However, if the code is indeed a template for working with real char-producing streams/IEnumerables, it may lead to memory consumption problems.
The reason, I think this "optimization" will not work, is because we're talking about string and IEnumerable<T>. I don't believe we can possibly beat the implementation(s) of these fundamental pieces of .NET platform.
Please notice that this is generated by compiling into .NET Core dll. The .NET FW Classic results may be different.
After running profiler, I got a chart to work with. Mapping the invocation stats to the instructions in the source code did not give me many ideas. What's worse, the few ideas which popped out, are pretty crazy.