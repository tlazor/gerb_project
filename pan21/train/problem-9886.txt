Unfortunately you have not posted your exact code in this question, making it a bit of guesswork to fill in the blanks, but my guess is that your current code is directly tied to a specific entity which is supposed to be "controllable" by the human player.
Later on, I'd pass either that message, or an interpretation of that message to the entity that it was relevant to so that it could handle the instruction. This would mean that as long as the message name doesn't change, it shouldn't affect the rest of the system what form of input you're using, as long as it sends those messages.
This is where Entity Component System has an advantage. It is Single Responsibility Principle at it's very best, and it decouples your different classes, a lot. Right now all your "states" that are making use of the Input "singleton" is directly tied to it. Reducing their reusability greatly.
Having a class handling input is the way that I'd initially go to design the structure, unless there was a particularly compelling reason to do it in another way. I'd have my key presses push an Event onto a stack, which can be popped somewhere else. So for instance, if the 'W' key was pressed, I'd push a "Forwards" event (or whatever was relevant), onto a message stack. This check would be within an Update() function of the Input class.
A nice thing about using an Input Component is that you can easily detach it from one entity and attaching it to another entity.
I don't think that the Entity Component System approach should be mixed up with the State Design Pattern as you have done. If anything, you can have the State as a Component inside your ECS, and then have a System for each possible state.
Not having seen a given pattern usually means that you didn't use exactly the right search string, or you've modified a pattern that already exists enough so it looks different, so I wouldn't worry about finding solutions that you haven't seen before.