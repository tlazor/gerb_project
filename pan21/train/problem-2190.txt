When you're ready to move, stop all writes (read_only=true, kill all connections) on the old server and wait for the new server to catchup with replication. Then make the new server writeable and take down the old server.
Depending on what sort of queries are run against you database, you can have a downtime on the order of seconds. This however depends on your write queries being deterministic so that the old and new server will have exactly the same data.
I see this describe ambiguously, or blatantly wrong all over the internet! The documentation clearly states: "If a client connection drops, the server releases table locks held by the client.". So, you cannot open the mysql client, flush+lock, quit client, make snapshot, open mysql client, unlock tables. You will end up with an inconsistent snapshot.
First make sure binlogs are enabled. Take a filesystem level snapshot (e.g. LVM or similar) of the mysql directory under the global read lock (FLUSH TABLES WITH READ LOCK). Use this snapshot to setup the new server, and configure replication to the old system (you can figure out the binlog name and position (master_log_file/master_log_pos) by looking at the size of the newest binlog in the snapshot).
I've cited 6 sources for you. I hope you feel confident doing this now. Let us know if you have anymore uncertainty.
Why not setup the second MYSQL server as a slave, replicate, then reconfigure the slave to be a master?
Some extra-sharp readers will correctly identify that the "UNLOCK TABLES" is unnecessary, because the client connection is going to close at the end anyway. I put it in there because it makes people more comfortable.