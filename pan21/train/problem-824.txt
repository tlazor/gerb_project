These design patterns exist so they can be easily replaced within your application without changing much code, but if your IUnitOfWork is returning a DbSet<T> repository and you decide to read your Product entities from a local file instead of a database then you’re not really going to be able to implement this with your current abstraction.
With these caveats in mind it’s going to be hard to change your implementation to work this way with Entity Framework as Microsoft has taken the design patterns and implemented it in their own way with Unit Of Work and Repository mingled together - I'm not saying this is wrong its just the way they've decided to do it.  The main benefit of having these abstractions in this context is the benefit of being able to create stubs in unit testing so you’ll be mocking stored procedure and query calls without hitting the database.
ii. Knowing how to authorise a user (in your example) along with all of the other stored procedure calls you’ll have
I think the problem is you’re starting with an implementation (Entity Framework) and then trying to bind this to two common design patterns – Unit Of Work and Repository.  The Entity Framework handles these two patterns and combines them together in Microsoft’s own implementation – they couldn’t actually work independently, for example you couldn’t just take a DbSet (Repository) and get a Product (entity) without instantiating the context (Unit Of Work).
Furthermore SP_UserMaster should probably exist in the User repository as its specific to that domain entity.  Again this is strongly-named to imply a database call with a stored procedure – what if this was to be changed to a web service call?