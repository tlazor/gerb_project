As the "Anemic Domain Model" does not care about encapsulation it is easy to get around semantics. You do not need to think about where attributes and algorithms are located "best". You can easily pass the structures around that you need at a certain location to do whatever you want with it.
I suggest to read the next paragraph too if you get a bad impression on my view here. First of all I want to mention that for me there is for one special requirement only ONE (the "best") solution. The point is: If you talk about code quality and what kind of code is better everybody implicitly say "There is one best solution". If you do not do this: ANY sugestions about "improving" code would be totally subjective.
You will have a hard day to "combat" this design. My view on this subject: People either want to get around semantics, do not care about it or even don't know that such thing exists.
You're adding a lot of complexity here. Plus, you're going against the point of a Service Layer and Domain Model. Your Domain Model should probably use either Active Record or Data Mapper. 
We developers try to produce models od reality as well. But there are developers that do not care about reality as there are people who do not care about the reality that science try to evaluate and describe. The point is: We as developers can make up fiction in the programm in our programming languages as long as the interfaces produce beneficial results to those who hired us. We can unneccessarily iterate over a collection twice but returning the correct result. We can build up huge structure and destroy them instantly. I have to admit that my models are bad in contrast to the models that science produce. Doens't matter if it the fault of the programming language or my cognitive troubles.
On the other side WE ALL have cognitive trouble at some point of complexity and/or the programming languge hinders us to express the semantic properly. That is why I am convinced that we nearly NEVER reach the point of the "best" implementation. BUT I am also convinced that we can evaluate the path through trial and error and falsification. Nothing else is done in in science. They try to produce good models of reality. And they want to be as close as possible because they want to make forecasts with these models that will be beneficial for the society. But to do that they have to be clear in semantics.
I personally do not care about social competence when I answer questions here. So I put out the sharpest sword have to argue with to pass it to you: The SOLID-principles together with the Law of Demeter.
We have one great advantage over the management: We can only be tracked by other developers that are familar with the our code. This has been discovered at a point of time when software came up that could not be developed by one developer alone. Collaboration was neccessary. The problem: The different perceptions of reality of the different developers (persons).
And here comes the problem: The more specific AND the more abstract the things are we have to model: I think we get cognitive troubles. This unfortunately also correlates with the persons perceptions on reality.
Todays approaches to solve this problem are to have experience, IT expertise AND high social competence.
The point of a Service Layer is to act as an end point (API) that holds common business logic that deals with integration of domain model objects. Your service layer should just query repositories and delegate calls to process business logic to your domain model (which should hold as much business logic as possible). Injecting it into your domain model adds persistence concerns, which it should not care about.  
So we as developers build models... May goal is it to have the model matching best with reality AND the code we produce matching best the model. Currently object-orientated paradigm is seen as the best paradigm to model real world elements. You have a car in reality, you create a model of a car, finally you get an object of class "Car" in your object-oriented language. A car in reality can be started, so you may have a model of starting engine of your car that may result in a method "startEngine()".
I am convinced under the assumption I made (reality, semantics etc.) these principles will improve code quality on the semantic level and reveal things that compromise reality so you are able to adjust your model to fit reality better.