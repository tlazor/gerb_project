(This answer does not fully answer your question; it is intended to enlighten you about the issues of GUID/UUID performance issues, plus some mitigation.)
Yes.  But it can be mitigated some.  When you have a huge database (more data than can be cached in RAM), UUIDs start to perform poorly, eventually (as the data grows) degenerating to one disk I/O per one reference to a UUID-based record.  For huge databases, this is untenable.  The mitigation is to use only Type-1 UUIDs (which is what MySQL's UUID() is), and rearrange the bits so that the date&time is at the beginning.  This is beneficial if your data references are biased to "recent" rows, thereby making the caching more efficient.  Changing from 36 characters into 16 bytes also helps with performance.
You can obviously create your own GUID/UUID and use it as a globally-unique key for whatever you want.  MySQL has its builtin UUID() function, which is "Type-1".  I don't know whether you consider that to be "strong"; it seems fine.
I discuss this more in my blog .  In MySQL 8.0, Oracle picked up the ball and implemented UUID_TO_BIN() and related functions to both rearrange the bits and pack into VARBINARY(16).