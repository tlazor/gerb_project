If the pointer owns the memory it points to, it can be a bit trickier, because the resource must be freed the same way it was allocated: malloc -> free, new -> delete, new[] -> delete[], etc. The best thing could be to use a smart pointer, but you'd need to specify the destructor to call. There is a level of complexity beyond which it is advisable to build a RAII wrapper around the legacy API, even if it looks like more work / complexity.
Each User has a field called id. And I want to create a vector containing all ids of the users returned by the API call.
If you know how many elements you'll be adding to your vector, it's always a good idea to reserve sufficient capacity.  This reduces the amount of reallocation it might do if it can only react to the additions, and may help avoid over-allocation:
If the return value is a non-owning pointer, the best thing is to build a span from it. It isn't standardized, but is part of the C++ core guidelines. It basically is a pointer bundled with a size. You could the use a range based for loop:
The code looks generally fine (though a little too sketchy for a good review).  It does look like you have using namespace std; somewhere, which I advise against.
You can almost always use a standard algorithm. It doesn't always look nicer though, but your intent is easier to read and you can benefit from the library's optimizations (and from parallelized algorithms with some luck)