The next thing for me was that we only have warnings and that all warnings are equal - is this correct, or do some rules have more importance than others?
Also, be wary if your class ends with "Manager"; it signals that the class will be responsible of too many things -- a God class.
Note: I have created interfaces a few of the types. This is pretty much a Matter Of Personal Preference (MOPP).  I find it useful for unit testing and expansion but not everyone would agree.
At the moment, we have a RuleChecker that verifies a rule against a user.  A problem with this is that unless all the logic for verifying the rule resides in the rule - i.e. the checker has no knowledge about either the Rule or User - if we add new rule types we would need to make changes to the RuleChecker.
If all the logic does reside in the Rule then we shouldn't need a checker, we can simply invoke the rule directly.
Having a Boolean result from the rule is limiting. We know only pass/fail. There is no degree of failure and no details on why it failed. Even if this is perfectly valid right now it may not always be so.
This gives us the current functionality, but also allows us to add more details to messages if desired.
Adding a RuleResult allows more detail. A rule now passes if it returns no RuleResult. We can verify a set of general rules as follows
The only criticism with the code is that your business rules are implemented in the third-party class UserRuleManager. This is OK if you are developing a a "rule system", but otherwise you should encapsulate the rules within the user class if they are about a user; the user factory if they are about how to create users; and the user repository (or data access class) if they are about how to persist and retrieve user objects.
Even if all rules are equal, by storing the failures as strings we lose a lot of information. We have no specific message from the failed rule and if we want to find out details of the failed rule we would need to parse the warning to find the TypeId for the Rule (and for Question details in the specific rules) and then look them up somehow.
The first thing that hit me was a seeming chicken and egg issue (though it is probably a naming thing). We call ProcessUser() and if there are no warnings we then CreateUser(), but the parameter for both of these is a User. If we already have a user, what does CreateUser do - if it doesn't create the user, should that method be called something else?
There should be a more elegant way to do the specific rules (with, perhaps a NullQuestion returned instead of an empty list and an always failing rule that is fetched for the NullQuestion) but I don't have time at the moment.
You have a bug in the ApplyGeneralRules() method. You are adding warnings if RuleChecker.IsVerified() is returning true.