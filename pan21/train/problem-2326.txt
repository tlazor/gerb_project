It's not a good idea, to return redundant information of a simple function. If you want to distinguish three cases, None, False and True would be good. If you also want a description, use a dictionary:
I have some ideas about how you could implement this in code, but I'll leave them out the answer for now, as this sounds like a learning example, and it might be an interesting challenge for you to consider them.
I have not written this code, but it seems to be working after some slight modifications (before the modifications it would hang on n = 1, and give an error for n = 3).
(I'm also hopeful that this observation will be surpassed by someone with a mathematical background giving some more info on how to definitively test for primes in an efficient manner!).
I'm not a mathematician, so I can't comment on 'correct' ways to identify primes - however one possible optimisation is to consider factors. 
Well, it is correct to say that is_prime(1) = False. Do you really want to add all this complexity to your function just to handle the special case of n<2? It depends on what you're using it for. If you're just wanting to be able to give Rodney the correct answer, he's probably not giving n<2, and if he does, you can just say "not prime" without running the program. You should consider just raising an error when n<2, rather than complicating the output.
If a number isn't divisible by n, then it also won't be divisible by any other number for which n is a factor.
Since other answers have covered style and efficiency of your code, I thought I'd contribute with another algorithm. The Miller-Rabin primality test is a probabilistic primality test which is fast. Really fast. I have implemented it myself in both Java and C++, and it could handle 100-digit numbers in a few milliseconds. 
For example if a number isn't divisible by 2, then it also won't be divisible by any other even number, since all even numbers can be generated by 2 * something.