You should pass them by reference (const reference) to avoid them being copied. Also the operator+ does not change the state of the current object so you should also mark it const
Rather than using the member functions begin() and end() you should prefer to use std::begin() and std::end() (or in your case std::rbegin() and std::rend()). This allows you to change the underlying data type without having to change the code. If you changed vnum to an array the code would continue to work as normal.
Normally when you implement numeric types it is easier to specify the standard operators + - * / in terms of their assignment versions += -= *= /=.
Note: Named values can not themselves by r-value references (though this acts as a bind point for an r-value reference). To forward this value to snum you need to call std::move() to make sure you have an r-value reference and that is movable.
But you don't test for the empty string. What value is the empty string? Is it zero. If you print out the empty string what will it display? It displays a blank. So that would confuse the user. So a blank/empty string is invalid input.
There are no prizes for squeezing multiple declarations onto a line and it just hinders readability. There are a couple of corner cases where it can be an issue (but these are obtuse). But you should be writing the code so that it is easy to read. NOT so that it fits onto fewer lines.
Only vnum seems to have any purpose. snum is used locally in one of the constructors and flag is set to true on error for some reason but plays no other purpose.
This constructor requires that you move a string (or provide an r-value reference). But you don't actually move the string you still make a copy!!
Why not have a move const for vectors? The Constructor that takes a string foes a lot of validation. Why does this constructor do zero validation?
You can use a simple test if you want to do things locally. throwing exceptions is what you do when you want to indicates an error that goes beyond the  public interface of your class and thus you can not control how it will be received. Internally you have full control and thus exceptions are not expected.
A better solution is to make your compiler warn (generate an error) you about shadowed members then make sure you change the name so it is not shadowed. Now you can never make the mistake of forgetting the this-> as a result less chance of a bug.
Remember macros don'y obey any scope rules and can quite easily obliterate code. Prefer to use functions rather than function like macros. With modern compilers and inlining you will not see any difference in generated code but have functions that behave well in terms of other language features:
Its a choice. I don't think its a good choice. I think this will make the rest of your code harder to write.
Also you are performing a bunch of uneeded copies. Capture these values by reference rather than value;
The only reason to use this-> is to disambiguity a member variable from a shadowing local variable. If you forget to use this-> there is no error or warning you will one day mistake and accidentally forget and thus have an error in your program.
You are in a constructor.The member vnum has just been default constructed (because you did not do anything in the initializer list). So this call to clear() is redundant.
But here you do want to throw an exception and let it escape your class. You do not want the user to be able to construct an invalid object. If the input is bad throw an exception. Force the user of your class to catch and deal with exceptions. If they do not deal with exceptions then the program should exit as you would be running code with an invalid object otherwise.
As a result the bi parameter should be marked as a const.  Also you are passing by value. Your object contains a vector so this is forcing a copy of the object just so it can be printed. So pass by const reference => BigInteger const& bi.