Also in #2 you avoid to manage and transfer private keys, everyone can use is personal keys and you only need to know the public part.
You should have a key rotation strategy for your root-key.pem anyway. In the event someone potentially loses this key. However, number 2 is generally the right way to go about this. Credential sharing should never be the recommendation although I dont doubt it happens often. There are a lot of ways to potentially implement and manage number 2. Some type of directory service is the most common, but it isnt the only option. You should consider some type of configuration management to handle either 1 or 2 so that it reduces the overhead for your team.
Yet #2 is easily scriptable if you have programmatic access to the users public keys you can build an script or use some configuration management software to retrieve it from a public server. For example the public keys of a github user are exposed in https://github.com/<user>.keys you can write a script that grab the github keys, write on the associated authorized_keys of the user and give the user admin privileges only knowing your user's github names.
In #1 when someone compromises the key every user has to rotate keys, instead if everyone has his own key only the affected user needs to do it and can be removed from the admin group.