I could only find room for one comment, being the reminder that the terminating character needs to be skipped. This might help with future maintenance (those gosh darn off-by-one errors!).
I don't see anything in this code that needs to be commented. To echo what other people said, comments should clarify code and they should never say what the code already says.
If you want to do a good job at commenting you need to write down the preconditions, post conditions and non-obvious gotchas (which should be avoided). Something like this:
Usually when I comment I look over the code and see what might be unclear to other people reading the code, and then I try to explain that line in plain english. What's clear to you about your own code isn't always as clear to others. So a good tip would also be to have others look over your code, ask them what they don't understand about the code and then write comments based on their feedback. 
I find by using the standard libraries as much as possible you can reduce the number of comments you need because they are well understood.
Even if names become a little long, make them obvious. Don't abbreviate. Some people say that abbreviating well known terms within your industry are OK. I'm from the camp that disagrees. Never assume that the next programmer is an expert in your industry.
Even if it's just a brief explanation of what it does. It will also help you in the future if you ever go back to check out your own code. You might be thinking to yourself "what the hell does this even do...?", then you will appreciate even commenting on the smallest things. As a personal opinion I think it's better to comment too much than too little.
The function never returns a string containing a newline. I am unsure if this invariant should be documented, but you could write a unit test for it.
It is also worth mentioning that recvBuffer is used internally to buffer data. All other reading functions must check that first before doing a read operation on the socket, which becomes extremely important when adding new reading functions later. (You remember now, but not next week).
This is an example, your actual code does things differently, but you should see where this is going.
Adding comments for the implementation is difficult, because I only see the obvious things that are not worth pointing out whereas I cannot see and comment the hidden gotchas that are worth commenting. One thing that jumps at me is that you manually lock and unlock a mutex. If a socket error occurs you leak the lock, creating deadlocks later. Either document that //WARNING: Function may leak a lock and cause deadlocks!!! or, if I missed your safety mechanisms, state that: //This function can never leak OSFactory::lockMutex. You can do that using RAII classes such as std::lock_guard. Same thing for manually using new and delete, std::make_unique would fix that and make the code easier.
I don't know the actual types of some of the variables used in your code so this example may very well not work in your case. But similar code might be rewritten a bit like this:
When it comes to "reducing lines" I have mixed feelings about omitting optional curly brackets. It looks nicer, but becomes extra typing when you have to add one line of code. I go back and forth on that and have come to a compromise with myself.
I would also want a comment explaining why you internally create an std::string which then gets converted to CString. Bug or feature?
Really, the biggest problem I see is one of the biggest problems in Software Engineering. As Martin Fowler once said: