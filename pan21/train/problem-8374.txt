The other answers here are very good, especially the accepted one by Brendan. I would like to add one additional comment. You wrote:
Now the big thing: You don't have "steel". You have "feet of steel". What if the spec changes and the amount of steel is entered in meters? Or in pound, and you have to calculate the length? Better to write
Do not worry about wasting a few CPU cycles here or there if it leads to clean, maintainable, clear code, especially during initial development where you may be changing things unexpectedly. You want to avoid premature optimizations that both distract you from your real goal and lock you in to a certain implementation that cannot be easily changed if and when it is necessary.
Your commenting is poor.  Commenting is difficult for beginners because it's hard for you to tell which parts of your code are obvious and need no more explanation, and which parts would benefit from having comments added.  As you gain more experience, you'll get better at this.
Program decides you can make 0 whistles. Note: unlike the previous examples, this is not a "failed to check for invalid input" problem.
Program doesn't say "Error, try again". Instead it displays all prompts without waiting for any user input and exits.
Roughly 50% of all programming is about dealing with errors. You say your code works, but it doesn't handle errors and therefore doesn't work.
so if the spec changes it is much more obvious where in your code you have to make changes. For example: 
In a similar vein, your comments on the lines that read user input don't help the reader understand the code: it's obvious that those lines read in the amount of steel, brass and ball bearings.
I know this is may be general advice and a bit premature, but if you keep this in mind (as well as all the information in the other great answers here) you will be setting yourself up for a smooth and productive experience.
I want to touch on your comment about making it "more efficient" with just a simple comment: Don't. Write your code, get it working. Code cleanly and do what makes sense to keep your design straightforward. Document your code, think about others who might view or work with it, and think about yourself in the future coming back to it and not remembering what you were thinking when you wrote it.
Most of your comments are completely redundant because they don't add any explanation. For example, you have several instances of
On the other hand, you don't document the two Calculate functions at all. That's the only part of the program that really needs explaining, since it's the only part that uses facts specific to the problem that you're trying to solve (e.g., what materials you need to make a bell or a whistle.)  You could say something like
Program doesn't say "Error, try again". Instead it displays all prompts without waiting for any user input and exits.
Use comments to document the PrintLine function, not the places where it's called.  It's pretty obvious that it prints a line, so you don't need to keep saying it.
Once your program is written, then ask yourself: Is it not meeting the hard performance requirements I have set? Is the UI too slow? Is some algorithm here or there taking too long and actually affecting usage of my program in a noticeable and negative way? Am I running out of memory somewhere? If so, then first concentrate on improving any algorithms or logic on a higher level; perhaps, for example, you are sorting a large amount of data and it is definitively too slow or resource intensive -- first consider a different sorting algorithm. After you are satisfied with that, then if necessary you can proceed to add further micro-optimizations but only after you have clearly identified where the actual bottlenecks are (e.g. profiling, or measuring function times, not just blind guessing). 
The result of dividing steel by 0.5 isn't an amount of steel. It's an upper limit for the number of whistles you can make. So write
It is very common for new programmers to start wanting to make unnecessary micro-optimizations right off the bat; especially in areas that don't really matter (e.g. writing a program that say, generates image files, but trying to optimize the code that checks if an output filename string is valid.) Don't go down that path! Design -> Implement -> Test -> Profile -> Optimize -> Test, and only do the last 3 if your performance requirements aren't met.
Program doesn't say "Error, try again". Instead it assumes 3 feet of steel; displays "How many ball bearings" and doesn't wait for user input and assumes 4 ball bearings.