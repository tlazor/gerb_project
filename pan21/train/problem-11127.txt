Both approaches should result in the same result, so your choice really comes down to what makes the most sense architecturally.
But the advantage of #1 is that you have more flexibility in how systems interact with each other. Suppose you have an animation system and you want to avoid updating it for far-away objects, since the player won't see them at all. But your physics system might depend on the animations as well - let's say your game is a fighting game where character animations change the physics shapes. You can easily handle this if you update on a per-game-object basis, whereas if you went with #2 you'll get a messy tangle of inter-system dependencies.
But first, your example for approach #2 is incorrect. Each system should have a collection of components, so you do not need to have multiple loops over your game objects. That is:
The advantage of #2 is it gives you more flexibility in how to implement system-specific updates. For example, for a physics-heavy game, you might perform a clustering pre-processing step so that you detect collisions only on pairs of nearby objects. It's also cache-friendly as you're repeating a small bit of code over lots of data in one go.
No, not all components require an update. Instead, Write granular systems which handle tasks common to a subset of components, such as updating position by velocity, or computing your graphics transform from position.
It looks like your understanding of this has a few gaps, so I would recommend doing some more reading on Entity Component Architecture, before doing any more work on your engine. I think you will find it illuminating.
Within each system, you have customised loops that only work with a small subset of components, as mentioned before.