This approach uses approximation, since I'm not sure how this would be solved for a definitive answer, but this solution will probably work for your purposes, as long as you aren't Nasa.
First, you need to find how long it takes object A to make 1 full rotation (also known as the period of object A). Call this P. Then, find the distance from object A to the center of its rotation (or the radius of object A's rotation). Call that R. These are constant variables, and should be determined ahead of time.
Then, at runtime, find the distance from object A to object B, and divide that distance by B's velocity to find the time it will take B to reach A if A remained stationary. Call that time T2. To get the distance around circle, create a new Vector2 (Mathf.Cos(T2/P), Mathf.Sin(T2/P))and multiply it by R. Add the orbit's position to that vector to give you the point that A will be at when B would reach A. Call this position A'.
Now, you will notice that A' isn't where A actually will be when B hits A. If you want more accuracy ahead of time, you can repeat this process multiple times, each time finding the distance between the projected point A' and B instead of A and B. You could do this, say, 30 times right before you launch B, and that might give you a close enough estimate that you don't need to calculate it once per frame. Or you could do this 3 times per frame, adding a little lag to give a better estimate. It really just depends on how much accuracy you need, how much performance you're willing to sacrifice for it, and whether you prefer lag spikes or slower frames.
Finally, all you have to do is tell B to aim straight towards A'. A' is recalculated every frame, so B will travel in a more or less straight line and hit A.