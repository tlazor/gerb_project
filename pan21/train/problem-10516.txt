I think this is a good start. It's straightforward and easy to read. The data is immutable, which makes it less error prone. Here are some things I would change.
I notice that your circle doesn't have a location. Why not? In most of the code that I've dealt with where I have a shape, there's almost always a location or position for where the circle is in space. This is usually necessary because I often need to draw it, intersect it, hit test against it, etc. I would suggest creating a Point or Coordinate class and using an object of that class as the location of the Circle.
Idem, as a return value: const double & corey::Circle::getRadius() const. A const reference will act as a value, so return by value is better (and more idiomatic): double Circle::getRadius() const.
You should rather start from what functionality you want to offer, and derive your implementation from it. If your circle is defined only by its radius, it's basically a double. And I can sum up all of your code by:
If you are learning C++, then you should start using qualifiers immediately, so that it becomes second nature. There are 3 notable ones in your case:
It's been said frequently that one should avoid using using namespace std. I'll let the experts explain it.
You probably have read about data encapsulation, that principle according which the class, and the class alone is responsible for handling its data members. Your design is built around this principle.
Don't take such things too literally. In this case, it makes your interface difficult to use without any safety benefit. If I want to modify the radius of my circle (which sounds legitimate), I have to assign it a new circle with the desired radius. That is unefficient and cumbersome.
I don't see any reason to make every circle behave like it is const. Client code might legitimately wish to differentiate const circles and those which aren't.
I also don't think naming a namespace after yourself is too useful. The name of a namespace should tell what it's for and hint at what it might contain. I don't know what corey should contain.
The ability to overload the basic math operators is a nice feature of C++. However, it can be confusing if the meaning of those overloads isn't obvious from looking at the class definition. It's not immediately obvious to me what it means to add 2 circles. There are places where adding and subtracting shapes makes sense (constructive solid geometry), but the results are very different from what's happening here. I think the overloads you have are likely to confuse future readers of the code. I would make regular methods with names like addRadiuses() and subtractRadiuses() instead.
Instead of using a using directive, or littering your code with corey::s, the best thing to do is encase the whole implementation inside the same namespace, e.g.
References aren't always the way to go. In your constructor (Circle(const int & r = 1.0);), it isn't optimal to get the argument by reference, because an int will be smaller than a reference (a pointer under the hood), generally 4 bytes vs 8 bytes. So it'd be better to pass it by value: Circle(int r = 1). By the way, 1.0 is a float, so the assignment looks a bit weird.
Or, you can simplify more radically your design and implement Circle as a struct: struct Circle { double radius; }; seems good enough, at least until you have a good reason not to be satisfied with it.