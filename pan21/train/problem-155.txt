The question whether to use (T) -> Double or Comparator<T> probably depends on your use case. If you have a scenario where you explicitly know, that your objects can always be mapped to a double, then it's fine to use (T) -> Double. 
IMO, no, not directly. That actually touches one of my criticisms I have: You have several "utility" methods (randomBest, firstBest and possibly contains) which don't seem to fit into the purpose of the class IMO, especially since they can just as well be executed on the list returned by toList.
I'm sure there is a scenario where this could be used, but I don't like the name either. Maybe something like BestWeightHolder?
And finally, personally, following Kotlin's pattern, I would consider implementing this as an immutable class.
I'm not a big fan of the method name next. Methods of that name usually indicate a supplying method (as in an Iterator, for example). I'd suggest add or (following Java's Integer/Long/DoubleSummaryStatistics classes which have a similar function and which implement Consumer<T>) accept.
I think you should drop those methods and replace toList with an asCollection method, which returns not a copy of the list of best items, but a direct reference of your internal list limited to the Collection interface (or if you want to make sure it is not cast back to a MutableList and modified, an instance of a thin wrapper class that implements Collection). The user then can use first(), random(), contains()and more on that.
On the other hand, once you have such a weighting function, then it's trivial to create a Comparator based on that. And (my gut says - I haven't researched it) the reverse (creating a weighting function out of a Comparator) may not be possible. That means a version using a Comparator would be more flexible.