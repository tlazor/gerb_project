Finally, I reveal the actual "names" of the fields. The short values between the names is labeled "Grade I expect to get in this class". The point of the exercise is to reinforce that the names of variables should define the information they contain. Otherwise, reading the code and understanding what is does is difficult, even for the author after only a little time away from it.
So, the paper may be overkill for the experienced programmer, but is a useful educational tool for teaching proper program structure and naming.
What methods will work depends, in part, on the teaching style. The effectiveness of any method also depends on the instructors consistency in presenting, and using, what's being discussed, and on the costs associated with following vs. not following the set guidelines. Students are no different than any other group of people, and decisions, including unconscious choices of what practices to adopt, are made on the margin. It is not the value the guidelines, or conventions, hold for their future selves that are significant in what they do. Rather, of importance to them now is what benefits they get now by following them, or what costs they pay now for not following the guidelines. "The costs now weighed against the (perceived) benefits now."
First of all, note that I've only tested this method on myself, so I have no guarantee that it is widely applicable. However, this would be my approach if I want to teach naming practices to others. Also, I will restrict myself to the naming of functions as 1) these are among the most important code artifacts to name (independent of language!) and 2) the methods I describe are easily adapted for other code artifacts (although it may be overkill for relatively 'low level' parts such as local variables)
In writing software we name things. In Java we name classes, interfaces, methods, variables, etc. How can we teach both the importance and the skill of choosing good names? 
In my personal experience, this approach also works well for writing programs. First write a "rough outline" of your program on paper (e.g. For input with description X I want output Y. To do this I need functionality A,B,C and data structure D,...), possibly with diagrams or such. (In case the students don't get enough structure, simply ask them to split up a function)
I'm not sure my experiment has really taught he students to create better names, but when I review student code, I do make comments on naming. I suggest that students read other code for conventions and adopt a "style" that suits them. I also suggest that when the students work in existing code, they adopt the style of that code. I believe consistency is more important that the actual convention.
As a bonus, if that method is used as the design process, you can use the same project, notes, slides, and handouts for classes in every language, and adjust the final pages for the language of choice. In any case, importance comes from the fact that there is no other way to know what each "machine" does except by its name. No code has been written that explains it, only the name exists. The "skill" is taught, like any other skill, with lots of corrected practice².
My answer is similar to that of Fritz Sieker, in that we both start on paper, but there are enough differences to post an answer of my own.
What teaching practices will lead students naturally to good practice in naming their programming constructs?
Good naming is important for both the creation and maintenance of programs. Good naming also makes the evaluation of the student programs easier when the student uses, for example, intention revealing names consistently. .
The course outline, and the progression of subject matter might not allow this approach, but the method of development that Dijkstra presents in his "Step-Wise Program Composition" example¹ seems to be perfect for automagically creating meaningful names. It is also language agnostic until the very end, which makes it usable in any environment, except possibly the classroom - if the lessons are required to go from low-level to high-level.
How important is naming in the creation of quality software? In particular, how important is it to teach good naming and insist on it in student programs? 
I follow up using short (often single line) helper methods in lieu of inline code. . For example, an if statement may have a complex set of conditions. I demonstrate how to pull this out into a single line function and, if the function is well named, how it makes code easier to read. For example I use something like comparing if (row == (numRows - 1)) vs if (atEnd(row)). 
Before we worry about names, let's take a look how to start writing a program in the first place. When writing an essay or report, it is often most useful to start with a brief outline of what you want to say before actually writing everything down. (a top-down approach, in other words) 
Note that much of this applies to other languages, but Java is a popular teaching language. Java is mandated in the Advanced Placement courses commonly taught in the United States. It is also a common language in first courses taught to undergraduates. 
Of course, I immediately get questions about what goes in each filed? "Isn't it obvious?". After a little time I show a form that was filled out correctly. However, I use names in several fields that could easily be either a first name or family name (e.g. Paul, Kelly). In the short field between the two names, I put a "A". Most students assume it is a middle initial. Some of the fields contain numeric values values that could be almost anything.
...your students may ask. And perhaps they are right. However, there are good reasons to use the paper:
I have another answer that deals with the "value" aspect on the How to teach the value of the command line in high school? question, so I'll skip over that. Basically, you can force (require?) the students to do something. Their grades, and there possibility of graduation, may well depend on that performance. You cannot, on the other hand, make them believe, or think, something. You can, however, sell ideas, and lower the costs so that they will likely "buy-in" to the ideas.
I believe the argument that naming is important in the creation of quality software is a bad choice, if not a red herring. First off, the quality of the software does not seem to be related to the names used. If so, programs written in machine code would be abysmal since machine code admits of no names whatsoever. Secondly, I'm quite certain that it's possible to find one or two examples of non-quality software that does, in fact, have good naming throughout. The quality of the software is not related to the goodness of the naming. The ease of understanding the software, now or in the future, by the author or by others, is affected by the naming. The majority of the code created in class projects is disposable code. There is no value to the students in making it easier to fix, modify, or upgrade later because there is no later for that code. That takes us back the the margin, and in light of the marginal costs vs. marginal benefits maintainability is going to loose the majority of the time.
As to which teaching practices lead to, and which impeded, the development of good naming practices, it's the same answer: the instructor's behavior. As noted in other answers, if you're consistent in the use of the guidelines in everything you present to them, they will come to accept it as possible. Until then they will be thinking that it's just not possible to always use intention revealing names. The off shoot of that thinking is that if it's not always possible, then it cannot always be required, so using it only when convenient is excusable. If you never fail to use such names, even in disposable, on-the-board examples, then it becomes possible to always use them (you've proven that), and there is, therefore, no grounds to argue for exceptions. The reverse is just as true, and more treacherous. If, sometimes, you slip up, and don't use such names, you've demonstrated that sometimes programmers will not use such names. Even the instructor doesn't do it 100%. If the instructor doesn't always use intention revealing names, why should the student?
Something I have used is to present the students with a paper form (like an application form). Each of the fields is labeled sequentially with A, B, C, etc. Then I ask the students to fill out the form with information about themselves and tell them that getting all the answers correct will determine whether they pass the course or not.
If you've followed my method so far, you now have a piece of paper with some functions or ideas for functionality that your program needs. As we have determined what we want from our individual functions, we can now give them the name that tells us most clearly what this function is supposed to do or represent. In fact, it is likely that there already is such a name on your paper! 
So, the only thing that is left is to check whether you need to change the name to adhere to some conventions. But this is just checking for proper form, which is a lot easier than the proper meaning of the name. In other words, we have already finished the task of finding proper semantics. Finding proper syntax to express it is easy in comparison. (This is a rather mechanical task and some IDE's can even check this automatically!)