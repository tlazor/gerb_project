You printed timestamps, presumably as a way to measure performance.  However, java.util.Date is only precise to the second, which isn't useful.  Even then, you can't meaningfully measure performance while you are also spewing debugging output, since the printing itself would account for much of the time spent.  (The default logging handlers happen to print timestamps on all messages.)
The loop is cumbersome.  A for loop would be easier to read.  The termination check could just be i < output.length â€” whether the output has been filled up.  The loop copies one element to the output per iteration, so the i++ should be factored out.  (The code below is a variant of your original code.  The way @janos wrote it is a bit more efficient.)
If I had to pick one of the functions to trace, I would pick merge() instead, since it is more error-prone, and you don't need to artificially introduce the left/right distinction.
You have a bit of a bug: your merge routine is not stable.  A stable sort has the property that if two elements in the input are equal to each other, then they will not be swapped in the output.  Mergesort can be stable if implemented well, therefore it is generally expected that it be implemented with the stability property.  When sorting primitives, it makes no difference, but the issue does become relevant when sorting objects, so you might as well do it "right".  To make your sort stable, simply change if(leftArray[left]<rightArray[right]) to if (leftArray[left] <= rightArray[right]).
A better way to add debugging output would be to use the Java logging API.  Create the following logging.properties file:
Then execute the solution below using java -enableassertions -Djava.util.logging.config.file=logging.properties MergeSort.