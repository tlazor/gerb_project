Each frame we determine the movement in the X and Y directions. If moving left we take the leftmost edge of the hitbox (similarly for moving right, up, and down) and determine what tiles that edge is intersecting with. Go through these tiles to detect any obstacles that would prevent movement and move the character the minimum distance it can move. Repeat until you've calculated all movement for the frame.
Optionally there is a similar 1-pixel collision for the left and right sides at the centre to handle the case of a wall up a slope (in green).
I'll describe the basic algorithm the article provides, but I encourage you to read the whole thing for more comprehensive explanations/insights into these systems. There are for sure more efficient, intuitive ways of doing 2D collision systems nowadays, but this is what I can gather from your specific question.
This could be avoided if there is never a wall up a slope and some games did this. When you only had between 1 and 8MHz you saved where you could.
Another case we need to consider is the top and bottom of the entire slope (the tile with the blue dot marked on it). To prevent the character from being stuck, we should ignore the full tile obstacle immediately before and after the slope is completed. The article does this by checking if the slope is filled on the left or right edges, meaning that we're at the end of the slope's tiles.
A lot of this is pixel-perfect math and collisions which depends heavily on the coordinate system you're using for your tilemap.
One other way this could be handled is by checking for collisions at the center of the character's base first, and falling back to the adjacent overlapped tile if no collision is found there.
Unless you're targeting an ~8Mhz micro-controller or want to reproduce the particular issues this trickery could cause an actual diamond-shaped collision can now be used on modern computers.
To save on processing the special case collisions were not a real diamond but single pixel-sized checks. This worked fine with the limited slopes shapes and making sure to edit the map accordingly to avoid the possibility of wedging the character.
We first need to check the X direction of movement, and before checking for collisions, we first check to see if the tile we are on is a slope and register the tile as a collision only if we're going up the slope (in this case moving left). If we have a slope collision, we'll have to move the player up in the Y direction.
The whole level is built as a tilemap with all the relevant information stored on the tiles (type of terrain, player effects, etc...) and characters have their usual collision/hit boxes. Much of 2D collision systems, especially for older games, involved pixel-perfect math and the like.
There are multiple ways to do collision systems in 2D games. I find it unlikely that this particular game didn't use a tile-based system of some kind, sprites larger than their hitboxes is a common feature for tile based platformers, and pixel-perfect tile systems are still extremely useful for modern games as well. The only tricky part about it is to handle slopes and other edge-case obstacles like one-way platforms. This article provides a decent explanation for several collision systems, though it is by no means the only method.
I think this policy of always using the center of the character's base for collisions, and only looking at the single valid collision tile closest to that center, can account for all of the cases shown in the screenshots.
Regardless of which tile we end up finding collision in, we always calculate the floor height using the same point in the middle of the character's base, which here I'm calling characterFootX & Y respectively
The full collision (in blue) only checks for full blocks completely ignoring special tiles (yellow).
For old 2D games full vector collisions were too CPU heavy and shortcuts were taken. If you want to recreate the same feel and it's associated collision glitches you will have to use the same tricks.
For vertical movement, usually we have gravity being applied to the character, so again we check for collisions in slope tiles and move the player down accordingly.
Once the foot pixel check (yellow) detects being inside a slope it pushes the character up as needed and disables the full collision check to allow walking all the way up the slope. If the full collision (blue) wasn't disabled when inside a slope cell you'd get stuck halfway up the slope due to hitting the side of the top full cell.
Well, you answered it yourself. When Kirby is standing on a "normal" tile, the bounding box is rectangular and when he is touching a slope, it turns into a diamond.
That was for maps without slopes, and adding them can get tricky. Unless you want to do some more wacky calculations, it's best to keep the slopes used a consistent size. So, for example, a ramp that is 4 tiles long and goes up 1 tile should never be placed with gaps or end prematurely.