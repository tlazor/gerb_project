I don't know how well P models "efficient" computation in the real world, but we like the class because of its nice closure properties and other mathematical reasons. Similarly, L is also a nice class due to some of the aforementioned reasons.
Another reason to study polyL or similar classes like quasi-AC0 is that while an oracle separation between (say) ParityP and PH implies that PARITY is not contained in AC0, the reverse implication is not known to be true. On the other hand, PARITY is not contained in quasi-AC0 if and only if there is an oracle separation between ParityP and PH. Similarly, the classes quasi-TC0 and quasi-AC0 are different if and only if there is an oracle separation between CH and PH. So the usual complexity classes like PH, ModPH, CH, etc. when scaled down by an exponential to prove oracle results turn into quasi-polynomial versions of the usual classes AC0, ACC0 and TC0 respectively. Similarly, the argument used in Toda's theorem (PH is contained in PPP) can be used to show that quasi-AC0 is contained in depth-3 quasi-TC0. (I don't know if the same conclusion is known for the usual versions of these classes. I have seen this listed as an open problem in some papers.)
Note that your definition of PolyL also gives PolyL = NPolyL, by Savitch's theorem, since $\text{NSPACE}[\log^k n] \subseteq \text{SPACE}[\log^{2k}n]$.
However, as you commented, if we relax our definition of "efficient" to quasi-polynomial time, then PolyL is also efficient. We could discuss complexity theory where we allow classes defined with a logarithmic bound on some resource to use polylog resources instead. Correspondingly, we would also relax our definitions of NC, NL, etc. to allow quasi-polynomial size circuits instead. If we do this, NC1, L, NL and NC all coincide with the class PolyL. In this sense PolyL is a robust class since many natural classes coincide with it. For more information on complexity theory with log -> polylog and polynomial -> quasi-polynomial, see 
Log-space guarantees polynomial time, since there are at most $2^{O(\log n)} = \operatorname{poly}(n)$ configurations of a given log-space Turing machine.  The complete problems of Undirected Reach and Directed Reach (for L and NL, respectively) are very "nice" to think about.
I think all the other answers are very good; I'll try to give a different perspective on the issue. 
The smallest class containing linear time and closed under subroutines is P. The smallest class containing log space and closed under subroutines is still log space. So P and L are the smallest robust classes for time and space respectively which is why they feel right for modeling efficient computation. 
When polylog space is concerned, work has been done to consider polylog-space with simultaneous polynomial time, giving the SC hierarchy: $\text{SC}^k = \text{TISP}[\operatorname{poly}(n), \log^k n]$.  