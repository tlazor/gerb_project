The time outside the system call is the time spent running your program's code before it gets to the next system call.
A CPU bound process spend most of its time outside system calls. This is the state a process will be in, while it is performing computations. For a CPU bound process the difference between the two numbers will be large, and probably by at least an order of magnitude.
The percentage of time spent inside system calls versus the percentage of time spent outside system calls will roughly tell you if a process is CPU bound.
A process which is not CPU bound will be blocked waiting for events most of the time. Since blocking can only happen inside system calls. For a process which is not CPU bound, the numbers will be approximately identical (probably only differing by a one digit percentage).
Based on the documentation you quoted I find it quite clear that one is covering the entire duration from one system call to the next, while the other covers only the time within a system call.
That was the simple explanation, in reality there is a few more aspects to consider. Due to memory mapping and swapping, a process can actually block without being in a system calls. Additionally the kernel could offer features, which involve computations inside kernel code. That could lead to a process spending most time inside system calls and still be CPU bound. The latter for example could happen when using encrypted file systems.