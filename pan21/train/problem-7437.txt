You don't actually need a linked list, nor any other complex data structure (outside of the board array itself) to do a snake game.
If you're going to be making the snakes grow and shrink a lot, then consider the linked list answers.  Lists will make your life easier, but are not mandatory.
Why not have the value for the array[x][y] increment down to zero each update (move) where when you move the head of the snake you place down a value of the length of the snake itself. Using this you could search the board for the value 1 for the snake tail and a defined value for the snake head (-1). Upon an expansion of the snakes length just decide not to decrease the valued for the board that turn. 
When doing your movement logic, before you update the head with a new position, loop through the array from tail to head.  For each position in the array, you need to change it to the next value in the array.  So in some pseudo-code:
The simple answer is that you need to track all of the snake's body positions, not just the head and tail.  If the snake is always going to stay 3 segments long, you can stick to an array of (x,y) positions of length three.
Doing it this way, it becomes trivial.  Simply reposition them one by one working your way down the list.
When the length is greater than the maximum length, you find the tail, and it will have exactly one connection flag to another cell.  remove that connection flag, then move the tail that direction, then remove the OPPOSITE direction connection.
Next, when moving the head, you know which direction you are moving, so you add that directional connection to that board cell, you move the head, then you add the OPPOSITE direction connection.  When you move the head, you add 1 to the length of the snake.
For ease of understanding, consider booleans.  One for each of snake body segment present, connection to the north, connection to the east, connection to the west, connection to the south (thinking of a screen in terms of a map).