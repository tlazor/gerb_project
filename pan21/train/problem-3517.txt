For more advanced physics or action simulation, you might go to two timers, one timer that changes e.g. 10 times per second and all actions are calculated relative to this one. And a second timer that is actually not independent, but is interpolated from the first one, so that you can get several frames in between the two physics updates.
A single timer is a viable option in many cases, but while one-time-per-object might be a bit overkill, there are good reasons to have multiple timers and/or time sources.
If updating your entities takes a long time this won't affect the game's fps and you still can get at least 60 fps. Also, updates might not need to be processed 60 or more times per second, maybe only on user input.
I've made a simple 2D game engine using C# and DirectX and it's fully functional for the demo I made to test it. I have a Timer object that uses QueryPerformanceCounter and I don't know what's the better choice: use only one timer in the game loop to update everything in the game, or an independent timer in every object that needs one.
In general, you want one time source for each batch of things that should operate on the same timeline. Typically you'll have all your game logic objects slaved to a single time source, but you might also have a few extra timers for rendering systems -- perhaps one for the primary in-game rendering and one for interface rendering. 
My worry is that when I try to implement threads, what will happen with timers? What happens with the sync?
It is often useful to separate out the actual real-time clock from the presentation of the per-frame time deltas (the actual time source), allowing you to drive multiple time sources off any given clock to ensure you're using a single canonical "current time" and simply scaling its delta appropriately in each source. There are also reasons to use a separate clock entirely for things like physics, which tend to work better with fixed time steps.
In a simple game I would use at least 2 timers (on 2 separate threads), one for the update loop and one for the rendering loop.
As for the threads, this is a completely different question. Threads are about dividing the work, and not having separate time. If you have 4 cores, one main thread calculates the new time, and then divides the objects into 4 groups and each thread can calculate changes to one group. Then they all inform the main thread they are done, and the main thread can render all the objects at once. Notice how this way, even though 4 threads worked, they all calculated changes at the same, fixed moment in time.
If you do that you'll want to be using a different time source for things like your HUD render effects, otherwise they would slow down (or pause!) when the game logic did, which would likely render them unusable.
The reason you'd want to do this is because it allows you to implement certain behaviors very easy by simply scaling your time sources relative to real time. For example, you can implement game logic pausing by forcing the per-frame delta time returned from that time source to be to zero, or you can implement a "slowdown" effect by scaling that delta time by some factor, such as 50%. If your object updates are correctly written to handle it, you can even rewind time this way.
It is absolutely critical to use a single timer! If you query for time for every object, that means a scene will be filled with many objects whose position is calculated at different time. You need to think about a single frame as an image of all objects, all frozen at a particular moment in time.