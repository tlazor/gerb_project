You would then define variables and parameters to accept objects that implement a specific interface, and then the code working with them would know what it can call... and can always query for other interfaces, if it needs to see if other functionalities are also implemented for the current object.
Each of these approaches has use cases when it's the best one, no one approach is an absolute best solution for all cases.
Inheritance, or the is-a logic: you use it when the new class is going to behave and be used completely like (outwardly) the old class that you're deriving it from, if the new class is going to expose to the public all the functionality that the old class had... then you inherit.
Class Fox, obviously, cannot fly. So if you define the ancestor to have all the features, then you could not derive the descendant properly.
The key point here is that this is the use case where you don't want to expose the original class features and use to the public, just use it internally, while in the inheritance case you're exposing them to the public, through the new class.
Whenever someone tells you that one specific approach is the best for all cases, it's the same as telling you that one and the same medicine cures all diseases.
Interfaces are for yet another use case - when you want the new class to partially and not completely implement and expose to the public the functionality of the old one. This lets you have a new class, class from a totally different hierarchy from the old one, behave as the old one in some aspects only.
If the new class just needs to internally use the old class, without exposing the old class' features to the public, then you use composition - that is, have an instance of the old class as a member property or a variable of the new one. (This can be a private property, or protected, or whatever, depending on the use case).
If, however, you break the features into groups, representing each group of calls with an interface, say, IFly, containing Takeoff(), FlapWings() and Land(), then you could for the class Fox implement functions from ITalk and IPoop but not IFly.
Let's say that you have assorted creatures represented by classes, and they have functionalities represented by functions.
Inheritance vs composition is an is-a vs has-a question. Interfaces are yet another (3rd) way, appropriate for some situations.