One thing I would strive to do in either of these cases, is any information that feels as though it's leaking from the subsystem abstraction to the UI should be pushed into the system.  The UI should be designed in such a way that perhaps these values could be tweaked in the system and the UI adapts accordingly.  For example, the BattleSystem maybe has a method that tells you the grid size is 3x3 but in a later release you decide it should be 4x4 or 5x5.  By allowing this to be data-driven, the UI no longer cares necessarily about it and just adapts, really allowing the UI to be as decoupled as possible from the system's logic and implementation.
The key take away is don't be hesitant to design a system or systems at one layer and then wrap those system(s) up into a larger system at a higher level until you reach the level of abstraction and generalization you need to keep things decoupled at their respective levels, but cohesive enough across layer boundaries without impairing design.  
It seems to me that you're mixing the visual representation with the logical representation of what you're trying to create.  Lets discuss your two scenarios.
I believe this scenario again follows a similar premise. You can easily abstract the component, entity, and logic aspects of the battle system into a BattleSystem that is part of your ECS.  This system again implements a specific interface that defines the contract between the UI and the system.  Now, when a user performs a UI action, the UI simply calls the appropriate method in the BattleSystem and whatever interactions must occur between it, entities, and components happen. 
In this situation, I would simply have the Equipment UI be capable of querying the inventory system for the current player.  This allows the inventory system and it's management to remain inside your ECS framework and you are simply allowing the UI system a means to ask the inventory system what it's contents are and visually represent the data for the user.  When users move items around in their bags, the bags simply call methods on the inventory system that manipulate the components accordingly.  This way, the Equipment UI screen really knows nothing about the ECS.  It simply has a reference to a class that implements an Inventory System interface and through that instance, it can obtain the information it needs to draw itself.