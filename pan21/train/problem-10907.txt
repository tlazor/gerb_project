So you're going to have to move up a little.  For example, if you have the imaging subset available you could apply a color matrix which would achieve the greyscaling.  Better yet, with a fragment shader it's just a simple dotproduct operation.
So this isn't the answer you're looking for but then again neither is OpenGL 1.1 - just move up to a higher version and use it's capabilities.
All of this begs the question - Why are you restricting yourself to OpenGL 1.1?  The last hardware that only supported 1.1 was in 1997 or thereabouts, and shaders have been absolutely ubiquitous for a decade or so.  These certainly aren't fancy new features that you'd be taking a risk on; they're mainstream even down to the lowest of low-end.
In OpenGL 1.1 there is really no way to do this efficiently.  You may be able to do something with glCopyTexSubImage2D to a GL_LUMINANCE target texture, but (IIRC) that will sum the colour channels during the copy process so you'll lose a good deal of brightness.  Or you could load a second (greyscaled) copy of all your textures and use those instead, at the cost of increased video RAM usage.  But just being able to say "give me a greyscale output from this" is something that you won't be able to do.