If you want the user to see certain output, regardless of output redirection, print to STDERR (this is what warn and die do).
I see you have the -w flag on the shebang line, but use warnings is more flexible. It has lexical scope, so you can deactivate warnings in a scope by no warnings, which sometimes is useful. In any way, it is a good habit to start.
Much of the power of Unix comes from the little programs you can pipe together to transform data (see Unix Philosophy, esp “Write Programs that work together”). They all have in common that they accept input on STDIN, and (mostly) print to STDOUT. The user can then take that output and display it, write it to a file, or pass it to another program.
The -T flag for mv uses the second argument as the target name. Otherwise, it will check if there is a directory with that name, and move the file there. E.g.
Always use a FILEHANDLE with print statements.  This avoids the accidental consumption of a variable as a file handle.  E.g. 
It is a bit silly to refactor such little code, but I think it better conveys what we are doing. E.g. the name normalization is common. Inside the substitutions, I removed unneccessary escaping. The second half of a substitution has the semantics of a double-quoted string, so the period doesn't have to be escaped. As a personal preference, I tend to use \z (end of string) rather than $, (end of… whatever, depends on regex flags).
When a Perl process exits, remaining open filehandles are automatically closed. Lexical filehandles (as you are using), are closed as soon as their reference count drops to zero (i.e. when they go out of scope). So manual closing is generally useless except for following two cases:
Obviously assumes that you assign $_ to $original and rename $s1 to $name.  Assigning $_ before using it is one of Conway's things.  It leads to more readable code if you pick a better name than $_ for the new variable.  
Use non-capturing parentheses (?:) rather than using () when just grouping.  Of course in this case, you only need to alternate a single character.  A character class is better for that than grouped alternation.  Thus [ch]xx is better than (?:cxx|hxx)
However, you print to both a file (in append mode! tell me a scenario where that is useful, and cat can't help), and STDOUT. The latter is enough. If the user wants the output on the screen, he does
This also helps with Leaning Toothpick Syndrome, e.g. s/\s/// -- where it can get confusing as to what is a delimiter, what is an escape character, and what is part of the pattern.  Contrast with s{\s}{/}.  
I also followed M42's suggestions but used the more specific \z (end of string) rather than the $ (end of line).  
But it still isn't perfect. What if we rename a directory, but also some of its contents? Then the resulting mv command will try to rename a file whose path doesn't exists any more. The solution is to use the finddepth function instead of find, to process the contents of a directory before the directory itself is passed to your callback.
Your script starts searching in the current working directory. This is a good default, but giving a start dir as command line option would be really sweet:
But it still won't work: File::Find will chdir into the currently inspected directory, so when we would run the mv commands, we'd be in the wrong working directory. But it's easy to sprinkle the code with cds.
If matching a single character, a character class like [.] is often more readable than an escaped character like \.
When we are already talking about security: If I were paranoid, I'd worry about filenames that contain single quotes, and other fun like semicolons, or ';rm -rf * ;, which is a valid filename for Linux. To mitigate these issues, one could
While you can pass multiple arguments to print, which will be concatenated automatically, you could also use the wonderful string interpolation Perl has—I find the above command more readable this way.  Esp. when writing code that writes other code, clarity is a security feature.
Note:  I don't take Conway as gospel.  He likes half-cuddled else clauses and I prefer mine fully cuddled.  And I dropped his mandatory regex modifiers msx (at least most of the time).  But some of his ideas make sense on their own.  I probably forgot some that would apply.  It's been a while since I read the book.  Anyway, following Conway will usually produce more readable and maintainable Perl code than just winging it.  Even just reading Conway and thinking about what you want to incorporate can help.  Perl has so many possible bad practices that it is easy to get committed to them before you realize their downfalls.  