The first question that pops into my head is, "Why so much inheritance?"  Why inherit IXmlRepository from IRepository?  What's the point?  
Your usage example is right on.  That's what you should aim for.  Short, concise, clear, to the point.  The operations are occurring on the same level of abstraction.
That being said, we do have a few people here who just "bang stuff out", and then they end up having to maintain it because they've failed to follow industry standards so the rest of us have to re-engineer it their way before we can troubleshoot.
I agree with qes on all points but in summary you've just taken the Interface Segregation principle a little too far.  But the most important point I want to get across is consider a career move.  You've demonstrated a willingness to learn so don't hang around in a team that's not willing to assist you in this.
The interfaces might be a little overkill, but they're not necessarily a bad idea. This is how the code is meant to be written. If it's too complicated for the lead and potentially the rest of the team, then perhaps the company needs a new team. I have to architect things with our junior developers in mind with respect to our applications, but on our team we always establish the needs of the project against the resources available to train up our juniors to be able to handle certain things.
I would just say that you seem to be unnecessarily creating a bit too many artifacts in the process that don't appear to provide any actual value.
You could use the OOP design patterns for this for sure, look at the seperation of concerns and use IoC if you like and strategy pattern to encapsulate some algorithms, just don't go overboard and apply too many design patterns. :)
I think that DDD might be a little too much for such a small task. You don'treally need a repository to hold a in memory collection of data since you are not dealing with a datastore per say, only transfering data from one output to another.
My advice to you is to continue to lead by example doing things according to industry standards, but don't become a maverick bucking every trend set by those above you. You could end up coding yourself out of a job. Continue keeping up with best practice and current trends, continue to rally for these things, but don't just begin implementing things because you think they're the right way. Your description of this situation sounds like you handled it just right. They asked you to do something, and you did it according to best practices and industry standards. If they had other requirements, they should have included those instructions up front.
Also regarding inheritance, why the abstract DataAggregator?  I understand you've cut down from the actual code, but from what I can see here it is again a totally pointless construct.
Another one: you have an inheritance chain that is XmlInvoiceRepository -> BillingRepository -> IXmlRepository -> IRepository.  Huh?  Why on earth is XmlInvoiceRepository inherited from BillingRepository?  Hopefully not just because Invoices are part of Billing in someone's conceptual model.  
I'd also take issue with calling that a "Repository" - I think that is one of the most overused terms in architecture at the moment.  Read Evans' DDD or Fowler's site and tell me if you really think that class qualifies under a definition of "Repository".  And then convince me that no one will get confused between that and some other type of "Repository" that exists in your project. (just going from my experiences here)
Also, you're throwing a lot of sealed's in there.  Why?  Are there clear reasons for that choice, or is it more just for good measure?  If the latter, get rid of it.  Be as simple as possible and no simpler.
Also, do you really need two interfaces to represent a function that can map from an XmlDocument to a generic type?  How many places is that really getting used.  Same question with your DataAggregator, how many different places is that really getting used.