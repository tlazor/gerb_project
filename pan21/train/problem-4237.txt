If the interrupt is coming back because of a stimulus that took higher priority than the current task being executed, I set the current task (the reference I mentioned earlier) to the root of the tree, and poll.  If your system is set up properly, your higher priority nodes should be earlier in the base few layers' selectors' lists, and so should be found needing before whatever it was that the agent was doing earlier would even be checked if it should execute.
Additionally, I've found that polling from the root out, every frame, is a bit wasteful when one is only really executing one task at a time, so I've been using a simple interrupt system, much like most modern CPUs do, rather than constantly polling a piece of hardware that is doing a task that can take quite some time to check if it's done yet, and keeping a reference to the "current task" (lowest level) that is being executed.  
When the interrupt is sent, depending on the reason for the interrupt, the current action decides how to handle it.
I've been working to implement a behavior tree in Unity for the last week or two, now, and I've found that it's much better to use very generalized task nodes when developing these things.  For example:  It seems (to me, at least) to be a lot simpler to have only one type of sequence and one type of selector, and to have "decorator" nodes that can change the behavior of whatever comes after them.
If the interrupt is coming back because the task either completed successfully or failed, it tells its parent task to move on past it, and to continue with its operations.