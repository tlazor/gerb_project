The way version control works in PostgreSQL, it will be very hard to update an entire table with more efficiency than just recreating the table, even if only one column is being updated.
If you really need to minimize write churn, you could construct the "day" column on the fly from an absolute calendar date using the row_number() windows function.  And you could wrap this in a view so that it functions just like your existing table to the client.  However, that means you have extra overhead every time the view is accessed, so you trade one form of efficiency for another.
Unless the table is into the millions of rows, you probably don't need to be too worried about efficiency.  My first impulse would be to just have a script every midnight that creates a new table from the old table with the needed updates, then drops the old table and renames the new one.  That won't play well with foreign keys, however.  (Actually, my first impulse would be question whether I really needed this volatile column in the first place--what do you do with this "day" column?  Is it only for presentation purposes or is it used in joins? And why do you have both a "day" and an "id" column which, in your example, get changed in lockstep and are always equal?)