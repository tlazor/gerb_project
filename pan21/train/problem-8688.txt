As far as addition and subtraction are concerned, many CPUs have a "carry bit" that is set if the arithmetic operation has overflowed.  So if a result will require 8 bytes to store, and the CPU is 32-bits (which equls 4 8-bit bytes), it can do two addition operations, first on the "low word" and then on the "high word" with the carry bit taking care of the overflow.  Necessary to clear the carry bit first.  This is one reason why higher bit CPUs increase performance because this does not have to be done as much.
I don't know very much about floating point math, but basically the bytes represent a fixed number of places, but not specific places.  That's why it's called "floating" point.  So, for example, the number 34459234 would consume roughly the same memory space as 3.4459234, or 3.4459234E+20 (that's 3.4459234 x 10 ^ 20).  
Of course this is from my limited assembler experience with 8-bit CPUs.  I don't know how the carry bit works with modern CPUs with multiply and divde instructions.  Non-Intel RISC CPUs may also behave differently.