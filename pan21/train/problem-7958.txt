Not only do these keep the data for you without extra steps or triggers, you also get some nice syntactic sugar to make querying this data easy for a number of common scenarios (show me all version of this item from last year until now, show me what this item looked like last week, show me what the whole table looked like a week last Thursday at 02:34, ...).
You can even create the target table using the base table as a template using something like SELECT * INTO NewTable FROM BaseTable or if you want to create the new table only and not populate it at all SELECT TOP 0 * INTO NewTable FROM BaseTable.
As pointed out already you can copy a row into another table as you are looking to do if they have the same column arrangement.
I would like to keep the history of a table using SQL queries without triggers. The simplest way to do that is to fire a SELECT and INSERT into the history table like below:
They have their own gotchas, and you still need to take some care with the table structure (though for some changes this is handled automatically too), but might be exactly what you are looking for.
But I suspect you will want more in the history table than that main store: at least a timestamp otherwise all you have for each row is a bag of versions with no indication of what order they existed in. You could also end up with identical rows if there is a "no operation update" or a change is reverted in the base data. Having entirely identical rows can be problematical - for instance: how do you delete one of them?
As you are using SQL Server there may be a built in option that will do this and more for you, depending on what versions of SQL server you need to support. If you are using Azure SQL or any editions (including Express) of SQL Server 2016 or later, then you can use system versioned temporal tables.