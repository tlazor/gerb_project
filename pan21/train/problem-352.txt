A quick gander through the doc of openframeworks shows a way to switch the current main window. But I'm not sure that is fully what you want.
That your context gets discarded when the user switches to a different app is a feature to free up memory for the different app. 
Introduction to terminology and description state transitions are in the Android Understand the Activity Lifecycle guide. There are basicaly three states:
If the Activity is in the CREATED state, it can enter second state - STARTED, that is reported through onStart and onStop callbacks of Activity class. The app can enter STARTED state multiple times during its lifetime. STARTED means that some part of Activity window is visible to user. Activity is not STARTED when we minimize the Activity or switch to another Activity. This is when EGL context is lost in default configuration and when Activity should be running on low resources without animation and rendering updates.
Now we need a way to tell that opengl context was destroyed so we can reload all the textures and other resources. To do that, we can use callback GLSurfaceView.Renderer.onSurfaceCreated on renderer that is assigned to our GLSurface view. The renderer does not receive any callback when surface is destroyed, only when it is created. But that is not a problem. While the surface exists, the onDrawFrame callback is being repeatedly called. When the app goes to background, the onDrawFrame will not be called anymore. When the app enters foreground, either onSurfaceCreated will be called first, in which case we know that we need to reload everything before next draw or it will not be called and onDrawFrame is again repeatedly called in which case we are good to draw with old opengl resources.
The most straightforward way to do so in any framework would be to add a switch(layer) in update() and draw() that dictates what gets done in each layer. So when the player hits the pause button you do layer = PAUSE; and the next frame will be the pause menu which you can add a nice animation to to make it swipe in.
Third state is RESUMED, which can be entered from CREATED state and is reported through onResume and onPause callbacks of Activity class. This is not that useful, it basicaly means that the Activity has input focus. So for example in multiwindow mode, where two Activities are visible, both of them are CREATED but only the one that received input last is in RESUMED state. For games this basicaly means that when we exit RESUMED state (onPause is called), we should pause the gameplay. When the game enters the RESUMED state, we should do nothing but wait for user to manually unpause the game when he is ready to continue playing.
However pause can also mean pausing the game and seeing the pause menu from witch you can edit options etc. This is the meaning that you want I believe.
To tell Android to try to preserve the opengl context even when minimizing the app, we need to use method GLSurfaceView.setPreserveEGLContextOnPause - call it with parameter 'true' after the GLSurfaceView was instantiated. This will cause that GLSurfaceView.Renderer.onSurfaceCreated will not be usually called after minimizing and restoring the app.
If you want to do that then you don't need to call onPause but instead swap over to a different "game layer" which is a simple menu just like the main menu.
Openframeworks was using GLSurfaceView.surfaceDestroyed callback to determine that opengl context was lost. But according to my testing, this is not how it should be used. That callback is called somewhere around onPause and onStop when app is going to background. And this happens even when the opengl context is not in fact destroyed. So don't use that. Second problem I had was that various callbacks in the code were a bit confused, so the rendering might sometimes get paused by custom bool variable, which caused the black screen in some test cases.
First state is CREATED, which is reported through the onCreate and onDestroy callbacks in Activity class. This state is entered at the beginning of the lifetime and exited at the end of the lifetime. Android app should be able to save its state during onDestroy and restore its state (if available) in onCreate so that Android can quickly and cleanly reload the app when for example screen configuration changes. These quick restarts do not really apply to games, the expected behavior from games is that they restart as rarely as possible.
Historically, there could be only one OpenGL surface existing at a moment, so when apps were switched, only the app in foreground had valid opengl context and apps in background had to restore the state of opengl context (reload textures, etc.) when they came to foreground. Since api level android_11, more that one opengl context can exist (it needs to be requeste by the app), but we still need to be able to handle the case when system decides to kill either the opengl context or the whole app due to system resources constraints. I am not sure if devices with api android_11 and higher may even kill only the opengl context or if they kill the whole app every time they run out of system resources. It might be useful for you to read more about this if you would like to avoid the necessity to reload resources on demand in your project.
Now to the technicalities. When we are making game in Android, we can use either NativeActivity that I am not familiar with, or we can use standard java Activity class and request updates and renders from native code using NDK JNI calls. In that case, we will be usualy using GLSurfaceView. That is basically a UI element that calls our custom callback GLSurfaceView.Renderer.onDrawFrame in which an OpenGL context is available and we can make OpenGL calls and whatever we draw during this callback will be visible in the GLSurfaceView. We need to call GLSurfaceView.onPause when Activity exits STARTED state (Activity.onStop is called) and call to GLSurfaceView.onResume when Activity enters STARTED state (Activity.onStart is called).