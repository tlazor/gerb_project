Pure ordering should be dictated by how you intend to interconnect the ideas. For instance, I use arrays as a motivating example for for loops, so it makes sense to introduce arrays to my students before for statements.  Think about segues, motivating examples, and lab assignments, and a sensible order should emerge on its own.
We teach AP CS assuming that our students come to us with no prior computing background. Being that the language for AP CS A is Java, we plan our sequencing accordingly. We don't follow the approach of starting with Hello, world. and user input because I think it (main, System.out.println, and Scanner) produces too much of a cognitive load at once . I always try to minimize hand waving as much as possible in the early parts of a CS course to help students build their confidence in navigating code. 
Keep the students in mind. Remember where they are coming from and that your goal isn't to turn them into CS researchers or software engineers in a single year. Expose them to the content in an order that appropriately challenges them, while avoiding the statement "You can ignore that for now" as much as possible. 
There is one additional red flag (for me) that you may want to mention to the instructor. Nowhere in your write-up is a discussion of mutability, with all of the cognitive traps that it brings. Mutability is often the secret trap that kids fall into, because x = x + 1 is not a sensible algebraic statement. 
This notion has been discussed already fairly extensively on this site (such as  my write-up here, or this question here.) If you don't call attention to the idea of = as an operation, very different from the declaritive $=$ that kids know from math, they may never dig back out if that hole.
If it is not specifically discussed, beginning programmers will take what they know about equality and apply it in an ad-hoc manner to code. Sometimes they get it right, sometimes they get it wrong, and there may be little consistency, even with the same student from one moment to another. 
At this point it's September and my students can navigate an entire Java class and the hand waving of public static void main(String[] args) is gone. That's hugely important and beneficial. 
For several programming languages (those that were not designed for pedagogy/teaching), starting with a teaching language or environment, and segueing later to the more arcane/abstract coding syntax, might be the easier path, and leave less students out in the cold (or typing magic incantations with near zero understanding).
While Eclipse is commonly used in industry and higher academia, an introductory course isn't industry or higher academia. So we use an IDE that is more appropriate for the new learner. We utilize BlueJ to begin demystifying Java from the very first day of class. Thanks to BlueJ, we don't have to discuss main or making tester/runner classes to run our code. In our post-AP CS course we can introduce IntelliJ or Eclipse, once the students can comfortably grasp the idea of multiple classes and project directories. 
This is because, if mutability is not explicitly taught, folks just kind of drift between all of the contradictory ideas about = that start to float around in their minds, fuzzing from one idea to another, without any fully concrete sense of what it really is.
Our decision to introduce objects early was inspired by Dr. Kolling's book's sequencing and the fact that Java is the language taught in AP CS. Others may chime in by saying they think objects should be introduced late. I disagree for the reasons previously mentioned. Should we leave AP and teach Python or Javascript, I would wait until later in the course to introduce OOP. That being said, here is our general outline:
Questions of what to include, however, are not so simple.  Your major curricular goals now become central considerations.
The curriculum you've shown us looks like a pretty reasonable objects-last approach to beginning Java.  I do agree with you that arrays are pretty fundamental, though, particularly when utilizing an objects-last approach, as they are the only tool prior to objects that allow you to deal with variable amounts of data.