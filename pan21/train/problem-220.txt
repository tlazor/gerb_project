At my company (insurance), we employ the use of a generic 'RESOURCE_LOCK' table that basically allows us to 'document' that a 'resource' (Policy, Claim, Bill, File, etc.) is 'locked or checked-out'.  We have a STATUS column indicating things like WIP (Work-in-Progress) meaning work is actively being done, but not in a single 'database transaction' and WNIP (Work-not-in-Progress) meaning the resource is still locked but a user is not 'actively' working on it.  We also capture the UserId of the 'locking-user' and the Timestamp when the 'lock' was acquired.  Our applications are written in such a way as to interrogate this 'RESOURCE_LOCK' table and inform others the 'status' of the 'resource'.  That allows us to ensure that only one user can be working on the 'resource' as a given time and also informs others ('readers') that data changes are 'in-flight'.
Extended database locking scenarios can play havoc with the ability of the transaction log to 'clear' on a timely basis and certain isolation levels 'can' introduce unintended consequences, like allowing others to read the 'before-data' and not being informed that data changes are 'in-flight'.
You can still encounter lost updates if you not at least at Repeatable read isolation level.  See this article for details about repeatable read.
Naturally, this does nothing to prevent a rogue TSQL statement (outside of the application and with proper authority) from updating the information that is 'locked', but that is a risk we accept.
I have a application development requirement to lock a database record for a user while the user is inside the record. Then unlock it after they are done. Is there a way to do this at the database level instead of the code level? Should this be done at the database level or code level?
If a user can basically bring a tent and sleeping bag to 'camp-out' in this record for numerous seconds, minutes, go home, go on vacation, etc., I would strongly suggest implementing this 'locking' in code.  
Please see this article for details.  Level of concurrency is controlled by isolation level you chose in SQL server or in your connection. Unless specified or changed Read committed is the default isolation level when you install SQL server and do not overwrite in your transaction. 