The idiomatic FP Scala way would be to use an immutable Set and create a new instance every time it's updated.
"A number chain is created by continuously adding the square of the digits in a number to form a new number until it has been seen before... How many starting numbers below ten million will arrive at 89?" The site also gives an example at https://projecteuler.net/problem=92.
For the above reason I now suspect that the chain of method calls used to produce the next variable in the chain function is the main bottleneck, but I am not sure whether this is possible to implement in a faster way. 
I have a solution which arrives at the correct answer but takes ~24 seconds on my computer to complete. I used an array to record as true the index of each value which resolves to 89 through the chain described above. I used an array so that updating and checking values would take constant time. I believed that recording all numbers that resolved to 89 would save time so that the checkAll function could avoid redundant calls of chain for these values. 
But since you're looking for a performance enhancement, reusing a mutable Set will probably be a bit faster.
However, I tested this assumption and wrote a version in which chain would simply recurse until resolving to true or false without recording the chain, so that checkAll would check every single value from 1 until 10 million but perhaps save time from not recording values. Despite the change, this version took almost the exact same amount of time, although at least it's more concise.