I think this question should have been posted on Stack Overflow, but as I am using all of this stuff to make a video game, I decided to post it here.
In C++, pointers are a very important concept.  In this case, they get a bit confusing because they're pointing to an unspecified integer, so let's get the rules about unspecified values out of the way.
As long as you don't access/use firstgid before initializing it, there's no problem at all with that. Check if the function which is receiving a reference to it is not using it.
A good folk just told me that the **this** was nullptr breakpoint error is triggered when we are calling a function on an unknown value or stuff. 
The difference between your first case and this second one is that, in the first case, you had a perfectly valid pointer, it was just pointing to an object with an unspecified value.  In the second case, we're actually calling a member function from a null pointer.  Pointers must be pointing at a valid object if you want to use them to call member functions on the object they point at.  However, this is fine:
The specific error you mention is what happens when you try to call a method on an object that you got by derefereincing a null pointer:
By using it I mean calling a function on the object, using its value (which is not necessarily bad, the only problem is that you don't know what value it holds) or trying to dereference it if it were a pointer.
A key thing to note is that you can always assign a value to a variable that previously had an unspecified value.  If you were to later write firstgid = 1, that would be completely valid and firstgid would have a defined value from that point on (it's value would be 1).
Now for the pointers.  The & operator is known as the "address of" operator.  It takes any variable and returns the address of that variable as a pointer.  In your case, because firstgid is an int, &firstgid will be an int*.  The value of this pointer (the address) is defined, even if the value of the integer it is pointing at is not.  The important thing here is that the pointer is valid, and we can dereference it.  For example:
In this case, all we did was pass a null pointer to someFunction, which is legal, as long as someFunction is ready for it.  For example, it might have some code like:
And I'm not telling the program what value firstgid equals to, like I'm not saying that int firstgid = 5; or something.
So, in this case, you can pass &firstgid to tex(), as long as tex() operates correctly if the pointer is a pointer to an unspecified value.
What that last bit means is that your integer, firstgid, has an unspecified value because you did not assign one.  It might be 0.  It might be 1.  It might be -1195716.  It might even be different each time you run the program.  It is legal to access this value, it's just not specified what its value will be.  If it were a pointer, it would be a pointer to an unspecified memory address, so dereferencing it would be illegal, but firstgid is not a pointer, it's an int.
In this case, objPtr will not change (because the pointer to the object was copied as part of the function call), but clearly someFunction will operate on some other object.
Notice the &firstgid here. I am not telling the program what firstgid is, and still I am making a reference to it using the ampersand