In this pseudo-code selectedParser, selectedDownloader, downloadedItemParser will not be aware of each other nor the order they're called. All they know is that they receive data, do something with it and return something. What the input to these functions and what is done to their output is determined by the flow logic that is above.
Consider using Promises instead. It's still the same continuation-style, but with more structure and decouples your API from the flow logic. All your component functions ever need to know is that it should return a promise that resolves with a value or rejects with an error. It won't be aware of the other functions nor the sequence of the operation.
Your loading logic is aware of the sequence. LoadTheLevel is aware of SaveTheFileString, SaveTheFileString is aware of ParseTheLevelString, ParseTheLevelString is aware of LoadCode and so forth. If ever you need to add another operation in this pipeline, you will have to touch the code of two other operations. While it doesn't sound that bad, it will often times lead to a domino effect of having to reconstruct the entire sequence.
I have made a small game just for my own practicing. While making it I wrote an asset loader, which (as the name says) loads assets. But my main knowledge and effort was on the game, so now I am wondering how I could improve the asset loader.
I understand that file is a url and xhrGet appears to be some sort of AJAX call using GET. But what is save? What is count? When is this .js function called? Where is it called in the code? This style of passing around control makes it hard to trace the flow of the code. You jump from that loop that loops through list, to this function, then you look for what save is, then go back to this function, then look for what count is. While it makes sense technically, it's hard to follow through.
Like above, I highly suggest you keep the flow and logic on the caller side of the operation. Leave the component functions unaware and independent of each other. 