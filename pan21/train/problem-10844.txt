My suggested pattern will condense the alphabetic ranges by writing the case-insensitive pattern modifier i, using \d to signify digits, moving character ranges to the front,  moving the hyphen to the back, and then (to be OCD) I've ordered single characters by their decimal value.
You are handling multibyte strings so additional care must be taken.  If you do not include the u pattern modifier, your multibyte return values will be damaged.  (Demo)
You could implement this without retyping $string to create a oneliner, but if you prefer shorter lines of code, you can break it up over multiple lines or declare variables.
Now we don't have any sample input to work with, but this may be a valuable read.  It might be more stable to perform the replacement on the raw string, but that is for you to determine with your project data.  There are plenty of ways to mince multibyte characters that are not always obvious; I recommend testing against a large battery of cases.
As a final consideration, you may want to perform the whitespace reduction after the whitelist replacements so that you can handle newly consecutive whitespace characters.  A final trim() might be advisable too.  Add some realistic test strings to this demo and see what processes ultimately provide the cleanest output.
The position of your hyphen between two non-ranged entities in your negated character class tells the regex engine that you which to declare a range of characters.  I interpret this to be a mistake.  Rather than escaping the hyphen, I always recommend positioning the hyphen as the final character in the character class.
As for the pattern to remove whitelisted characters, you have some overlapping logic which I believe is due to an ill-positioned hyphen.
Rather than making two separate passes, you can safely merge the logic into one pattern.  To provide a more comprehensive "mop up" of newline characters, I'll recommend \R.