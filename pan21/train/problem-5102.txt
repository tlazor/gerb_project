If they're not shared contexts then rendering will be somewhat quicker, but you'll need to separately load any required model data into the second context, and you'll need to pull the final rendered image back to the CPU and then explicitly load it into the first context as a texture, so that it can be used from there.
My understanding is that the goal is to have a background "high quality render" while still updating an on-screen progress bar and eventually producing a still image from the background process.
Slow part takes too long? Break it into multiple draws. Each draw is still too long? Fill a smaller area.
If your rendering is slow it's not because of slow OpenGL calls. Your architecture is just bad. You can improve it by moving away all your logic (UI events, physics, AI,...) from your rendering thread. That way, there will be more frequent updates and your UI will not lock up. Also the overall experience wil be a lot smoother. There are many models for multithreading.
An OpenGL context may be current on at most one thread at a time. If you make a context current in one thread, it will be made uncurrent in the previous thread. So while you can migrate contexts between threads, you can not do so in any concurrent manner.
The second context handles your lengthy rendering process from a background thread, and renders into an FBO.
Either way, you're left with a texture of the rendered scene that you can use from within the first rendering context;  the one that's rendering to the main screen.
While there is the existence of shared contexts and shared resources, those are not exactly in the fast path and you'd need to do some work to get them set up, if at all available.
These may or may not be shared contexts.  If they're shared contexts, they can share model data (ie: the second context can render using VBOs, textures, etc. created in the first context, which may be useful depending on your application), but this will make rendering slower in both contexts, primarily due to driver-imposed memory fences around that shared data.  On the other hand, you'll be able to convert the rendered image directly into a texture that will be accessible to the first context, without pulling the data back to the CPU.
The first one renders your progress bar (or whatever else is needed) to the main screen, from your UI thread, as normal.
Maybe also take a look at my answer about multithreading: Multithreading in Gamedevelopment, specifically Networking
The easiest way to do this will probably involve having two separate OpenGL contexts, each set as 'current' on one thread.
If not using shared contexts, then use glReadPixels() to get the rendered pixels back out of the second context, and then use those pixels to create a texture inside the first context.
To get the final rendered image to the screen using shared contexts, you just need to either convert the FBO contents into a glTexture;  that glTexture will be available from the first context (once synch has completed between the two contexts).  
As @LarsViklund pointed out, you will have significant trouble using multiple threads to render. OpenGl is kinda bad at multithreading, so don't.