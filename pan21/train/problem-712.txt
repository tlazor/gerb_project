I have previously advised you to avoid using floating-point operations when dealing with integer arithmetic.  If your goal is to handle int overflow, then use long.
The value for range, 2147483647, is a magic number, better written as Integer.MAX_VALUE.  However, even if (A > 0) && (A <= range) is true, the reversed result might not fit in an int, in which case Integer.parseInt(…) would throw a NumberFormatException.
Note that the overflow detection is also much simpler.  There are no special cases — we simply check whether downcasting from long to int can be safely done.  Also note that (a % 10) produces a negative result when a is negative, so that no special handling is needed for negative numbers either.
My suggestion would be to rework your code and request another review, since correcting some of the issues mentioned above could possibly require radical alterations to the code (it is perfectly acceptable to post a new question with a reworked version of a code from another question, but if you do, you should mutually link the questions).
If I were presented with that solution as an answer to an interview question, I would definitely question your judgement and taste, even if the solution worked correctly — which it doesn't.
In any case, using StringBuilder.reverse() is, in my opinion, a bad idea.  CPUs are very efficient at arithmetic, but less adept at handling strings.  Both String.valueOf(int) and Integer.parseInt(String) do a lot of work behind the scenes.  Though the inefficiency is quite tolerable for all practical purposes, I would consider the solution to have missed the mark, if judged as an interview solution.
I'd be happier with a purely arithmetic solution like this, which should be far more efficient, and that demonstrates your ability to write a loop: