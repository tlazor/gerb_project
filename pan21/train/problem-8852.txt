See Is using a vector of boolean values slower than a dynamic bitset? for some benchmarks on this, specifically in the context of a Sieve.  Note that C++'s vector<bool> is a bitmap, but you can implement one yourself in C with shifts.  (Making it portable requires using CHAR_BIT if you don't want to assume 8-bit char).
typedef unsigned char bool; is technically legal in C, but very bad style.  If you want a proper bool in C that works like it does in C++ (guaranteed to only be 0 or 1), #include <stdbool.h>.
This is a very low-readability way to write isdigit(inp[i]).  But maybe the library isdigit is slow and you don't want it to check if a locale is set or any nonsense.  Hard-coding ASCII constants is still usually not the right way to go.  Use character literals like this to make it more readable:
Note that you can store your bitmap as 0 means prime or 1 means prime, so you can choose whichever is more efficient: generating a value with all-but-one bit set, or a value with only one bit set.
for (int i = 2; i <= max_sqrt; i++) is a good start (only going up to sqrt(max)), but you can skip the even numbers.  If you start with i=3 and do i+=2, you avoid wasting time testing list[i] for even numbers.  (set them to false in a startup loop instead of memset(true)).
To optimize the bit-setting for Sieve, you can make a bit-mask to AND or OR and rotate it instead of re-creating it for each word of the bitmap.
If you want a 0 / non-zero integer type that avoids the possible inefficiencies of bool (Boolean values as 8 bit in compilers. Are operations on them inefficient?), call it something else.  bool is a keyword in C++.
More complicated indexing is possible to bake in other small primes like 3 and 5.  Much has been written about prime sieving, it's always possible to make an implementation more complicated to gain some performance.
It's not usually useful to write your own string->int functions in the first place.  But there are other times where you want to work with characters.
One major thing for large data sets is using a bitmap (8 true/false elements per byte) instead of only one per unsigned char.  This requires a read-modify-write to only clear one bit, so it only pays for itself with a large enough max that you start to get cache misses with the per-byte version.
You can compact your list by not even storing the even numbers in it.  So list[i] represents the primality of 2*i + 1.  This cuts your cache footprint in half.  It does make the logic more tricky, though.  Let's take 3 as an example.  list[i=1] corresponds to the primality of 3, so we need to mark 9 as composite (stored in list[4]).  But 12 is even, so it's not in our list.  15 is stored in list[7], and so on.  So we still do j += 3, but it really means we're skipping the even multiples.  Squaring is also tricky.
As a bonus, now your code is portable to EBCDIC or other non-ASCII C implementations.  (Hard-coding 48 and 57 would be useful if you explicitly want to work with ASCII, regardless of the native character set of the C implementation.)  BTW, the C standard does guarantee that the integer values of '0' through '9' are contiguous and in the expected order, so '0' + single_digit_number works.
If you're curious about performance, profile your code.  e.g. on Linux, perf stat -d ./soe to show CPU hardware performance counters for cache misses.  Make sure you compiled with gcc -O3 -march=native, or with optimizations enabled for whatever other compiler you use.