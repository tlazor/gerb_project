I would create an ADO.NET .dbml model, where I'd reference all the stored procedures that need to be called by the application. I don't know if that could be called a "repository", but I'd implement it something like this:
Entity Framework also has support for stored procedures, and your Request class would make a perfectly suitable complex type (only missing a [ComplexType] attribute), and if the returned column names exactly match the property names, the mapping is automagic, but you have more control over how things are called than with ADO.NET.
You also use this a lot inside that same class,  make it a class scoped variable, move it outside of all those Methods.
A quick Google search for "SqlDatabase class" yields an outdated MSDN page about an obscure class in an obscure Microsoft.Practices.EnterpriseLibrary.Data.Sql namespace:
What I mean with this last point is that despite IRepository<T>, the wrapper class could easily be used outside of the "repository" class, which would result in this:
Both of these return a variable that you define within the block itself, so you should just return what you need instead of creating a variable
One obvious advantage of using either an ADO.NET .dbml, or Entity Framework over what you have now, is that you just pass the parameter values as you would when you call any other method: the stored procedures become methods of the data context!
I'd get rid of the static class and move that code into the repository implementations. Then I'd look into using EF or a Linq-to-SQL .dbml to replace the apparently outdated (never used it) Microsoft.Practices.EnterpriseLibrary.Data.Sql.
In your .dbml you drag-and-drop the stored procedures from the server explorer into the designer, and then you give it a name that's code-friendly, like SelectRequests (the source can still be called ResponseTracking_Get_Requests, but that's less code-friendly), and you tell it that its return type is a Request object (which you can also create in the .dbml designer), or leave it an (auto-generated type) and work with an auto-generated ResponseTracking_Get_RequestsResult type instead.
...unless DataAccessWrapper is an internal class in a data-dedicated assembly, I think it would be better to implement that code inside your "repositories" - otherwise these repos are nothing but non-static wrappers over a static wrapper... which doesn't need to be static in the first place.