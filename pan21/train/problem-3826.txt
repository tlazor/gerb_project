Signing is a good way to get around this - it might be good to look at JSON Web Tokens for ideas, though this is really intended for verifying the authenticity of session data etc... and the payload is still in the clear.
What of course remains as a privacy risk is, that the GPS data is open to everybody who listens in - this might or might not be acceptable to you.  
You could look at salting the hashed data with a timestamp, which would at least create a new hash for each report, but this increases the workload on the server to authenticate a hash (you need to try each user, perhaps with a range of timestamps).
Remember also that SSL is not the only way to encrypt the payload. You could encrypt using some other asymmetric encryption (do not use symmetric encryption)... with asymmetric encryption anyone can encrypt data for a specific target (using the public key), but only the target can decrypt it (using the private key). Look at GPG for a popular starting point - this will also add some overhead, but it would not really be acceptable to transmit such data in the clear.
There is a way around this: On the client concatenate the payload data and the current timestamp, then use the hash to sign this. Send the timestamp (in clear) with the request and have the server reject obviously wrong timestamps.
SSL does indeed add an overhead when establishing the connection, but have you actually quantified it? Are you sure that this is an issue? Also, in terms of increased complexity in an App, there isn't much. As you're reporting location once per minute, could you not look at keeping an SSL session active between reports, eliminating the overhead in establishing the connection?
Additionally, the payload is "in the clear", which is probably not at all suitable for a user's location data...
Your design indeed has a privacy flaw: Once an attacker has figured out the hash value for a user, he can then impersonate the user, i.e. send wrong location data to the server.