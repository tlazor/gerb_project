Repeat with Q2. We read t1 and return A. We read t2 but now the ON says t2's value must by both A and also NULL. No row matches. It's an outer join so we return (A, NULL). We read the next row from t1 getting B. We look in t2 for "B and NULL" and do not get a match. We return (B, NULL). There is no where clause so we're done. Query 2 returns
Different results depending on whether the predicate is in the ON clause or the WHERE clause, but only with outer joins.
Your particular example uses and inner join. The results will always be the same whether you use ON or WHERE. 
I think of the ON clause as applying the predicate to the row from the right-hand table before it is combined with the left-hand row. The WHERE applies after the combination is formed. This is just how I think inside my head. The query optimizer does not work this way. I'll use an outer join to demonstrate what I'm saying.
I need to filter a specific date for both tables. For instance I need data only for '10/28/2019' from each table.I want to know whether there are differences between these two queries in terms of the final result and query performance. In the First query I'm filtering dates in ON clause and in the second query I'm filtering dates in the where clause.
Let's step through Q1. First A is read from t1. Then the ON clause says "find matching rows from t2". This returns A from t2 and we have an output row (A, A). Then we read B from t1. Again the ON says "find matching rows from t2". This time there is no match. Since it's an outer join we return (B, NULL). Now we've read all the rows and we apply the WHERE clause. Only one output row has t2 as NULL so query 1 returns