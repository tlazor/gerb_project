You can build a Popularity based recommendation system in this scenario. This type of algorithm works with trend, it basically uses the items which are in trend right now.
There are faster approximate ways to do it, like a simple locality-sensitive hash (LSH) of the vectors into buckets, from which you can reduce the search for similar users to the users in the same bucket as the target user.
This is a classic recommender problem. Given users' interactions with items, predict what other interactions are likely but unobserved. The usual algorithm for this is alternating least squares. See https://datasciencemadesimpler.wordpress.com/tag/alternating-least-squares/ for example. The details don't matter much; it's implemented in many packages like Spark (https://spark.apache.org/docs/2.4.0/ml-collaborative-filtering.html).
You get recommendations (new items for users) out of it, and if that's what you want you're done. But, you also get from this model a set of user and item vectors, which can be viewed as embeddings of users and items into a latent factor space.
All this means is that it's valid to define 'similar' users and items as those that have a large cosine similarity. The simplistic way to find similar users is just the brute force one: for a given user, find cosine similarity with all users and take the top ones.