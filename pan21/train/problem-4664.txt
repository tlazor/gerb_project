Similarly, taking advantage of the properties of the obtuse coordinate system, the range between two hexes is readily obtained with this method, allowing adjacency to be tested as the case when Range = 1:
Using an integer matrix implementation IntMatrix2D the conversion between the rectangular and obtuse coordinate systems is down thus:
Yes, all the above is C# code, but translating to Objective-C should not be an undue hardship. My orientation convention for hexes is the transpose of yours, but this is easily addressed either with a transpose matrix, or swapping North with East and West with South.
In my HexGridUtilities project (Open Source, MIT Licence) I found it both useful and performant to define the coordinates of a hex as a vector of four integers - the rectangular coordinates and the obtuse (120 degrees between basis vectors) coordinates. Although I initially used Lazy calculations, it turned out to be more performant to always track both.
However if you only need adjacency, there's a simpler way. Because every other row is offset, the logic is going to be different for odd and even rows. Look around 2,3 (odd y) and you'll see the x==2 column bends to the right like ">". If you look at 2,2 (even y), the x==2 column bends to the left like "<". So we'll need the code to treat odd and even rows separately. The x logic isn't symmetric for positive and negative so I won't take the absolute value:
Note that the Norm of the conversion matrices is 2 rather than 1, allowing the arithmetic to be quite elegant:
The logic of the code here treats the adjacent hexes as either "・>>" or "<<・" (there are two bent columns and one extra hex), and the "<" or ">" part is the first (....) condition and the "・" part is the second (...) condition. (I'm not sure this explanation helps)
The code to generate the adjacency list for a hex is the following extract from the library's HexCoords struct: