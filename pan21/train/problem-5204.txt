The advantage of a goto chain is that you don't have to repeate the cleanups at each possible failure.  It can make a big difference when you have lots of initializations.
To gain a broader insight in things many (high-level language) programmers nowadays take for granted, I decided to study some of the more basic ways of storing data in memory. I wrote a program which stores dynamic sized (integer) arrays in a chained hash table. A possible application could be the indexing of lines on which words appear in a given text file to be parsed (I could then 'ask' the program on which lines, f.e. the word 'banana' appears in the parsed text). I designed the program so that I can pass different hash functions and compare their performance later on.
It would be a different story if your hashtable supported different multiple types.  Then you would need to pass in a hash function.
Anyway, my code is working perfectly as I want it to. However, I feel like it's necessary to get fundamental data structures such as hash tables and dynamic sized arrays right, so that's why I am posting my code here.
This is a noble goal -- you will learn (and perhaps already have learned) a lot about higher level languages by diving a layer deeper.
Even simpler!  But you'd want to comment about linear probing. This would be a big win because you wouldn't need to reimplement so much stuff.
Another tip -- in C, return is often the cause of bugs.  This is especially true for ex-C++/similar programmers who expect cleanup to be automatic.  A nice feature of the goto chain is it minimizes the number of return statements to think about.