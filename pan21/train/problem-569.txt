However, my guess is that you used features which the person reviewing your code was not familiar with.  Quite often the person who determines if you are hired is not an active developer, but a development manager who used to be an active developer.
countMap is awesome. Do more of that. In fact, countMap is the report. Move NUMBER next to it, and make it your return value. Do the printing elsewhere.
Quite often things happen that have nothing to do with your performance, and feedback is not provided that it was nothing to do with you.  Or, it is something to do with you, and they lie and say it wasn't.
I think you should strive for KISS. You wrote 96 lines where I think far fewer would have sufficed, and failed to write a good string fizzbuzz(int). You signaled that you are more interested in writing lots of lines with fancy features than writing clean, minimalist code.
They are less likely to keep up to speed with the latest features of the language.  Showing you are using them to solve a problem will make your code look worse to this ex-developer; they will probably feel ego-challenged (I don't understand this, I am smart, thus this is bad code) by not understanding what your code does or how it solves a problem.
For this task, they just wanted to see if you can write a for loop and either use the modulus operator or keep track of 2 counters and reset them.
In this case they are right; the code demonstrated is showing off your knowledge of Java features (which could be quite useful in more complex problems) which are not appropriate for this simple task.  The parts that are not showing off are not well done; copy-pasta, hard coded constants, brittle tests, undiciplined library use, etc.  (Other answers cover this better than I)  Finally, apparently your code fails to compile in some "modern" compilers; that could have eliminated you before they even looked at your code!
Maybe some companies or some interviewers would have been impressed by your use of more advanced features of the language. Apparently not this one.
Speaking of tests, you wrote some but they are incredibly brittle. If I wanted you to iterate from 1 to 21, all your tests would break. This should have been a clue that the interface to the core logic should have been refactored, but instead you happily wrote a bunch of brittle conditions which don't provide a whole lot of confidence that the code is working well.
You showed that you were aware of fancy types like IntStream, but when doing something fundamental like counting the number of fizzs, you chose to test against a string actual.contains("fizz: 4").
Final thought: You could write the best code in the world and a business might not provide any feedback or contact you again--for any number or reasons. Don't sweat it too much.
For the special lucky case, it's not clear if they wanted you to still print fizz as well. Maybe they wanted to see if you'd ask for clarification.
In the future, the thing to keep in mind with FizzBuzz style tests is that they are looking to check if you can program at all.  They aren't asking you to show off.  The goal of the test is "can you write a simple solution to a simple problem", and to filter out people who cannot program at all.  Make your code simple, non-challenging.  Try to follow "best practices" in the most conservative way.
Your solution probably looks too different from how they would have coded it themselves, and so it looks like complete overkill for what they're asking for. 
You've got 2.5 of 3. There's no function/method that takes an integer and returns something printable for that input; that's the heart of fizzbuzz. I understand you buried your transform in a lambda and mapped over it, but it's only accessible through a parameterless interface which can't be independently accessed or tested. Then you copy/pasted it into report instead of factoring it out--a big red flag.
So if someone doesn't understand those features, the code looks like noise and is ego-bruising.  If someone does, they'll say "ok", then look at the rest.
Basically you've just told them that you will take a simple problem and find a complicated, hard-to-read, hard-to-debug, and hard-to-maintain solution to it. If your reaction is "but it's not that complicated, I'm just mapping stuff and a regex", then that is the problem: you don't need to map for this problem. 
More likely, they where looking for someone with the minimium competence that would solve their problem: if they are hiring someone to write Java to move controls around in a UI, they don't want someone who likes playing with Java8.  Or they found a candiate already.  Or they changed their mind about hiring because they got distracted.  Or you where judged acceptable at Java, but you didn't list SQL on your resume, and there was another candidate who did and was also marked as acceptable in Java, and the HR noticed that SQL was required and elminated your resume from the pool.  Or the application process was a fake, and they where just gathering FizzBuzz implementations to feed to a FizzBuzz plagarism detector.  Or they where gathering FizzBuzz implementations that could avoid Fizzbuzz plagarism detectors to game some other application process.  Or they are someone who gathers resumes and code in order to have a stable of people, then they find contracts and try to become middlemen; if they don't get the contracts, they discard the applicants and repeat.
I don't care about extracting magic numbers or whatever; that's easy to do later, and arguably they shouldn't be moved anyway because they are uniquely tied to that particular transformation logic. It's also dirt simple to change import statements, so I wouldn't hold that against you too much either.
Parallelism was an incredibly distracting flourish; completely unnecessary for the task and a bit worrying. If I were a potential employer, I'd wonder what other unnecessary junk you were going to insert into my codebase.