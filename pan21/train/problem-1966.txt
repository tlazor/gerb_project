One simple way to do this is by compiling a simple program that will write to this file, and stay open until it is killed. An example of such a program is below, and can be compiled by cutting and pasting the code into a file called setcpulatency.c, and running “make setcpulatency”. So, to minimize latency during certain hours, say from 8AM until 5PM, a cron job could be set up to run at 8AM. This cron job could run setcpulatency in the background with an argument of 0, with a cron table entry like this:
To dynamically control C-states, open the file /dev/cpu_dma_latency and write the maximum allowable latency to it. This will prevent C-states with transition latencies higher than the specified value from being used, as long as the file /dev/cpu_dma_latency is kept open. Writing a maximum allowable latency of 0 will keep the processors in C0 (like using kernel parameter “idle=poll”), and writing a low value (usually 5 or lower) should force the processors to C1 when idle. The exact value needed to restrict processors to the C1 state depends on various factors such as which idle driver you are using, which CPUs you are using, and possibly the ACPI tables in your system. Higher values could also be written to restrict the use of C-states with latency greater than the value written. The value used should correspond to the latency values in /sys/devices/system/cpu/cpuX/cpuidle/stateY/latency (where X is the CPU number and Y is the idle state)—CPU idle states that have a greater latency than written to /dev/cpu_dma_latency should not be used.
Of course, this is just an example to show how C-states can be dynamically controlled... the crond service is often disabled in low latency environments, but these steps could be taken manually or run by other means.
The methods to limit C-states above will all be permanent (until the system is rebooted). If you would
like to have a system have extremely low latency during certain hours, but want more power savings at