Choosing between options 2 and 3 depends on the circumstances, and may depend quite a bit on your personal preferences.  Some people would avoid option 2 because they believe all nulls are evil.  Other people would avoid option 3 because they don't like having too many different tables.  This is a "holy war" debate without a definitive, logical answer.
Having the same types of columns is not the same thing as being the same entity type.  Normalization is not the same thing as code reuse.
Normalization is about arranging your columns into tables in such a way that you avoid insert, update and delete anomalies.  It is about reducing the kinds of redundancy that can lead to these anomalies, it isn't about putting things together because they look alike.
From this perspective, your first option is not good, because you are jamming three different kinds of child data into one table.  You can't control referential integrity as cleanly or easily this way.  The only two conventional, practical options you have are 2 and 3.
As a first choice, you should let your database engine use its declarative constraints (foreign keys, unique keys, etc.) to protect the integrity of your data.  This saves writing application code to do this and makes your system less buggy in the long run.
As an aside: You don't show the details of the child table(s).  If these three child tables have an identical structure and you're worried about having application code that is duplicated, consider creating a class that handles the child table structure and inheriting from this class for each of the three child tables.  This will give you code reuse without compromising data integrity.
This means that you should aim for at least third normal form (3NF) by default and then consider later whether any denormalization is necessary.
For practical purposes, looking at your three main tables, I would say that they don't look like they have very much in common.  There is a little overlap, but not very much.  Therefore, I would tend towards option 3.  Keep your tables separate so that your code and your data stay clean.