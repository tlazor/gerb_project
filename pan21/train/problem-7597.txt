Marking all prime numbers on one pass, and then looping through your marked array printing out prime numbers is looping twice for possibly no reason.  You can simply print out the prime numbers as you find them, if it is inside the required range.  It would require some juggling, and optimization tricks to ensure you print out a number only when required, and only exactly once.
When generating prime numbers with the sieve of Eratosthenes, you can treat 2 as a special case.  All other prime numbers are odd, so you can increment by 2:
You generate the sieve 10 times, if you have 10 test cases.  Maybe you could examine all 10 test cases, find the largest end point, and generate the sieve once???
When you find a prime number \$p\$, you have already eliminated all multiples of prime numbers below \$p\$.  This means starting at \$2p\$ and going up is eliminating already eliminated multiples.  You can start at \$p^2\$, and since you are only concerned with odd numbers, go up multiples of \$2p\$
When looping over the array for printing, you could again skip all even numbers, by going up by 2.  But make sure you start on an odd number!
If you reversed your sense of the flag array, so true means "not prime", you wouldn't have to loop through the array to set all elements to true at the start.  They would start off as false, which would mean "prime".