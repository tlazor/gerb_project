This isn't necessarily more efficient, although it could be (depending on how Java optimizes it).  The primary advantage of this version is that it leaves maintenance to the Java engine.  
You can write persistence code manually, without annotations.  But I would generally still use a database if you intend the code to scale at all.  You don't want to read all the records every time you want one record.  Rather than reinventing that wheel, just use the existing solution:  a database.  
There is no point to declaring and initializing friends and interests if we're not going to use them.  So do those tasks after the check, not prior.  
Switching to an early exit changes from >= to < and allows us to reduce the level of indent.  It works here because the entire code for an iteration after that point is inside the if.  
When split is of length 2, only 0 and 1 are valid indexes.  So split[2] would be out of bounds.  Making it a 3 instead of a 2 would fix that.  
This method has no added value whatsoever. All it does is calling another method with same method signature (with the first arg shifted as invokee). This could have been a good choice if either (1) you needed some validation (2) argument/result type parsing was involved (3) calling this method would have been a lot less code to type. But none of these are true. Try avoiding an anti-pattern like this.
Hibernate (and Java Persistence Annotations in general) is for exactly this task.  It maps classes to storage and vice versa.  Now, that might be a heavyweight solution, but it is one that exactly addresses the problem.  