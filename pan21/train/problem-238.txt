In your code, you're changing the key and re-initializing the block cipher for each random number.  It will, generally, be much more efficient to initialize the cipher only once, with a fixed key, and increment / decrement the encrypted data block instead.
Because the routine used is usually employed for encryption, it operates on two parameters: the plain text and the key/password. 
Your program then takes the first 32 bits of the block of crypto text (BitConverter.ToInt32(RandValue, 0)) as the random value. This value should depend (pseudo-)randomly on the key, so that key+1 will yield a completely different value than key with high probability; this way, there's no simple correlation between subsequent values of the RNG, which makes the output look like real random data.
Because the Rijndael algorithm chosen here is a block cipher, it will always output a whole block of crypto text, even if, as in this case, the input plain text has zero length: Encrypt(new byte[0], KeyBytes);.
This PRNG uses an arbitrary encryption algorithm to generate pseudo-random numbers. The trick is just that the encryption algo will return the same crypto text whenever the same plain text is encrypted with the same key.
Another approach I once tried was using a simpler stream cipher (RC4) whose calculations can actually be completely reversed so that one may go back and forth through the sequence of output numbers as desired by either using the (normal) forward or the reverse operations.
This is, in fact, a standard method for creating a seekable pseudorandom bitstream using a block cipher like AES / Rijndael.  It's known as counter (CTR) mode, and is commonly used to implement a stream cipher (which needs a keyed pseudorandom bitstream) based on a block cipher.
In your case, there's no need to encrypt a particular plain text, but since the encryption function needs it as input, some arbitrary, but constant, "plain text" is given to it via the "ClearData" array.
In fact, it's likely that your crypto library already implements CTR mode, but the API it exposes for it may or may not suit your needs.  If not, it's perfectly fine to implement it yourself by using ECB mode (which basically gives you direct access to the raw block cipher) and incrementing the data blocks yourself.