In your case, I'd keep a TileDatabase that just mapped simple integer IDs to TileType values.  It can even just be a simple std::vector wrapper that returns a reference to the error tile for out-of-bound indices (e.g. invalid tile IDs).
You haven't shown code with them ever being initialized.  Even if they are, you're likely suffering from the "static initialization fiasco" outlaid here: http://www.parashift.com/c++-faq/static-init-order.html
As some unsolicited advice, the entire structure of the code is just... awkward.  If you find yourself wanting to use the "mutable" keyword, you should pretty much rethink everything you're doing.  In almost 20 years of programming C++, I've never once had a legitimate use for that keyword; anything it can solve you can solve by a better abstraction (which may well mean less abstraction).
Very specifically, Tile::ERROR_TILE is being initialized by storing a copy of Tile::ERROR's value, but this is total garbage (because Tile::ERROR hasn't yet been initialized).  Namely:
In general, I'd shy away from all this static data.  But for now, I'll note there's a workaround: http://www.parashift.com/c++-faq/static-init-order-on-first-use.html
If this is not the problem, I recommend comparing the address given to you in the access violation or segfault with any and all of the pointers involved in the line of code that's crashing, including the implicit "this" pointer used to access member variables.  While it likely won't match exactly due to member variable offsets and the like, this will likely point you to the exact pointer that's causing the crash when dereferenced.
You've got a ton of different objects/types defined, which is a usual sign of newer coders who've just learned about object-oriented programming but haven't learned the do's and dont's yet.
Remember: just because you have some conceptual "object" doesn't mean that it deserves its own C++ class.  C++ classes and interfaces should focus on how things work in the algorithm and do not focus on how a human would categorize conceptual entities.  In other words, don't make overly "concrete" classes, but rather focus on algorithmic abstractions.  It takes a lot of practice and experience to really start understanding what that really means.  A classical treatise of the subject is the Coffee Maker example, with a good explanation available at http://web.archive.org/web/20081227131937/http://www.objectmentor.com/resources/articles/CoffeeMaker.pdf