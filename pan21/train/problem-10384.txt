Any solution that uses premade segments will require you to make sure that all the meshes have the same shape and diameter around the center of the tunnel, but you can get around this somewhat by having the segments overlap to an extent, and have each segment flare out at the ends.  If done right, it shouldn't be too obvious to the player that there's a seam.
One further note: if your cave really is infinite, you may need to "recenter" it periodically as the player moves further and further from the origin. Because floating point numbers lose precision at high magnitudes, physics and rendering artifacts can creep in at extreme distances. If you do this, you'll want your worldspace noise to be periodic over a large scale, with the period exactly matched to your recentering offset, so you don't encounter seams after recentering.
These starting tiles could be shapes you've modelled, or procedurally-generated macaroni tubes of cylintrical geometry (this form is a variant on bcrist's and Steven Stadnicki's suggestions). Using models you've created makes it easier to handle arbitrary topology like branching paths, or points of interest like open caverns. This is still possible with pure procedural (see Gyroninja's suggestion about metaball techniques), but challenging.
There is rarely a "right way" or "wrong way" when it comes to game design.  There are many, many ways to solve this problem, but here are a few possible approaches to explore:
You can use a lower-res mesh with only the low-frequency noise components applied to create the collision representation. As bcrist notes, you'll need to control the maximum amplitude of the noise relative to the radius and sharpness of turns of the tunnel, to ensure it never pinches off completely.
But we have no idea how to make sure that the mouth of one tunnel piece always aligns perfectly (in both position and rotation) with the end of the previous one. Can anyone offer any advice on how to accomplish this? 
On the other hand, if you go for entirely procedurally-generated geometry, you'll have more work to ensure that you don't generate sections that are impossible to traverse, and you might run into issues with collision detection.
The hope is that a technique like this gives you the ease of planning and level design control of a tiled map, without visible repetition or mechanical-looking structure in the playable result.
Once a tile is placed into the world, displace its vertices using noise functions applied in worldspace. This preserves connectivity and seamlessness between tiles (since coincident vertices have the same worldspace input, and get the same displacement output), but makes every tile look unique and organic:
The idea is to start with tiles that are generic, downright boring, with simple predictable edges so they're easy to line up without seams or gaps:
Here's a technique I experimented with recently. My RenderMonkey prototype shows a section of badlands-style canyon, but the same principle should work in caves.
Texture and normals are applied in worldspace too - here using triplanar mapping - so that adjacent tiles are completely seamless, without tricky UV unwrapping constraints.
Are we even going about it in the right way, or is there a better way to procedurally generate the cave? Bonus points: It'd be awesome if the cave could change in diameter and/or shape as well, though that'd just be gravy. 
A friend and I are hoping to make a game in Unity in which you fly through an infinite 3D cave that can twist and wind in any direction (though obviously not to the point that the turns are impossible to make). We were thinking about creating a number of tunnel "pieces" that each curve a certain amount, and spawning each at the end of the one that came before.
Keep in mind, with any "infinite" game, you should be aware of the limitations of floating point representations.  If the player gets too far from the world origin, it becomes easy to lose precision in floating point calculations (when two large values are subtracted from each other, for instance).  To avoid this, you can make the world move around the player, rather than the player move through the world, but its usually easier to just check the player's position every so often, and if they're too far from the origin, rebuild the world with the player at or near the origin.