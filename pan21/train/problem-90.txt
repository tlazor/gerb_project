For each tile, create a vertex buffer that will hold N by N quads and initialize their positions so that they make the whole grid. To make an element appear, you just have to set the texture UV coords of the quad to the element image in texture atlas. You never change quad positions.
You can reuse the vertex buffer and just update it's content after each change. Now rendering this vertex buffer will draw all the elements in N by N tile onto the framebuffer. There's even no need to cache it in a texture, 
So, let's see how we can draw a whole tile of N by N elements in a single drawcall. First, let's make sure that you have all possible element images on a single texture atlas â€“ this will enable us to draw any element without changing textures.
And when it comes to (c): this should not be needed, but let's assume that your elements are mostly static and you would like to only ever draw what's changed. If you render your graphics to a texture, you can later draw to this texture without clearing it, thus updating only the changed parts. However this (not clearing before rendering) could potentially hurt performance on some older mobile platforms. Also, still remember to draw all the updated elements in one single drawcall as shown above.
There are several ways to approach this problem. When it comes to WebGL performance the key is to: (a) reduce number of drawcalls, (b) reduce gpu overdraw (fill-rate) and vertices. (c) reduce buffer data transfers. Because you're filling the screen at most once and scene complexity is low, we can totally ignore (b). (c) is a bit more complex and I'll get back to it later.