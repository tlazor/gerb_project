GPU can produce mipmaps (opengl, directx I'd imagine too), though such a map is prolly too large to do it in one shot on the GPU (too large for a texture), but if you are doing quadtrees you should be able to figure out how to break it down to feed it to the GPU piecemeal. The lowest level of a mipmap would look like that section from far away. Precompute the entire mipmap if you can.
After this algorithm is done, I can render each point either at its location (if it's a leaf), or at the node's center of mass (if it's intermediate node). It works very fast, and gives decent results. 
Fade between the two levels of the mipmap that are at the scale you want to draw on the screen (this is called trilinear interpolation).
It almost feels like I should start from leaves, combine individual points into single cluster, until I get N clusters, but this would kill performance.
Another thing to try would be to use opencv (or another lib) to directly do the rescaling; see if you can produce a mipmap this way, it might produce good results.
Experiment and see what works best. One thing you could try: the brightest stars are always visible; emulate that effect by having a priority queue of stars by brightness, always rendering the brightest N, and the rest in simplified form.
I want to render this map at different level of details. From a single star to entire star system, galaxy or even universe. I also want it to be fast.
It should look decent, but if it doesn't look good, you'll want to do the same thing yourself; use a vision library like opencv (prolly to precompute them) and basically you do {1. blur, 2. subsample at half resolution} over and over until you have a 1x1 mipmap level. And you have produced the mipmap yourself. The choice of "blur" and associated parameter choices for each blur will affect how it looks at the end. Some examples are "gaussian filter" or "bilateral filter". There are lots of others.
One obvious error in your current implementation is that you should combine nodes based on their total area, and not total radius. Otherwise you're overstating the visual effect by a squared factor - remember the area formula, pi*r^2. But you'll still run into other artifacts.
So I started with a quad tree approach: loaded every point into the tree. At any moment of time I can query a tree with a simple question: Give me top N points in this region
An obvious one is that when you are zooming or refining your detail, there will be popping artifacts as one level of detail is abruptly replaced with the next. Most LOD algorithms deal with this by fading between levels of detail - i.e. when you are at the threshold between levels, alpha blend between the two instead of having a hard threshold.
I have a large list of points (millions) in 2d. Let's say it's a star map. Each star has a radius and position in space.
Just to note, if you don't want to do the entire thing precomputed, you can take a section that you want to draw and only do that section. Keep in mind you might need to add some border to this section to take into account things that would normally be blurred in.
But what is a top? I thought to myself that quads can be compared based on total radius of points that they host. So, this gives me sorting order to work with, and the algorithm boils down to a mix of quad tree and a priority queue:
If I render each intermediate quad tree node at node's center of mass, then I get these artifacts, where two nodes are collapsed into one:
A mipmap is a "pyramid" of images, each at a different scale. At the "top" of the (upside down) pyramid is the original image. The next level is the same image at half-scale. And so on.
In my experience level of detail for point clouds where you replace small points with big points only works for continuous surfaces (and even then you get artifacts from the loss of surface texture, which is somewhat improved by texture mapping techniques like bump mapping). When you're dealing with discontinuous data, like your starfield, replacing multiple points with a single point is going to cause jarring effects like points shifting abruptly. You can also try one of two techniques: