It's almost assured that this is happening somewhere in your code. SQL Server has been beat-on pretty heavily by very, very large users over the years. A bug in the SQL Server engine itself of this type would've been sorted out a long time ago. 
The whole "rounded off time" symptom you describe makes me think that you have a "utility" function buried somewhere in the code that is "helping" by truncating the time (since truncating datetime values is fairly trivial). 
Make SQL Server throw contraint violation errors and you'll be able to track down the offending code. Leave the constraints on the database even after you've fixed the offending code because excluding invalid data is part of the database's job.
Putting constraints on tables isn't a "solution" (in a figurative sense). Rather, it's the right thing to do. By definition a database schema should be designed to cause the RDBMS to enforce constraints that prevent invalid data from being represented in the database.
You should have constraints on your tables to prevent "duplicate data" from being inserted as part of the basic design of the database. If you were using natural primary keys you'd get this "for free". Since you're using artifical primary keys ("identity" columns) you need uniqueness constraints on the columns that make up the natural primary key.
Once you've got uniqueness constraints in place errors will be thrown when these duplicate records are inserted and you'll be able to trace them back to their source. If your code doesn't have the equivalent of an "On Error Resume Next" type of construct in it you should start getting errors (unhandled exceptions, etc) when the offending code fails to perform the inserts on "duplicate" data. 