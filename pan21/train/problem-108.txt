Keep in mind that you have a limit to how many sockets/threads you can create per box. Sockets are limited to something like 16 million(16,777,214 to be exact), but threads are much worse. With threads, it's possible to get a few hundred going, but that is not advisable. Threads require a chuck of contiguous memory in order to allocate the stack, so you will quickly run into the upper bounds of memory once you start to create/shutdown threads per connection.
There are a lot of things that you need to consider. First of all, where are you hosting your servers? UDP works great if your hosting your own hardware, but if you're using something like AWS then you'll end up spending a lot of time trying to get a good reliable solution. UDP traffic can not be load balanced using the default load balancer, so you'll have to expose individual instances to the users. The same goes for Azure and Google services. 
However, for the next steps (particularly the steps concerning what happens inside the lobby), I am undecise on what approach I should take. How can the server notify the players of new events (disconnections, new player, character chosen by a player, player ready...)? Should the players poll the server on a (very) regular basis for new events? Or would it be better to have a pool of threads to keep a TCP connection alive with the players in order to broadcast new events? Or something else? (UDP?). I'm kinda lost.
The best way I've found to support in-game events is either through sporadic polling over TCP from the client or long polling and TCP keep-alive sessions. 
Also, if you're targeting mobile, then forget about UDP. Mobile data carriers have sporadic support for UDP. Sometimes it will work, other times it will not. I am aware that you can check if a user is on their cell network or using Wifi, but limiting the users to only play while they are wifi in order to use UDP is not a good solution in my opinion.
Oh, and by atomic operations, I mean the following definition: Atomicity is a guarantee of isolation from concurrent processes(from Wikipedia). How you implement server-side atomic operations is another subject altogether, but for a quick reference, take a look at how CouchDB handles conflict resolution.
I have written my matchmaking server with the C# Web Api template. This RESTful webservice can at the moment take care of steps 1, 2 and 3 as they are transactions between the frontend (player in UDK game) and the backend (the C# matchmaking server). The player asks for something, the server replies with JSON data. I have done so because having many HTTP requests seemed less foolish than having all authenticated players on a constantly alive TCP connection.
Sporadic polling is better if your requests are lightweight and atomic in nature. however if you need to guarantee order then go with a long polling keep-alive connection. 
Lightweight polling with atomic checking is by far your best choice if the server uses thread pooling and automatically handles keep-alive connection pooling.
I would use the same method of communication that you will be using once the game begins. You're only delaying the inevitable by using these other methods. I don't know what you'll be using during the game, but now is the time to find out.