The question I want to ask back to you is, "Why do you need CapSwitch and SimpleSwitch to inherit from some sort of GeneralPurposeSwitch?"
For example, if your problem is that you won't know until runtime what kind of switch is hooked up to your hardware, then you might need this kind of code to work:
The middle ground that seems obvious (at least to me) would be to factor the parts that are truly unique to a type of switch into a pair of classes, then have a small template that you instantiate over one of those classes, which provides a single interface to either type of switch. This lets you change between the two at compile time, so only one little bit of code needs to change, and avoids repeating code between the two where it isn't strictly necessary.
So, the common functions end up in the template itself, and anything specific to one or the other ends up in the class for that specific type (with a front-end in the template the delegates appropriately) so client code works the same regardless of which type of switch is in use.
And so on. Once the two codepaths start looking more similar, so that the human reader can look at one of them and then look at the other and say, "Okay, I see what's going on in CapSwitch by analogy with SimpleSwitch"... well, at that point, it might make sense to look at whether CapSwitch can reuse any of the actual code inside of SimpleSwitch — via a non-abstract base class, or CRTP, or any other design pattern of that general nature. But it's still very premature to worry about that, I'd say.
You shouldn't write OOP code for its own sake (in fact, you shouldn't write any kind of code "for its own sake", at least in a production codebase). You should start from some sort of problem in need of solution, and then write exactly the code that solves that problem.
But if you don't need that kind of thing to work, then you probably shouldn't worry about adding code to make it work. Instead, just focus on making the two codepaths as understandable as possible.
For example, right now you've got parameters named p and _pin that both seem to be doing the same thing. Consider renaming them both to pin, so that a human reader who has already learned what the English word "pin" means will immediately know what's going on in your code, instead of first having to learn what p means (namely, "pin") and then later have to learn again what _pin means (namely, "pin") and then wondering why there are two different words for what seems like exactly the same concept.
You asked, "How should I factor out a parent class, so that CapSwitch and SimpleSwitch can inherit from some sort of GeneralPurposeSwitch?" — but don't you already know how to do that?
Since you've said you will always know the type of switch at compile time, you might want to consider what I'd think of as middle ground between the status quo and supporting run-time polymorphism.
You've got member variables named hilo and hiLoTransition. Consider renaming them both to the same thing.