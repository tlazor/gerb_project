Methods are not serializable. Methods aren't data; they are procedures. It makes no sense to serialize a definition of "how to do something". Definitions are the responsibility of the classes/assembly. --- This is also the reason why you can't deserialize data without access to the assemblies that define it. The compiler is not clairvoyant; it needs to know the format that the data is supposed to be in, in order to reassemble the data back into a concrete instance.
You seem to have a misconception about how accessibility-levels work in C# (or programming in general). An element marked private cannot be accessed outside of the class it's declared in, by definition.
The reason you are able to expose fields is because the editor is not working with the actual run-time instance, but rather with a serialized copy that the editor will substitute with an instance when the time is right. Fields are serializable, and serialized types that have a Drawer show up in the inspector, so when you override Unity's default behavior using the [SerializeField], and the protected/internal/private field gets serialized, it will show up in the inspector. It's more of a consequence of how the system works, rather than actually "exposing a private field" as if it was a concrete action that could be taken.
Since methods aren't serializable, the inspector can only know about them through reflection. And while there are ways to get references to non-public methods through reflection, it will not be something that Unity will provide out-of-the-box, because it's something that presents many problems: