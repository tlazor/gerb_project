The way you dissected the problem was a good way to get a handle on it but once you had, it reveals some refactoring opportunities.  Once you have the individual methods, you can begin to see how to build them back together
You might want to name that map_side something that means more to you in the problem domain (I know it returns an array of arrays, but didn't come up with a better name than map_side).
Let's begin by focusing on your two Matrix#<xxx>_segment methods.  Both have the same method signature and differ only by the use of width and height. So those could be combined to just be 
which has the advantage of keeping width in the same function, making it slightly more readable and DRY.
The code is now DRYer, the width and height references are near each other for their specific uses, and you can quickly see how they stack up (in other words, your naming of elements was retained).  The one part that might throw you if you're not used to it is how I used the lambda closures to pull this off, but it's not an uncommon approach in Ruby and as you can see, a handy one.
Now the following methods can be safely removed: horizontal_segment, vertical_segment, top, bottom, left, right, and number_of_layers.
The other answers are already very good, but I want to point out one stylistic detail the other answers missed: Matrix#rotate! should be called Matrix#rotate, there should be no bang in the method name.
A key thing to look at when you have tiny methods is whether you ended up using those methods more than once.  I like labeling things too to keep them straight (and that's always a Good Thing), but when it's just a single use, a variable name is as good as a method name.  So, we can just get rid of number_of_layers as a method.  I called it count below, but whatever works for you.
Your side functions (top, right, et al.) really only differ by the block they use.  So you could write a single map_side method that just passes a block in the map.  However, because of the refactor we just did in the new #segment, a lambda helps pull it together:
In fact, those four functions could be rolled up into one function that still satisfies the single responsibility guideline (note the name: the function does exactly what the name says, and nothing more), and it isn't all that large:
The bang is used to point out the more surprising one of a pair of methods, i.e. when you have both rotate and rotate!, then rotate! is the more surprising one. However, you only have one method, so it shouldn't have a bang.
I tested this refactor with your test suite and it ran fine.  I didn't benchmark, but it certainly didn't seem any slower and might be a little faster.    
A key problem with a monolithic construction such as my solve_matrix_rotation_challenge is that it's hard to see what's going on without lots of commentary. A key problem with a slew of overly-short functions such as in your implementation is that it's hard to see how things fit together without lots of commentary. There's a happy medium where you can still understand individual chunks of code and where you can see how things fit together, and without needing an excessive amount of commentary.
Note, this is a hash of lambdas now, not the arrays you're looking for yet.  But with it, we can now write this for layers in whatever order you need:
With that, we just use the new method to set up a quick hash of lambdas for each side, passing each the specific block you wanted: