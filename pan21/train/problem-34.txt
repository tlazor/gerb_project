You can also use CTE as an optimization fence which forces the full select to be run before ordering and applying the limit:
Starting in v12, this is no longer an optimization fence unless you write it as with t as materialized
The problem is that PostgreSQL assumes that more rows will be returned when you specify more OR conditions, so at some point it will think that an index scan won't be faster any more.
As you add more OR conditions, it thinks it will return more rows.  Since there is an ORDER BY and a LIMIT, at some point it thinks that walking a different index, which provides the same ordering as the ORDER BY and stopping early once it hits the LIMIT, will be faster than getting all rows which meet the WHERE clause, and then sorting them into order and applying the LIMIT.
So I would go with the quick and dirty hack first described, at least until some future version of PostgreSQL offers better solutions.
Why is PostgreSQL getting it wrong in the first place?  JSON objects have no statistics gathered on them, so PostgreSQL has to use generic estimates about how many rows will match the @> operators.  You can see it is over-estimating that by about a factor of 40.  This is a double-whammy, as it thinks it will have 40 times more rows to sort if it follow the sorting route, and thinks it will have 40 times less of the already-ordered index to scan (before the LIMIT kicks in) if it takes that route.  One way to potentially fix that is by mapping the JSONB into regular PostgreSQL arrays, as those do have statistics gathered on them.  You can either store them in the table that way, or you can  create a functional index as outlined by Laurenz.  However, in my hands this did even worse for row estimates than the JSONB did: the most_common_elems column ended up being NULL, for reasons already explored.
The easiest way to fix this is to skunk the index being used to ORDER BY ("emailjobs_ordered_created_and_keys").  If "key" is numeric, then you can do:
This will not change the actual order, but will prevent PostgreSQL from recognizing that it can use the index to supply that order.