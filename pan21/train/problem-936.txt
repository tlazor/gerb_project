Usually there should be some reproducible sequence for debugging purposes. There might be engines that are not moveable, and some other small issues. 
Documentation mentions presence of undefined behavior of Type is not one of the listed ones. Putting at least static_assert would be great.
Your seed with a defined function seems wrong. THe first thing is you are missing the braces around the if and only the first statement is inside the if.
80/20 rule. 20% of the library is used in 80% of the code. Optimize for common usage. In the usage case shown in the question, library could easily use an alias template:
By looking at the documentation, it is clear that the only thing they share is their operator() and general value semantics. Construction and data retrieval are very different, aside from their behavior. Usually it is better to make a special code for the one that you use often, and use others directly. It is very hard to find an interface that would fit them all.
Where is the function passed? Generally you would pass it as the second argument and then the argument pack
In general, uniform distribution is not the ultimate distribution. Depending on the usage, other distribution might be needed. Discrete distributions could be used to balance the game dynamically, by moving weights around. Normal distribution might be used to get more of simple enemy NPC types and in other cases spawn one of the special ones. If you're sure you won't need the other ones, then that's great.
From the example, it seems like the main usage scenario is to stream random numbers or generate some of them at once. Yet interface doesn't allow that. Make interfaces easy to use correctly and hard to use incorrectly, Scott Meyers (not sure though if he was the first one). 