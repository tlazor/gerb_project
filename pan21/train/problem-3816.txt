Get a mentor. They can guide you. For example tell you which routines you will need. fork (create a new process), exec replace process with external program from file-system, pipe create inter-process pipe, dup copy file descriptor, close close file descriptor, wait wait for a process. Plus other that you should have used before.
Once you do this enough times, you start to develop a sort of gut sense for what sorts of obstacles you might end up.
Notice that if we had kept drilling down, we'd end up learning about the fork and exec thing here as well.
To a certain degree, it comes down to experience. But if you don't have experience, I feel you can get a lot of mileage of just trying to do the simplest thing possible to see what'll happen and googling your questions as you go. 
Gain experience with simpler programs: start with writing ls, what happens when you try to write cd?
First, figure out what the problem is. What are your goals? Is it just to build a working shell? Or must it be done in a certain language? Often, in school, the problems are defined for you, but in the real world, they often aren't. Figure out your parameters and what exactly a solution needs to be like to be a solution. 
Free-Software / Open-Source projects are a good source of code for you to read. You could read the source code for bash.
Ok, how do we do all three of these things? Well, if we drill down, we might end up coming up with something like this:
Find a real project to work on. There are many Free-Software / Open-Source projects that you could work on. These will give real experience.
For example, we want to write a shell. Well, what exactly does this shell need to be able to do? Let's say as a minimum prototype, I want to be able to:
At some point, you'll run into an obstacle you didn't anticipate and realize you need to pivot and adjust or even entirely re-write your code to accommodate. (Having to rewrite code can seem painful at first, but it's basically something everybody needs to get used to. It's helpful to have a sort of zen mindset, where you let go of your attachment to your code).
For example, take your shell example. If I had absolutely no idea what I was doing but just moved forward instead, I would probably...
Another strategy you can try is to try planning ahead: specifically, figure out what precisely you want to do, then decompose that plan into smaller and smaller subproblems. The nice thing about this approach is that it forces you to think about potential obstacles you might run into and can help make it easier for you to form precise google queries.
Second, start breaking down the problem. With your shell, maybe you think, okay, I need a GUI, and I need a way for user input to 'act' as commands, and those commands to produce some sort of output. Here you should be of course check your requirements to make sure the "chunks" of your program can handle everything that needs to be done.
The key is to just give whatever it is a whirl. Try, and see what happens. Quite a lot of code might be written, and most of it will break, but that's how you learn - you gain an experience of what methods work and what methods don't and fill out your figurative toolbox.
Fourth, take the plunge and start writing code. Or solving the problem. Whatever. Follow your googlings and your goals and your requirements (those things are important) and your broken-down sections of the problem. When you run into errors, google. When you by chance hit on a better solution, rewrite. Debug and code and sketch out code and google and rethink your design and then tremble in awe at the finished product.
Third, the exploratory google searches. I kid you not. When I first wanted to write a GUI, I googled "python GUI". And started reading. I found out tkinter was a common package used. So I googled "tkinter GUI". I learned what things that entailed, and I checked whether the method could do what I needed it to do. I explored some of the difficulties I might have. Make sure, for example, that the package you're using to create the GUI doesn't interfere with whatever things you might be using to get user input, or make it into commands for the computer, or show output, or whatever. Make sure it can handle all the things it needs to handle (check the requirements for this). 
This is much more important than you'd think. Unfortunately true anecdote: I was writing a program to solve a simple problem. But then I wanted to enhance it. And I wanted to do this and that, and oh, maybe I'll add that - and the code got super unwieldy, with more and more bugs that I needed to work out - and finally I thought about it and realized that most all the code in there was unnecessary for my purposes. I wasted multiple weeks on that project.