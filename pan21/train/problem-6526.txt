That's the value of the enumerator; it's a static, compile-time value. The actual runtime limit is queried from the implementation using that enumerator. Typically via glGetIntegerv(GL_MAX_VERTEX_OUTPUT_COMPONENTS, &mvoc).
You shouldn't be doing transformations into light-space in your VS; that should happen in your fragment shader. You should be sending the basic information to the FS needed for it to do its job: normals (and tangent/bitangent as needed), texture coordinates, etc.
I'm developing on Windows 10 with GLEW v2.1 and the November 2019 nVidia driver.  I'm not using any other extensions/libraries, eg glm/glut (doing all my matrix work myself).
I can get around this by implementing subsequent features per pixel rather than per vertex, but that's a real pain because its going to result in sub-optimal efficiency which could become a big problem later.
I have an OpenGL based graphics engine coming along quite nicely, but I'm currently stumped on a problem that arose after adding a new vertex shader output array.
The vertex shader is outputing the usual things one would calculate per vertex to minimise fragment processing - eg fragment locations in tangent and light space etc which are done on a per light basis with currently an 8 light max per lighting zone.  Structure as below.
But this method of pre-computing large quantities of data per-vertex is not going to work. Interpolation of vertex data is not free, nor are the caches between the VS and the rasterizer.
Everything was working fine until I added the vLightMRPTangent[cMaxZoneLightCount] array.  Adding that brings the total number of vertex outputs to 153 and I receive error C5041 when the shader compiles - "cannot located suitable resources to bind variable... possibly large array".
Now, the interesting thing is - if I make vLightMRPTangent[2] instead of 8, this brings the number of vertex shader outputs down to 129 and it works.  Similarly, a vLightMRPTangent[3] which would put it up to 133 output components generates a different but verbose and nasty link failure message.
If you find that your FS's performance is not what it needs to be, then the best thing you can do is reduce the number of FS executions. You can use a depth pre-pass to eliminate overdraw, so the only FS executions that happen are those which produces an actual visible element. Or you can go to full-on deferred rendering.
So it's looking a lot like my still formidible GTX970 only wants to send 128 components down the pipeline!! (tell me that can't be right...)