In whatever higher-level code deals with the interaction now (typically something more at the "game" level), you can employ techniques such as double-dispatch to resolve interactions between two runtime component types (normal dynamic dispatch in C++ and most languages is done only on a single parameter, the this pointer; double-dispatch is a way to perform dynamic dispatch on two parameter types, which is all you have varying in the case of two objects interacting).
There are many, many ways to approach this, depending on the needs of your game and what you want the API surfaces to look like. This is also not a problem that really has anything to do with entity systems. A physics API should maintain a list of physics object (often "rigid bodies"), detect, and resolve the collisions between them. The API can be a "system" in the common component-based parlance, or not. A physics object can be a physics component or not. It doesn't matter: the solution is the same.
This requires a sendMessage method on the Entity class that sends on the message and parameter to each component that makes up the Entity. The Entity parameter on the handleMessage method should really be a void* so you can pass anything in.
You don't want the physics code itself to know anything about the interactions between specific objects, beyond the fact that they collided (and perhaps some metadata about the collision). Instead, design your physics API to support the notification of a collision to interested parties, who can subscribe to events on the physics API if needed. You can implement this behavior with the observer pattern. Thus you delegate the processing of the interaction elsewhere.
I have CollisionSystem which basically iterates through the array of PhysicsComponent and checks if there was some collision between two entities. But where should interaction code go? And how should I deal with different types of entities? (pseudocode below)
What is bad is that this handleCollision code will have lots of if-else conditions as more and more types of entities emerge and the code will be hard to maintain. How can I deal with this?
Back in the physics system itself, you can avoid the n-squared problem of checking every rigid body against every other rigid body using spatial partitioning techniques. By dividing up your simulation space into distinct regions (for example using quad-trees or oct-trees, or even simple separation-of-axis approaches) reduces the problem space for detecting collisions by immediately discarding large numbers of objects that cannot possibly collide.