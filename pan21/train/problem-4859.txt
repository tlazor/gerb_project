Ok, don't hate me, but this is all the answers above compiled into one. I benchmarked all the answers with the following code:
About the pattern matching speed test: I think patterns need to be compiled, and the compiling takes a long time, compared to the actual matching. I would assume that to parse a number using some specific method, a pattern would be compiled once and then reused again and again, so that's how it should be measured. 
So there may be a spec, and you better test for that spec. If Double.parseDouble can't handle it then tough; check it by hand. Or you are handling user input. In that case I'd ask for common sense. 10e-3 should probably not be considered valid input, nor should 0x1234, nor should 0777 be different from 777. I'd probably ask to be nice about spaces, use localised decimal and thousand separators, handle $ or â‚¬ gracefully. 
Saying "is this string a valid number" is quite pointless when you don't have a spec what a valid number is. For example, a valid JSON number can have a leading minus but not a leading plus, it can't start with a zero unless the integer part is a single zero, if there's a decimal point (not comma) then there must be digits after it, and the exponent can have a plus or minus and as many leading zeroes as it wants, just to be inconsistent. 