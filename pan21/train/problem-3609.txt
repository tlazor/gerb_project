With D3D, you don't use a separate call to set the divisor, it's part of the D3D11_INPUT_ELEMENT_DESC.  The shader calls to access texture buffers are different and you use constant buffers as the analog to a uniform buffer.  Otherwise, same thing.
An alternative, which is necessary for OpenGL implementations that don't yet support glVertexAttribDivisor, is to store your per-instance information in either a uniform buffer object or a texture buffer object.  With a uniform buffer you just acess it like a regular array.  With a texture buffer you use texelFetch in your shader to access them.  Use gl_InstanceID as the index.
If you're rendering 10 models and need 10 positions, you create a VBO holding 10 positions and then bind it with glVertexAttribPointer.  You can then use glVertexAttribDivisor to set its instance update rate to 1.  Now this attribute in your vertex shader will be sourced per instance; that is, the attribute won't change for each vertex, but it will change whenever a different instance is being drawn.
I don't know XNA, so I'm going to just talk like we're doing OpenGL.  This all translates relatively easily into D3D, and should hopefully thus translate into XNA easily as well.
In your shader, you get a new uniform called glInstanceID which is the number of the instance being drawn.  All of your other uniforms in the single case now need to be in an array of some kind that you can index with glInstanceID or be part of a new vertex stream that is automatically updated once per model.
When you call glVertexAttribDivisor you can specify that a particular vertex attribute in a bound VBO is only updates once every N instances (usually you set this to 0 for attributes shared by all instances and 1 for attributes that vary per-instance).