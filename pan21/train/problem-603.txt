Bonus for them: If they choose a career in code, is that they'll find a lot of their professional time is spent doing similar tasks. Teams might make a program, but each coder only does a part.
The other side though is coming up with a coding assignment that is doable in 2 hours. To do that you'd probably have a few of the upper students finishing in 15 minutes. Sort of the same issue as the discussion we had a few days ago on students finishing labs quickly. 
I normally do a hybrid of the two, and it works okay. A multiple choice section that should take about half the period and a couple of simple coding questions for the other half. This semester I only had one student that had to stop because time was up, although a few stopped themselves early because they knew that had done well enough for the average they wanted. 
Bonuses for you: You can see what concepts seem to have been the hardest to implement and can adjust your syllabus for the next term. The scope of each problem is small enough that you can grade them, collectively, faster than trying to evaluate an entire program, which will of necessity contain lots of standard code that's really boiler plate - such as the includes.
For the final exam, I made a very odd test.  There was no material that they had learned up until that point at all - everything consisted of standalone activities that they would learn during the exam itself from texts I provided.  So, there would be a long explanatory text of some concept in CS that they hadn't learned, and then some simple problems.  (I chose regular expressions, a teensy bit of functional programming in ML, and coding in Java for memory efficiency, but you could do any topics that you want them to learn about as long as you can create or find a good explanatory text)
I'm not a fan of throwing 2 hours worth of multiple choice questions at students. Sure, I could probably come up with 75 or 100 multiple choice tracing questions. Make sure there are some recursive tracings and it could easily hit 2 hours.
Then, whatever their % on the exam was would be added to their 0 score.  So, if their average for the year to date was 85%, and they scored a 50% on the exam (a relatively high score), they would receive a final grade on the exam of 92.5%.
The grading worked like this: whatever their grade average was for the year in my class was theor 0% on this exam as long as they clearly made an effort to complete the exam.  (No attempt would be graded as a 0 score)
I had a rather odd solution to this back when I taught at a school that had no material beyond AP.  I figured that they worked their butts off for the AP test, and (especially juniors and seniors) were often burnt out.  So I had them free-build a project (ie. no new curricular material after the AP test)
How do you create a final exam that is a valid assessment of an entire year or computer science, but can still be completed in a couple of hours? Ideally I think a large-ish scale project would be the best assessment of where the kids are. But two hours just isn't enough time. 
In my 2nd and 3rd year courses I normally do a take home project, but I don't think that would work as well in my first year AP-A course. 
I probably should have asked this last week since we just finished up finals today. But, there's always next year :)
Rather than doing one large full-on project, do several smaller, focused coding segments that are not complete programs. Use the stated course objectives as a guide and create problems designed to show mastery of the listed points.
The advantages for them: no studying, and they learned a bunch of material in a highly focused 2-hour session.  The advantages for me: no complaining, no review sessions, and they could work on their projects until the end of the terms.
They were allowed to ask each other questoins about understanding the text I provided, but not about the questions they had to answer, and they were not allowed to refer to the internet.  The only questions I would answer were clarifying questions about the exam itself.
All things that demonstrate some subset of their skills, but don't require writing a complete program.
Problems for you: You have to decide what concepts to test where, and you have to create new questions every term that still test the same concepts.