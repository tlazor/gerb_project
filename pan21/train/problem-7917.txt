But value types (like numbers, or anything defined as struct) are stored and passed by value (by default). So each such variable contains a complete and independent copy of the data. Eg. an int variable will contain a specific four bytes, and every possible value of those bytes represents a valid integer from int.MinValue to int.MaxValue. So there's no leftover storage to represent the "nothing / not populated / invalid" message that null provides for reference types.
When we need to, we can augment a value type with an extra bit of storage to track whether it's been populated, by using a Nullable type. This is a built-in generic struct that wraps an arbitrary value type and adds null functionality.
If you're used to working with reference types, you can just change Item to be a class and you're off to the races. This can save memory in some cases because we can share references to a common instance rather than copying it everywhere, but it also means we're doing heap allocations whenever we create a new instance, which might not be ideal for types you want to create & discard frequently, like vectors.
This will let us return an Item instance or null, and the ? advertises to callers "I might fail to find an Item for you â€” I can only promise a 'maybe'"
We can declare that our method returns a nullable version of the Item type (ie. a Nullable<Item>) by writing:
Reference types (including anything defined as a class) are stored and passed by reference (ie. if you have a GameObject myObject variable that variable holds a kind of pointer to the game object, rather than replicating the whole object inside the variable's storage), and that reference can point at null to signify "nothing / not populated / invalid"
Calling code should then check to see if it got a null before it tries to work with the returned value: