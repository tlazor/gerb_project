Consider observer/subject pattern components for your game components and ui components. You plug them together upon creation/load up and then forget about them. If the character's health changes, it notifies all observers, which can do whatever they want with the information.
Remember, abusing your ECS is the same as abusing design patterns; just because you have some nifty new tool doesn't mean that you're supposed to use it to solve every problem you encounter. Evaluate your problem space and select the best-fit solution, even if it's the old dingy thing your ancestors used back in the dark ages of the 90's. :p
There's an EmsServer (one on the server, and one on each client) that's responsible for moving messages between EmsClient on it's realm (EmsServer on the server side moves messages between EmsClients on the server side, vice versa for the client side).
There's no reason that code that actually hooks up the HUD to your in-world game needs to be in a component/system that lives in some particular space. That code will perhaps be better off living in a central manager or global script that has access to all spaces and all objects, and can then interact with the code that knows when to actually create a space and what to put in them (e.g. the code that spawns the player, saves its state between levels, etc.).
Basically, I have an EmsClient class, which stuff can derive from. Currently, my components don't do that, but the more higher level classes, although there's not reason not to. I subscribe to Names of messages, and provide a callback with the following signature: Action<JObject>. As you've already understood, I'm using Json Objects as means to transfer messages. I've done this after I've before used just byte[]'s, and I found that I needed something more general, and since I'm used to something like that from my workplace (we have an IPCD that works similarly, except the callback method is always the same, since usually we separate responsibility to different handlers). 
this is something that I'm actually working on in the past couple of weeks. I'm working on my own ECS library (wanted to do that for experience and just to try it out, cause I've wanted to do so for quite some time). 
My code pretty much speaks for itself, and if you get to it, I'm looking for criticism for it, so I would like some constructive criticism :)
Whereas, for your example, if I want to add a GUI component for a player, you can look HERE, at the BeginAllocateLocal and BeginAllocateRemote methods, which are responsible for building the GameObjects of the players. Each GameObject contains an Entity (from the ECS lib) and an IComponentContainer (which is too, from the ECS lib). Each GameObject automatically gets a transform (like in Unity, from which I took inspiration).
I did create a few prototypes but nothing too big and the way I used to handle multiple spaces was simply create a game object which contains, world, player etc and than I'd setup some properties that are required by some other spaces for example health, in the game object
Whenever called it will get the player's health. that way I could send it to the HUD and display the health bar.
You could also just have a "master space" that holds game objects with logic or data that needs to persist past or manipulate the spaces used for levels and UI. That approach is common in engines that force developers to put all scripts/logic onto components/objects (e.g., in Unity, you'd make a global Main object and set it to persist across scene unloading; if Unity actually had spaces, you'd use those instead of the flag).
For messaging between the Client and the Server, I created an EmsServerEndpoint which is an EmsClient himself, he just does the logic of buffering the sent messages on it's realm, and flushing them to other realms (F.E the client sends the message to the server, whereas when the server transfers each message to all clients connected.
It is not the cleanest but it gets the job done, I did some performance testing back in 2013 and everything seemed to work smoothly. to avoid such dependencies you could always drop the health bar when player health is null.