Ten minutes later the timer goes off. Worker 1 stops working on Task-A and gets the supervisors instructions. Those state to put the current task at the bottom of the TODO list. Continuing the supervisor's instructions it now restarts the timer and start to work on what is now at the top of the TODO list (which is task-C).
In real schedulers there are many more things. E.g. interrupts (compare it to a phone ringing in the middle of a task and how to handle that), smart scheduling (giving the same task to the same worker will likely result in it getting done faster since the worker is already familiar with it), I/O (if a worker needs a book from a library (s)he will not wait until the timer expires, but immediately continues with the next task, etc etc.
Worker 2 does the same thing: It sets a timer and gets what is now from the top of the TODO list. Since worker 1 removed task-A from it worker 2 now starts on task-B.
Worker 2 does the same and stops task-B and starts with the top of the TODO list (which in the example is task-A)
This is somewhat simplified. But it should give you an idea how two treads (workers) can work 100% of the time on three or more tasks.
The OS stays stable in pretty much the same way it stays stable when there are multiple threads running on different CPUs. From outside a CPU core there is very little apparent difference in behavior between two LPs in the same core, and one LP in each of two different cores. All of the same "multiprocessor-safe" programming techniques, such as semaphores, must be used in both cases. 