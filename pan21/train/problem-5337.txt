One thing you should always make sure is that a shared variable is never read/written without holding the mutex.  In your case, the shared variable is myEvent.  Keeping that in mind, I can see two possible fixes for your main loop.  The first fix is simple: just keep holding the mutex while you use myEvent.  However, perhaps handle_event() is lengthy and you don't want to hold the mutex for that long.  If so, then the second fix is to make a copy of myEvent while you still hold the mutex.  Here is an example of how that would look.  Notice that I also moved the part where you clear myEvent to where the mutex is still being held:
I've marked above where the danger lies.  If another thread calls trigger_event() when the main thread is at the comment, that other thread will set myEvent.is_triggered and signal the condition, but the main thread won't notice.
The fix for this is simple: use a queue of events instead of a single event.  In trigger_event(), while holding the mutex you push an event onto the queue.  In the main loop, while holding the mutex, you pop an event off the queue.  You can do this where my code above currently copies myEvent into eventCopy.
This kind of loop guarantees that you will never miss another thread signalling the condition variable.  Notice in particular how someVariable is checked while the mutex is being held.
Right now, you only have one variable myEvent, which means that if two or more threads trigger events at the same time, myEvent will get overwritten with the latest event and you will lose the earlier event.