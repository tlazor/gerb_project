Vertex and fragment shaders run concurrently, not sequentially, and the GPU automatically load-balances between them, so it's not possible to meaningfully assign specific timings like 7 ms for one and 1 ms for the other.
When you measure performance with the matrices zeroed, you'll be seeing the amount of time needed to run just the vertex shaders, without any concurrent rasterization or fragment shading work in the GPU.  You can then compare this to the amount of time needed for ordinary rendering for each pass.  If the two times are similar, the pass is probably highly vertex-bound; if the zeroed-matrix rendering is significantly faster, it's probably pixel-bound.  It's also possible to get an intermediate result, indicating that the work is split about evenly between the two.
However, you can do a simple experiment to measure where the bottleneck lies: set the view-projection matrix to all zeros for all your draw calls.  This makes all vertices output zero for their positions and makes all triangles degenerate; it therefore short-circuits all rasterization and fragment shading, while keeping all the vertex shader work (the shader compiler can't optimize anything away, since it doesn't know the matrix will be set to zero at runtime).