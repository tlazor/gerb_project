Let's get started with the most important question in my oppinion: Can we improve the code using smart pointers. And the answer is: Yes, a lot. Most importantly, my first dislike.
If your data structures and algorithms that need dynamic allocations (and yes, a singly linked list does not allocations) can be made to work with unique_ptr, the compiler will insert the delete statements automatically where appropriate. A unique_ptr only works if it is the one-and-only owner of an object.
I would like to know what is good in this code and what is bad. In terms of everything (memory usage, functions implementations and optimization, naming conventions, etc...)
This means you also need to be more stringent where you transfer ownership, and be careful to not use a unique_ptr after transferring ownership.
You can not just make head and tail both std::unique_ptr<Node>, because (as an example) in a single-element list, both head and tail would point to the same Node, which obviously breaks uniqueness. Looking more in depth shows that each node is pointed to by its previous node, except for the first node, which is pointed to by head. On the other hand, the tail pointer does not point to anything "new" compared to that. So I would make Blinkedlist::head and Node::next unique pointers.