I also do not understand what exactly you intend to accomplish with this query, and therefore cannot offer much advice in optimizing it.
Specifically, in both halves of the query, you have used GROUP BY with only one attribute (M.msg_id), but listed many columns to be selected without the use of aggregate functions.  Assuming that msg_id is the primary key of the messages table, I could forgive the use of other columns of M in the SELECT list, such as M.uid_fk, M.message, etc.  However, it makes no sense to select unaggregated columns of message_share and myusertable.  Every SQL-compliant database would reject this query on those grounds.
I am suspicious of your use of LEFT JOIN.  I believe it is possible to obtain rows that consist entirely of NULL values.  Don't write LEFT JOIN if you actually mean INNER JOIN.
Here is what I would refactor to. However there is no way for me to test performance since you did not provide DDL or sample data. 
Single-letter alias names are not very helpful. Aliases should at least give Mr. Maintainer a clue what it stands for. What if you had a table called family along with friends... would you call it F2?
Also, I find it good practice to use the optional AS keyword, just looks better in my opinion. How about:
Using SELECT DISTINCT is almost always a sign that your joins are poorly formulated.  Frequently, phantom rows appear when you perform JOINs when a WHERE EXISTS subquery might have been more appropriate.  Unfortunately, I can't offer concrete advice since you didn't include any details about your schema in your question.
MySQL, with its default settings, is very lenient in interpreting queries that involve a GROUP BY clause, to the point where it can accept queries that make no sense at all.  There is a server-wide ONLY_FULL_GROUP_BY setting that can be enabled to make MySQL follow the sane, standard behaviour.
Some of your column names are pretty cryptic. I realize you may not have any say into it, but if this is your database you may consider changing names like ouid_fk and such to something more meaningful, if a bit more verbose. 
To me in a well-designed database, this status1 column should be int (4 bytes), smallint (2 bytes) or tinyint (1 byte). Not to mention, status1 is not a very good column name. 
Use line breaks and indentation to facilitate reading of your queries. Also consistent spacing is an improvement. 
It's not really possible to rewrite the UNION in a way that obtains exactly the same results, since you want each half of the query to return ten rows.  If the row count didn't matter, you could extract some of the intermediate joining tables into a subquery.