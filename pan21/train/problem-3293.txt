As a final note on the indentations that you used. I've nothing against it as long as it is used in a consistent manner. This seems not to be the case! Sometimes the editor on StackExchange/CodeReview is to blame though.
Eventually you're going to want to handle other key-presses, correct? You might also want to handle other encoding styles, like EBCDIC, correct?
When it comes to the compairing section of the program you could definitely tidy up a bit. It will enhance readability a lot.
What you might not realize is that having 128 (because eventually you want to support all codes/keys, right?) cmp statements will cause negative performance because al is compared up to 128 times for each key press, that's a lot. So we build a jump table that might be more work to implement initially, but in the end we'll end up with a much easier to maintain setup, and performance will not degrade. When we call jmp ascii(al), it jumps to the ascii label, then to the line identified by al. Easy stuff.
So you should get the point, go through the ASCII spec line-by-line and put a line for each record in the spec, then a label for each of those lines. For the ones you don't wish to implement yet, simply have a restart label or badCode label that ignores the input.
As you can see I combined a pair of settings in a single instruction. This saves space, can be a bit faster, and the comments make it absolutely clear what is going on.  
So, I've never done Assembly before, but these are pretty simple things to design for, and I hope the implementation is correct. First, we want to build a (very large) jump table for ASCII. Essentially, a jump table eliminates all of your comparisons down to exactly one comparison. It's pretty easy to set up:
The ret instruction below a jmp is totally useless. The CPU will never reach it. Now it just consumes a byte and is testament of (lack of) skills.
In its present form your program entirely depends on the values in DL and DH having a permanent meaning. If your program were to become longer and more complex, this would no longer be a desirable approach. Then variables would be in order. An example on how to use these:
Here you need to verify your understanding of the count in CX. It specifies the number of characters that you want to draw. The hexadecimal value 1000h equals 4096 in decimal, but the usual 80x25 textscreen only has 2000 characters to play with! In your program it seems to work OK only because the video memory is much larger than that single display page you're looking at. Nonetheless you should correct it to avoid developing the bad habit of buffer 
In this simple program it is what I would do. If the polling section were much longer I would keep what you wrote.
Your program uses many BIOS functions that require you to set the display page beforehand in the BH register. You specified it correctly in the SetCursor routine, but not in the several WriteCharacterAndAttribute calls.  
In a construct like this most programmers will try to save some bytes by using the opposite conditional jump and else fall through:
Regarding your indentation and such, from what I've seen usually assembly is spaced fairly far from the left (8-12 spaces) then all labels go at position 0. This helps keep them in plain sight, since assembly doesn't have 'functions' and such, and there's not a real concept of 'nesting' (you can nest labels, but any label can be accessed from any other location/scope so it doesn't always do any good).