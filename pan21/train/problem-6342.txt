For even faster code, make one single read, and iterate an array instead of iterating a worksheet and making 10000 worksheet reads - this code should run orders of magnitude faster than your original code:
Deleting rows one at a time is by far the slowest thing you are doing.  It is many times faster to do a single delete operation on the union of all the ranges you want to delete.  
The question is, what would this function do? Remember, we want it to only check what it needs to, and return as soon as it knows it should be returning True.
Now, in one single worksheet operation, we've got an array that contains the values of columns 1-20 for row i; we call a function that returns a Boolean value when the row is "up for deletion", and so we remove that row when that function returns True.
VBA will evaluate each Case until it finds a condition that evaluates to True, and then immediately jump out and return. Because we're working with an in-memory 2D array here, and not accessing any cells, this is going to run much faster.
This will have far more of an impact on performance than anything else you might do (unless your spreadsheet is really big).
If you do it this way, you don't need to make calculations manual or turn off screen updating, which are ugly and difficult to always switch back (and you must, always).  Consider what happens if your code throws an error: you should have a Catch block that cleans up Application-wide variables to prevent them getting stuck.  You also don't need to iterate backward.
Some other notes: as others have mentioned, don't use functions that depend on the currently active worksheet such as Rows.  For macros and buttons, it's OK to capture the currently active worksheet (or selection, or whatever you need) immediately, but then you should pass them around as Range or Worksheet variables.
Notice the column indices are off by one - that's because VBA arrays are zero-based by default. If you want to refer to column 11 with an 11, then you could use Option Base 1 at the top of the module, and do this:
So how do you make it so that you only validate what needs to be validated, and that you don't access the worksheet more than you need to?
Add Application.ScreenUpdating = False to the start of your Sub and Application.ScreenUpdating = True to the end. 
First make sure you specify Option Explicit at the top of the module. Option Explicit forces you to always declare all variables you're using, and that alone can prevent many bugs, since without it VBA will happily compile a typo.
Use this in conjunction with Mat's Mug's answer.  I didn't believe him that putting the cells in an array would make any difference, but I tested it and it actually did give about a 3x improvement over reading each cell individually.  For those wanting to test the performance difference themselves, here's some test code (I recommend having only one cell with an X in it):
The VBA culture is full of myths, outdated conventions, and cargo-cult programming.  I urge you to test the advice you get yourself.  The code above deletes 40,000 rows in a single operation, and runs about 40x faster for me than the code below.  Test this yourself against two sheets that have 40,000 rows of data.  For comparison, here is by-row version:
My standard answer to "how do I do this faster?" in VBA is to use the ADODB library to execute a SQL query against the Excel sheet. It's orders of magnitude faster than accessing the sheet directly, with the added benefit that you don't even have to open the worksheet up in an instance of Excel. It's a technique well worth learning. 