If you are using rsync (as was the case for me when Googling this problem), you can do it by specifying the ssh connection commandline to rsync as:
The first ssh command will cause /etc/issue to be printed twice (once by the system, once by cat), so the number of lines will be twice that of /etc/issue. The second command's output will only show the output from that number of lines plus one.
Neither my OS X localhost or my Ubuntu server print /etc/issue when I ssh in (neither with a shell nor with executing a remote command), so I cannot reproduce your problem. I will try this from memory.
When the host sends back lines of text, how can the SSH client know which lines came from the host's /etc/issue, and which ones are more interesting messages?  It can't.
Now I see that you are not logging, but instead looking for messages in the window - I recommend creating logs and scanning the logs instead of relying on terminal window output alone - this is much more flexible, and allows referring back to errors from previous sessions if needed.
If your log will have a bunch of sessions appended in one file, you could have your script do something like echo START LOGGING before running any other commands, and then echo END LOGGING before disconnecting, and then use a simple shell script (using sed or awk) strip out all contents of the file between END and START (ie. the boilerplate before each login).