Base.AnyInteger is another tagged union elsewhere that has cases for every .NET integer type except bigint. My expectation with these "Nodes" is that each one (except constructors) will contain their name in the string, a Node list containing any child nodes, and a reference to their System.Type or System.Reflection.___Info to provide additional information when needed. Last, I added the extra empty lines to help mentally align each level of nodes.
After defining a list of constraints that would have to be managed "in logic", I remembered that I'm not working with VB or C#, and that F#'s type system is better than what I'm used to. After about a half hour I came up with this:
This new set of types correctly describes what each node can contain, using the type system to enforce everything rather than just implying how the levels are arranged with empty lines. Now nodes from Lvl1 can contain children from Lvl1 or Lvl2, nodes from Lvl2 can contain children from Lvl2 or Lvl3 (Classes and Structures may also contain Constructors), and nodes at Lvl3 cannot contain any children.
I'm working on a parsing engine as part of a personal project, and I'd like to expose certain .NET APIs to the parsed environment. I put together a very simple tagged union that allowed me to nest types, and put together a few functions that built up a tree of namespaces. Before going further, I decided I needed to refine the types I was using, and came up with this:
Now that I've used the type system to make sure I can't accidentally add a Namespace node inside a Class node, are there any other obvious changes I should be making here? I'll also admit I was originally using list references for each list of child nodes, because it made it easier to reason about in an imperative way; I've since revisited my code and have removed ref and started making use of map/fold/etc.