The one caveat here is that if you're going to do this manually, you should probably -- somehow -- disconnect your application from the master before locking the tables, because if there are pending writes, they will happen on the master as soon as you unlock the tables. 
A better solution would likely be to set the two machines up in master-master where each of them is always a slave to the other.  You'll read that master-master (a.k.a. "circular") replication brings with it some new issues and concerns, but many of these are related to writing to both machines at the same time and potentially causing replication to break due to conflicting writes applied to each machine at almost the same time.
An excellent and painless way to do this is with HAProxy.  It can even connect your application only to the preferred server if the preferred server is up, and switch your application to the backup server if the preferred server is down.  You configure your application's MySQL connection to point to HAProxy and configure HAProxy to relay those connections into the appropriate MySQL instance.
But, if you really want to do it manually, here's the way to know the two machines are currently in sync:
Additionally, it's not only that you need the slave to finish reading everything from the master.  You really need to make sure it has also executed everything from the master.
Keep that connection open, because it holds the read lock, which prevents any thread from writing to the master.  Your application will be able to read, but will block on writes.  Check SHOW MASTER STATUS several times in a row and when the Position stops incrementing (which should be almost immediately since you shouldn't get back the prompt from the FLUSH TABLES WITH READ LOCK until all pending writes are done) your master is frozen and will not write anything else to the binary log until you unlock the tables with UNLOCK TABLES; or you disconnect.  If you shut down the master while still holding the read lock, nothing else on the system should be changed.  
When the Master_Log_File and Relay_Master_Log_File on the slave match the log file on the master and when Read_Master_Log_Pos (the last position the slave has received from the master) and Exec_Master_Log_Pos (the last position the slave has executed from the master) agree with the information you got from the master, and the *Running states are Yes and Seconds_Behind_Master is 0, then your slave has received and executed everything from the master and the two servers at that moment contain identical data in their tables.
What you'll do, instead, is treat one machine as the master, only allowing your application to write to that one.  When you want to switch... then all you have to do is switch... point your application connections that do the writing to the opposite machine.
The slave gets events as soon as they're written to the file... not when fsync() or fdatasync() is called and not when the file is closed or rotated... the events are sent across almost instantaneously.