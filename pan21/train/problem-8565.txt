On the other hand, in scenario 2, you only need to stop updating. So, in scenario 2 you get the pause for free, but updating takes work. In Scenario 1 you get the updates for free but pausing takes work.
The other example where you need scenario 2 is when you need to interact with an external system when the player is not logged in. For example, if the player let something crafting in your game, and you want the game to send a message to the player telling that it is completed... even when the player is not logged in. There is no way around it, you will have to implement that using the scenario 2.
Using scenario 1 falls down to the problem of trusting the client. As you know, trusting the client to do computation is not advised, because the user may tamper with the client.
Because of those complication, you might decide that it is better to implement that on the scenario 2.
If you also need processes to cancel other processes, that's harder. For example the process C will cancel the process D, then you would need to store the cancellation time for D, compare it to its completion time... and if it will be cancelled, then any effect the process D completing should be removed (for example if the process D was supposed to start the process E, then that should no longer happen).
There is one exception: You can let the client compute what the client sees. Here are two common examples:
Of course, in this case all this rushed simulation will be done in the server so that it can be persisted and to prevent any possible discrepancies between clients.
Besides, if the period of time that needs to be simulated is too long, the client may have to do a lot of work and that may be problematic. You can mitigate that by doing updates in the server (like in the scenario 2) just not that often, for example you may update once per day, an let the simulation of hours to the client. This may also allow you to change the seeds for random events every day, preventing malicious users to get information too far ahead in the future.
This is why when you sleep the pork chop in the furnace, it doesn't cook. Mods that change that, do so by sending ticks to nearby objects when you go to bed. Yet, if the objects in Minecraft could receive an elapsed time instead of a "tick", the game could just tell the furnace that X amount of time has passed and then the code in the furnace would figure out how much cooking was done in that time. Furthermore, the game wouldn't have to do that for all the loaded chunks, just those visible by a player.
Yes: if you send the seed to the client, then a malicious user may be able to use it to predict how the simulation will go in the future. You might not want this, as it may give away exploitable information... for example it might reveal that certain monster will appear in certain location at certain time.
Now, you have your player that walks into an area where there are these plants you describe. The client will query the server for the objects in this area, and the server will send the plants.
To correctly pause the world, you need to take the time for the pause, go over each entity and compute the progress for that time, update its state it and mark it in pause. To resume, you need to take the time again, and go over each entity again, remove the pause mark and set the start time to time taken.
â€»: If line of sight is very important for the game, you may consider to do line of sight checks for the player in the server (that will prevent the player from looking at something that shouldn't). But in practice handling line of sight checks for all the players in an mmo is (often) too much work for the server. So, keep in mind that you may need some compromise between playability and performance on one hand and preventing cheats on the other.
The scenario 2 is also how plant growth works in Minecraft. Saplings will take ticks, and after a given amount of ticks they grow. When you plant a sapling, it will be eligible to receive ticks from the chunk where it is. Not all items eligible to receive ticks from the chunk will, only a random subset. Because of this randomness the plants don't all grow at the same time, and that makes it harder to implement them in the scenario 1...
A process A that starts another process B can be tricky to implement. You can do that, if the process A will start another process B in the future, you can set the starting time of the process B at the time when the process A will be completed. You can chain multiple processes this way.
Both scenarios are useful, there are object that will require to be implemented in the second scenario. Yet, I suggest to use the first one as much as possible.
No: you can let the server set a seed for the particular random event and send that to the client. Now, the client can simulate the elapsed time using that random seed and (if the client has not been tampered with) it should arrive to the correct result.
Finally, there are things that need to be handled purely in the scenario 2. These are things that when completed will trigger another process or will require interaction with an external system.
I'll be taking Minecraft as example. Minecraft (at least old versions, prior being acquired by Microsoft) exists purely on the scenario 2.
Now, it doesn't really matter if, by tampering with the client, the player sees the plants in a wrong state. So we may let the client compute the state of the plants. That means that the server may send to client the timestamp of the last update of each plant and let the client figure it out.
I have seen developers who think that the reason to implement the second scenario is randomness... that is, for example, if rain is random then the client will have no way to tell if there was rain in this area, therfore the server will have to handle that...
Similarly, if the player starts a process that will take X time, the game can store that the process started at such and such timestampt and that will take X time. There is no need for consecutive storage of the progress of the process.
In scenario 1, you don't need extra effort to update the world. But you would have to do a global update (like those done in scenario 2) to be able to pause the world. That is because when the game checks the time, it will see that some have gone by.
The problem above gets even worse if the dependencies of the processes have interlaced branches (e.g. process A starts process B and C, process B will cancel process C, and process C will cancel process B).
You will persist on the actions of the players anyway. For example, if the player got an item, you want to persist that to pernament storage, regardless of which implementation you are using.