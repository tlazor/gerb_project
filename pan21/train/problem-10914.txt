In your EXAMPLE 1, you're gathering all your player input first, and then doing the move as part of logic().
In the first case, you will be checking all buttons every frame. Let's say you have 50 objects in your gameworld, and they need to respond to five different keys on average. If you are running at 60 frames per second, you'll be launching 50 * 5 * 60 = 15000 polling function calls per second. 
Here's a pattern that has served me well in many things (software design, code structure, major life decisions, &c): Gather, Analyze, Act.
In the second case, the input device (or some manager component inbetween) takes the initiative to contact all objects that are interested in listening to keyboard event. Let's say you still have 50 objects in your gameworld, they still respond to five different keys on average, and you are still running at 60 frames per second. The important thing to note is, that object code is only called when an event happens. Let's say you press 10 keys every second (which would be a lot). This means the number of calls made will be 50 * 10 = 500. 
But usually what happens to each game object (including the player) might be affected by various things going on. If you keep working on Example 2, you might find more and more "logic" crammed into "input".
For active polling, the number of calls relates to the the amount of buttons that an object responds to, the amount of objects in your gameworld and the framerate of your game. For events, the number of calls relates to the amount of actual, physical button presses and the amount of listeners. 
Events are a great choice for checking input, as input events occur sporadically (aka. relatively far and few inbetween). 