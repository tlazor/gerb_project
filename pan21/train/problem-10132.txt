Now, you feel like you've probably lost all your beautiful formatting! Not to worry - toString() to the rescue! It'll get you a String containing the String representations of all the elements in the List, separated by commas and spaces with the whole thing enclosed in square brackets.
In the case of fact, it should return List<Integer> (for ease of use) or int[] (for performance reasons, not that that should ever be your primary concern).
Note: You'll need to use List<Integer> instead of List<int>, as primitive types are not objects and hence cannot be used with generic containers without boxing to its wrapper type first. However, with the advent of autoboxing before Java 7, the process is transparent and thanks to caching will not incur a large performance hit from object allocation for small numbers (less than 127).
Your format specifiers totally mess up the output formatting - don't worry, I'll (mostly) fix it in the full program below.
isPrime, (which should be isPerfect (or isPerfectNumber to satisfy my tastes), by the way) should return boolean.
Why hard-code 100? I'll show how you can get the maximum number up to which to check for perfect numbers as a command line argument, and improve usability while at it!
All three of those methods have a loop which does the same thing: find the factors of a. That should be pulled out into a single method, which should have a suitable return type (e.g. Collection<Integer>, although there's a good case for Set<Integer>, or maybe some integer stream type, but I'm not up to date on Java 8).
First things first - you ask us to reduce your code without changing it. That, obviously, isn't possible. So you'll have to settle for changing your code. Others have suggested minor changes; however, I'll go wholesale with my recommendations. In fact, I'll even show you a way where your code becomes just 3 to 5 lines long! (Warning: Java 8-fu ahead!)
Now, you see that we are repeating similar calculations thrice for one number. What this suggests is that we pass around intermediate results ("cache" them) so the process becomes faster. For this, we can combine all my previous suggestions into a whole program as below:
This answer is mostly an addendum to @Peter Taylor's answer, so I'll not address previously addressed points.
I'll cut you some slack on this as it does not look like this app will ever present an API, but recommended practices are recommended for a reason.
Use a consistent bracing style for blocks - the Java convention is to put the opening brace on the same line as the declaration, and the closing brace on a new line at the end of the block.
What's going on here? My best guess would be that you're mixing tabs and spaces with a tabstop of 8. Be consistent: tabs or spaces. Changing the tabstop shouldn't break the formatting.
About fact - remember how I suggested it should return a list of the factors, instead of formatting them into a StringBuffer? In this case, since the factors of a number should be unique, I recommend returning a Set, whose elements are guaranteed to be unique, and specifically use a TreeSet, as HashSet does not store its elements in a defined order, while Treeset stores them (for our use case) according to their natural order.
However, you've probably noticed by now that perfecrNo is already returning the sum of the factors (shouldn't it be named sumOfFactors?) - so why not just use that in isPrime, excuse me, isPerfectNumber?
Then two of the methods sum the factors: that's already pulled out into a method, so the other method shouldn't duplicate it. Instead you should have a very simple method
Why does fact return a StringBuffer? I can't think of many situations in which it makes sense to return a StringBuffer (or a StringBuilder). Either you're appending to a StringBuffer/StringBuilder, in which case it should almost always be an argument and doesn't need to be returned, or you aren't, in which case it makes more sense to return a String.
Whitespace is free, and makes intractable sections of code more readable - here, space around operators and before opening braces is the Java convention.
When you don't want a method to be exported (you don't, usually, for methods that are implementation details)(that is, to be available to anyone for use and abuse), you want to use the private visibility modifier instead of public or package private (the default if you don't specify a visibility modifier).
I won't bother explaining this too much, it should be self-explanatory once the concept of higher-order functions and lambdas are understood, along with method references. Reading up a bit on Java 8 would help a lot more than me trying to explain this. I'll also sacrifice a bit of good design to keep it short - it'll all be in the main method.
Why does isPrime (isPerfectNumber) return a string "true" or "false"? The boolean type exists for precisely the type of things which are true or false.
Try to always use braces even for single-line statements - it lowers confusion originating from wrong indentation and makes it easier to add code later to that block.
As to why it lies to the reader of your code - that's usually you - and other users of your code - that has been already been clarified by Peter, so I won't bother with that here.
Your method naming is plain horrible - it lies to the reader and API user (and that's after ignoring the typos - you probably meant perfectNo instead of perfecrNo.
Obligatory screenshot of output (don't mind me showing off my custom Rainmeter setup :P) - forgive the low font size, the whole thing wouldn't fit otherwise.
I recommend using a java.util.LinkedList as an intermediate in this case, as the elements of this are only ever iterated in order and the number of factors of the number is not known before the factors are evaluated - thus it will provide performance characteristics better than a java.util.ArrayList on large or highly-composite numbers with where the number of factors is large enough to require reallocations of the underlying array.
It's easier probably for your formatting purposes to return String or StringBuilder - but that's not what one would expect.