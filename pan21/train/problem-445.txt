And for most interesting problems, the lifetime of at least some values depends on runtime (user) input, so lifetimes can't be statically determined. But even if the lifetime doesn't depend on input, it can be highly non-trivial. Take the simple program repeatedly finding primes simply by checking every number in order, checking against all primes up to sqrt(N). Clearly this needs keeps the primes and can recycle the memory used for the non-primes. 
The chief problem here is the fiction of immutable values in pure functional languages, which are created while the program runs. Real hardware (and certainly bare metal systems) rely on mutable RAM, which is in limited supply. The runtime of a functional language implementation in practice dynamically allocates RAM as new "immutable" values are created, and garbage collects them when the "immutable" value is no longer needed.
A trivial scheme for the "bare metal" systems is to simply disallow all runtime memory allocations. Remember, even the C malloc/free pair requires a runtime library. But even when all objects are defined at compile time, they can be defined in a typesafe way.