Flash-based storage devices implement an FTL - a flash translation layer.  What this is: They maintain an internal table that maps OS-visible "blocks" to firmware-visible flash pages (PBA to LBA), and they will also keep track of which "eraseblocks" are ready for new data.  Incoming writes will not go to a flash page only based on the incoming block number, but wherever the firmware deems is a good spot - and the firmware will update its internal PBA to LBA table to find it when it's needed next.  
You can't issue an erase command on USB or SATA mass storage devices other than TRIM (and that's just a request to device firmware, not a direct command to flash chips), those standards are meant for hard drives and not flash hardware.
The moral of the story: Don't worry about it.  Treat it like a normal hard drive, and keep backups.  Crappy flash drives will die earlier than good ones.  
There is no such thing as a standard hardware, firmware or software platform for USB flash drives, so you can't rely on any sort of standards to help you predict exactly what the firmware might be doing with incoming USB requests without intimate knowledge of the microcontroller, NAND flash hardware, and firmware in question.
Probably the easiest situation where you can experience this is Linux-based consumer-level routers - the underlying Linux OS is on and has access to a 4MB, 8MB, 16MB or similar flash chip and can talk to it and manage it directly.  Android phones are similar.
All USB drives have a microcontroller that takes incoming USB requests and translates them to actions consistent with the actual storage on the USB device.
Unfortunately, you cannot know what that microcontroller is doing exactly without having the source code to any firmware and full knowledge of it's small hardware platform on that USB flash drive.  
Flash chips are read and written in pages.  They are erased in sets of pages that Linux projects call "eraseblocks".  (This is very different than mechanical hard drives).
Good firmwares will try to redirect writes to eraseblocks with erased pages for performance reasons, and they will swap blocks in the background to try to make it so that erasing is not needed before writing.  When drives get full, it's less likely this can be done, and performance will suffer.
I know, but without that internal knowledge you can't modify your write behavior meaningfully.  Especially since there's various microcontrollers, firmwares, and NAND flash chips, what might have any sort of effect on one flash drive may not work on a different flash drive.
In the case of USB drives that have NAND flash, the firmware/microcontroller on these devices likely (hopefully) implements a FTL that does wear leveling.  
Filesystems "optimized for flash memory" require direct access to the flash hardware so they can issue erase commands to the flash themselves.  Talking to a device via USB, SATA, SCSI bus via mass storage commands is not direct access.
You can then assume that writes, even if the same file and "block" from the OS point of view, do not go to the same place on the flash.  So you gain nothing by worrying about modifying files in place.