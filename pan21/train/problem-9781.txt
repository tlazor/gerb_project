Note particularly here that all buildings - no matter the archetype - can now live in a single homogenous collection. This is pretty useful. You can just draw all buildings without having to care about what type they are, for example:
It's not ugly, at all. You're just confusing language types and instance with game archetypes and instances. They're different things.
Of course, you might now be wondering about all the code bits that are in fact different for different kinds of buildings. That's the same application of this design, though. For instance, Barracks might produce Soldiers but City Hall produces clerk, and City Halls might also have a Take Loan option.
You also have properties that are unique to each instance of a building archetype (any building), such as its location, or its construction completeness / hitpoints / whatever. Again, it doesn't matter which archetype a building instance uses - they all have these same sets of properties. Hence, a building instance is a second class.
This provides another benefit - your building archetypes, since they are just data values for a class rather than unique classes - can be defined in data files instead of code. You can allow designers or modders to add all new buildings without having to recompile your game.
For game objects, think about the kinds of operations you have. For instance, you have an archetype of building called BuildingA. All BuildingA's look the same, have the same stats, or whatever it is your game requires. In other words, there's a bunch of properties that are shared by all BuildingA instances. Note now then that BuildingB has the same set of properties, just with different values. That is, both BuildingA and BuildingB have a sprite or mesh that is shared by all their instances but is of course different between the two building architectures.
And hence each instance takes its archetype as data instead of using the language's type system, since the operations you can perform on instances of one building archetype are the same as another building archetype.
These don't need to be methods on a building class, though, and you don't want them to be - that would mean that you have to write differnet UI code for every building, and different AI code, and so on. Huge pain. Instead, a building archetype can contain a list of Action classes that define what sorts of things a building can do, and individual action sub-classes can define the logic of the action.
This should sound familiar. All building archetypes have the same set of properties: that means that you can model building archetypes as a class! So instead of class BuildingA you instead have class BuildingArchetype. Your individual archetypes of buildings are object instances of that class.
This. Do not use your language's type system to enforce your game logic's taxonomy. That's the kind of bad object-oriented programming nonsense for which Java programmers get ridiculed. ;)
The type system in your language is there to enforce interfaces. It's there to help you make sure that you don't accidentally try to draw a sound or animate a database record.
This is also composable as now you can reuse your actions on buildings, on units, on scenery, etc. You can make units that can make other units, or buildings that attack just like units do (e.g., guard towers can fire bullets just like soldiers can, without having to duplicate any code).
Note also the "composable" part. This is the crux of what leads into component-oriented design. Instead of hard-coding a complex game object into a single class in your code, allow your game object to be built out of many small components. There are plenty of resources online for you to Google if you're interested in that broader topic.