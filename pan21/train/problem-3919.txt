 only internal commands did not use fork()(ex. cd,pwd etc).Even in some famous books internal commands are defined as the command which does not generate any process.
Running a program on Unix involves replacing the memory image of the current process with the image of the program; this is done by the exec() family of system calls. When the program finishes, the process terminates. If we hadn't forked a new process, there would no longer be a shell process running to display a new prompt and let you run more commands.
then no new process is created when you type find.  Instead, the shell will invoke the function, which is a no-op.  However, if you have not defined such a function, have no alias set for find, and an executable named find exists in your PATH, then the shell will (almost certainly) fork a new process.  ("Almost certainly" because it is quite possible that you are using a shell which implements find as a builtin, although I am not aware of any shells which do.) 
yes, generally speaking find is not a built-in command so the shell will spawn a new process, by calling fork() which will exec() the command.
So the shell forks a child process, and this child execs the program. Meanwhile, the original shell process waits for this process to terminate. Or, if you end the command with &, the shell doesn't wait -- this is how we run programs in the background (I'm simplifying greatly, but this is the important gist).