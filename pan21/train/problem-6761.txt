Given that you only want to avoid the most recent result, what you're essentially asking for is "a random number between A and B that is not C". This can be pretty easily achieved by generating a random number between A and (B - 1), then, if you got C, returning B.
Of course, for anything besides a hobby project I would go with your approach except that I would write my own RNG.
(Side note: | 0 does the same thing as Math.floor, but faster and more concisely. Though counterintuitive at first, I tend to think it's worth getting used to.)
You can do this without checking what the previous selection was.  On the first iteration, you select a number from 1 to n, call this r.  However, subsequent iterations should select a number from 1 to (n - 1), call this rn.  The next random number in the sequence is then ((r-1 + nr) % n) + 1
Your code only allows you to prevent repeating any two consecutively-generated numbers, it does not prevent collisions with numbers that have been generated on previous iterations - to do that, you would need to keep an array of all the previously generated values and iterate through them.
It works like this: imagine the numbers 1:n are stored in array.  If you start at some position x, you get to the next position x, but not back to x, by adding n-1 to x (but not going past the nth index by starting over at the beginning when you pass it, hence the modulus operation).  That's kind of hard to visualize without a diagram and i'm not good at making internet forum diagrams.
Instead of - 1 I have - (lastRandom !== undefined) so that, before lastRandom is set, you select over the full range.