replicate-ignore-table and the related configuration options are problematic at best.  Not because they don't do what they're supposed to do -- because they do -- but rather because they have side effects that require a deeper understanding of MySQL replication.
STATEMENT -- the actual queries are replicated from server to server, with each server executing the query and modifying its data set.
Once that is set, if it were me, I would remove the replicate-ignore-table from the configuration, and instead provision the user table on the slave with the BLACKHOLE storage engine, which discards data sent to it, returning "success" on inserts and 0 rows found/affected on updates and deletes.
The problem you have stems from the way the events are replicating.  MySQL can replicate table data changes using two different mechanisms, statement-based and row-based, based on the setting of the global configuration variable binlog_format.
I have linked to the documentation from MySQL 5.6 since that's the current GA version, but this feature is available as far back as 5.1.21.  When doing things this way, you would still be advised to switch your master to binlog_format = ROW.  
Importantly, when a query is replicated as a statement event, triggers on the affected tables fire on the slave in order to make the same changes to other tables that would have been made on the master.  When a query replicates as a row event, triggers do not fire on the slave.  Instead, the master server sends over additional row images from the affected tables so that the additional impacted tables also get updated to match the way they were on the master.  The same thing is true when procedures are called -- either the individual statements in the procedure are replicated and have to be valid and execute on the slave (statement-based replication), or the rows changed by the procedure will be replicated (row-based replication).
ROW -- the actual queries are not sent, but instead, tightly-packed row images of the changes actually caused by each query are sent.
The solution is much simpler: alter the table to move the confidential data to the far right side of the table, and then drop those columns from the slave's copy of the table.  No, really:
The scenario you described cannot work unless your master server's binlog_format is set to ROW, because the queries running on the slave have to have access to the "user" table data.