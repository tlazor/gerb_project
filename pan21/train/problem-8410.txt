Rather than trying to motivate the students, or the reluctant ones, to progress into using your new tool (foreach after for), and finding a new motivating example every time, try to motivate them to be self-interested, lazy coders.
Elegant solutions are appealing to some students due to their brevity, which can be seen as clever or almost getting away with something.  That may motivate some, especially the lazy ones.  Others may just appreciate how elegant the solution is for it's open merit.
If someone wants to stick to older concepts that won't solve a new problem, they plain old won't solve the new problem. They can't stick, they either go forward with either new concept, or they fail out. This is why we reproduce the development of programming as it occurred: no one ever gets lost trudging along in the well-worn path. They never ask why something is better than something else: they know. 
Now that I'm under the tar and feathers, I'll explain. People like to find the easiest way, not the best way. Earlier postings reveal that you're in the teen-age world with your students, and they are no exception, if not the rule, to that thinking. Knowing that your students will have that natural preference for easy, use it as the motivation. "Quality is job one" makes a good slogan for a company, but isn't so good for motivation of students.
The key is that the new concept is not presented as better programming, better presentation, or even easier to maintain, update, or fix later. Rather it's presented as a real solution, to a real problem, right now that makes less work right now for them. Less time on coding, now, means more time, now, to be with their friends, or do other fun stuff. After a couple rounds of that, once the light bulb goes on, they'll start actively looking for pre-baked solutions, and libraries will be their next target. That outlook will carry them well into the future, and could even encourage them to look at new languages, either new to them, or new to the world, for an easy solution to a problem.
Challenge them with something they'll have to do once they're working -- give them some code that uses the technique you want to teach them, and have them make a change of some sort. Or show them code that DOESN'T use the technique, require some change to be made to it, with requirements (complexity, line count, whatever) that drive them towards the technique you want them to use.
Begin at the beginning, with things that could not be simpler or more obvious. Add one thing at a time, and show how it solves problems. Steam engine, gasoline engine, gas turbine, rocket. You just will never get to space with Jules Verne's coal-powered "rocket train".
For example I had an assignment where I spent a good chunk of time implementing my own (very flawed) version of a HashMap.  I have some the same thing for a TreeSet as well. 
I think some students will stick with Array and ArrayList until they are basically forced to not use them.  No matter how clever or elegant they could potentially be.  Fostering a culture that embraces failure may help overcome that.
Many of my peers will cling to an ArrayList no matter what the problem presents.  They are just comfortable with using it and prefer it over any other structure, even when that means a lot of extra code they have to write.
Borrowing from the world of sales, show the problem first, and the solution second. To progress from a bounded for towards a foreach, as an example, use the bounded version in a manner already natural to them that is possible, but problematic, against a collection that can be foreach-ed. Legitimately work out the checks and error traps and actually make it work. Once they've experience doing it that way, then you can present the "package" where someone did all that work, and more, when they created the foreach. All the traps, special conditions, etc., are handled, and all the work has been done, and debugged, for them.
I have found online interview prep sites have done the best at nudging me to use constructs I would have otherwise ignored.  Maybe sell them on the idea of interview prep? Can't use an Array for all of those, just flat won't work and that is a time you definitely want something to work!
As a student, I can say the appeal to my free time is pretty powerful motivation.  I have spent hours implementing features already present in a language only to feel foolish when I realized my folly. 
The same approach can be used to step-up to any progression you choose. Under the hood in any chosen language the new tool might not be implemented using the old one. At least not now. Still, that's how they came to be created in the first place - refinement on a common problem and its solution creates the shiny new practice which becomes a tool. That's how we got structured programming to begin with.
If you start with the most absolutely bone-simple programming concepts at the start, then as you introduce each more complex concept, it is obvious why it solves a problem that just could not be solved using the simpler stuff they already know: No number of separate variables will solve a problem that calls for arrays. No fixed size array will solve a problem that calls for expandable arrays, and so on.