Or if you run the main script in a pane, you can run one of the target scripts normally as a part of the main script after you start the other in another pane:
If ./blocking_script_1 exits soon enough, the window may be destroyed before other commands run; then they will not find the window and fail. Compare race condition. Few ideas:
As you can see the original flawed snippet suffers from possible race condition. When we try to fix it, new race conditions appear. This is common when working with tmux this way. tmux new-window â€¦ is a disposition for the tmux server, tmux here is just a client. After the client exits successfully, you can be sure a new window has been created, but you cannot really know what happens in it, on what stage, or if the window has not been already destroyed.
Instead of switching panes and then running blocking_script_1, it just sends the keystrokes required to execute it, followed by a carriage-return (Ctrl-M. aka Enter, or C-m).  Then it runs blocking_script_2 in the current pane (which hasn't changed, still pane -t1)
This can be generalized to more waits. Exactly one wait foo can defeat a race condition. More than one wait foo at a time creates yet another race condition.
Note any of the above commands that run ./blocking-script_2 actually runs a POSIX shell  (sh) in a pane. The shell interprets ./blocking-script_2. After the script exits, there shell exits. Some implementations of sh may be smart enough to detect they can exec to ./blocking-script_2 in the first place. One way in another after the script exits there is no process in the pane, so normally the pane gets destroyed.
The other answer advises send-keys to inject commands to other panes. This is cumbersome and not really reliable (e.g. you need to make sure there's an idle shell there, with empty command line).
Im trying to run 2 scripts in 2 different TMUX panes from a bash file. The problem is that they are all blocking, so once I execute a process from one pane, I can't move to the other pane to execute the other job.
The shell in the first pane will get blocked with tmux wait until after the main script configures the option. Then it doesn't matter how soon the first script exits.
You may find the -d option of new-window and split-window useful. It makes the newly created window/pane not become current. From now on in this answer if I need to make any new pane current, I will create all panes with -d and only finally select-window or select-pane once. This is to avoid mishaps when you paste any snippet in an interactive shell in tmux and tmux selects another pane before the whole snippet gets to the shell.
the next line will execute in the selected pane. This is not true. Even if your main script runs both scripts in the background, they will still run where the main script runs.
In your particular case running the main script in a shell inside tmux and targeting its window can guarantee the window exists. The first thing the script does should be setting remain-on-exit on.
My tests indicate that tmux wait -S foo never waits. When it's invoked, all waiting tmux wait foo are woken, they exit. But if there is no tmux wait foo waiting then the "waking power" is postponed and the next (future) tmux wait foo will not wait. This means both commands may be invoked in any order. If tmux wait foo exits then you can be sure tmux wait -S foo has occurred (just or in the past).
If you need to provide any arguments to blocking_script_1, wrap the entire command and all its args in double-quotes, or use \ to escape the spaces.  e.g.
If you want to utilize an existing pane then you need respawn-pane, possibly with -k to kill whatever runs in the target pane at the moment (in this case do not target the pane your main script runs in, unless it's the last thing the main script has to do).
Then I realized although I can run wait and wait -S in any order, this is not true for 2xwait and wait -S: