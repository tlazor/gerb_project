As I mentioned in the comments, check out networkx.  The source for their implementation of breadth first search is available in Github.
If I am understanding correctly, I see that node 0 is connected to nodes 2, 3, and 9.  Is that right?  My confusion is that node 9 is not connected to node 0.  Is this to avoid double-counting edges?  Or is this meant to represent a directed graph?  The output of your traversal routines makes me think that you want undirected graphs. 
Your definition of max_num_edges is confusing because it is somehow normalized to the number of nodes in the graph.  Is your definition equivalent to the density of a graph?  If so, I'd rename your variable to density or something similar.
Why is there are "internal" __ method required for IterateInDepth, but not for IterateInBreadth?  I'd expect more symmetry between the two implementations.
There is no native Python data structure really well suited to create a FIFO queue. There is deque in collections, but it is a little obscure language feature, and also not ideally suited, so I'm going to pass on using it. Your implementation using a list and removing items from the front will lead to a terrible worse case performance, probably quadratic in the number of nodes. At the cost of not releasing the memory early, I think it is better to never remove items from the queue, and use an indexing pointer.
Note that I'm keeping duplicate accounting on scheduled_nodes, both in fifo_queue and scheduled_nodes. This is to have the ordering of the FIFO queue and the fast membership check of a hash table. You could get rid of scheduled_nodes by checking against membership in fifo_queue, but you will again get quadratic performance, not a good thing.
I'm going to skip the making it a class part, but with graph being a dict-of-iterables, and the above points in mind, you could implement depth-first iteration as:
Note that, since we are using sets, the exact order of iteration over the connected nodes is implementation dependent, so a failure form the above tests doesn't necessarily mean that something is broken in the algorithm.
If I understand correctly, your graph is represented as a dictionary of connections, where the dictionary keys are node indices and the values are lists of node indices to which the keyed node is connected.  
Opinions will vary on whether my use of a global visited list is good, but it is faster than writing methods that return visited lists since only one list is modified in place and copies are not created.  It can make the code a bit trickier to digest, though.