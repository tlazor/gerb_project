It's very simple to use, fire and forget, and you are informed as soon there is a result, but the downfall is you cannot control individual bytes within the transfer. It also doesn't provide hooks for additional magic.
So the answer to your question is to forget about the python smbus package for this single special case and bitbang I²C and your special -LDAC signal — create the necessary high-low/low-high sequences on three arbitrary GPIOs by hand. You can do this e.g. with Joan's pigpio python library.
Please note I²C is an Open Drain communication bus. Both the SDA and SCL signal can be pulled to GND by both the host and the devices. To avoid short circuits between +3.3V on the host GPIO and GND in a device GPIO, you have to configure the host GPIOs as Open Drain, and use 1..10kΩ pullup resistors to +3.3V on SDA and SCL instead of actively pushing 3.3V into the bus. That's what the kernel driver also takes care of automatically, and what you had to configure by hand. To read from an Open Drain configured GPIO, simply output a "1" and read back what's on the bus line in reality.
The python smbus package uses the Linux kernel I²C driver to do I²C transfers. That driver provides a high level of abstraction and controls a whole I²C transfer of an arbitrary list of writes and reads to one or multiple I²C devices. It even controls I²C muxes automatically.