So all you need to do is multiply your initial velocity by the coefficient, negate this velocity (for it to travel in the opposite direction) and voila, you have your final velocity and if you keep doing this for every time it collides, you have your bouncing motion. This is assuming you have a flat plane that you want to bounce against, if you have a complex mesh you're colliding against, then instead of negating the vector, simply multiply it by the normal of the polygon you collide with (which is essentially what negation does on a flat plane).
Use some sort of position update function (Euler, Verlet or even RK4 - see this link) and it will make this task a lot easier.
The easiest way to implement it is to give your camera an initial velocity vector (call it u) and you want to find the final velocity vector after the camera has collided (lets call this v). Lets call the CoR e.
If you want bouncing then look into the Coefficient of Restitution. It's a value between 0 and 1 that represents the "bounciness" of the camera. A value of 0 means that no bouncing will occur when the object collides with the ground, and 1 means that the camera will bounce back up to it's original height after it has collided with the ground (in this scenario anyway).
If your movement should look a lot like your graph, you could make use of a bounce easing equation like this one (source):
Using a graphical equation will not help you apply natural looking accelerations to the system. You may be surprised to find how easy it would be to simply use basic Newtonian equations here. Give the object a little mass and momentum and let the force of gravity and Newton handle the accelerations & position changes. It's far easier than you may think