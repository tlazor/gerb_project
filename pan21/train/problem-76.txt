I sacrificed compile time safety and OOP style data hiding sure and I might need some kind of templating mechanism to define and check properties. But for now this approach works suprisingly well.
It's trivial to inspect, store and load the game state. Easy to extend and I can create new behavior entirely in script (I'm using python for scripting - great language btw). Components are only known in their respective subsystem.
An Entity consist of an unique id and a bag of keys and values (hash the key strings for ultimate performance ;-) ). Subsystems (e.g. physicsEngine, renderer) look for entities with property keys they can use and create components internally with the required behaviors. These components store the unique id of their entity and use it to read and modify the entities property values. You could even get rid of the entity class entirely, since it's only an id anyways and store the properties under the entity id in a global property store making the whole design more like a database.
Entities only contain a position vector and a set of components. A component contains a specific behavior and necessary data e.g. RenderComponent, PhysicsComponent etc.
Jason Gregory calls this Property Centric Archictecture in his book Game Engine Architecture. Thief and Deus Ex used this approach.
The data of an entity is closely entangled with the component functionality. Sooner or later a component needs to access and modify data stored in a different component type e.g. the MovementComponents needs to apply a force to the PhysicsComponents etc. So either directly access the other component via the entity, send an event causing the change in the other component or pull the needed value up into the entity. All bad solutions in my opinion.