In the above example the nonBusinessDays of the week are SATURDAY and FRIDAY, and 1st and 2nd of June are holidays. In that case, 3 business days from now is June 5th.
Lately, you should check if there are any holidays between the last and the first date. As, at the beginning, you don't know what the last and first days are, you first make the calculation between dates, then check if you have to add more days, and pass the add_business_days_no_holidays function.
Before it enters the while loop, we start at the previous day of the $startdate. This allows us to work on weekdays alone, since the very first line in the loop will always get the next weekday. The only comparison we need in the loop is if the weekdays fall under the given holidays or not.
I don't like the while loop either: when you'll have to add, maybe 60 days, is going to take a while, so I propose you take the problem form a different angle. Instead of working day per day using the while loop, calculate the total of days you have to add, according to the number of business days. 
A business week is five days, a normal week is 7, so, let transform the number of business days in normal weeks and days dividing by 5 and calculating the rest, and then multiply by 7 and add the rest days. Of course, you have to check if you finish on a weekend day, so, add days if you finish on a weekend day (You see this in add_business_days_no_holidays). 
The drag of the code is if you have a lot of holidays dates, but I suppose that you get them from a database, so you could check first what is the end date without holidays using add_business_days_no_holidays_function, retrieve from DDBB the holidays between the two dates, and then use add_business_days_function, passing the start_date and end_date, and avoiding the first add_business_days_no_holidays_function, as you passed it before. 
I propose a class, BusinessDayCalculator, which would handle all this logic in one place. Here's an example: