Next up is that I feel with your improved idea about how to create strategies is still wrong. Why would you create a set price for items then attach a sku to each of those prices. It is like you are switching your key and your value around. Now your entire system is indexed off of the price instead of the Sku.
There's another problem though. In reality, a single sku can only have one pricing strategy at a time, but this implementation doesn't do anything to prevent that from happening. Also, why does a pricing strategy need to know what Sku it's attached to? Answer: It doesn't. You only did this so the Cashier knew which strategy to apply to a Sku. Kill two birds with one stone. Remove Sku from IPricingStrategy and provide the Cashier with a Dictionary<Sku, IPricingStategy instead of a List<IPricingStrategy. 
Yes, your gut feeling is right. You should sterilize your Sku implementation idea, as it should never reproduce any offsprings. In addition structs in c# had more than a few gotchas. For example readonly on a struct field is a lie.
The validation isn't generally an extension method on string but you get my point. The validation starts cluttering up everywhere. 
and that is all the new things that I can see at this moment. You and everyone else covered the parts I wanted to talk about.
TestCaseData. I know you are using MSTest, but you've preached about using that ability from NUnit a few times. Not using it with the way you wrote your tests was like holding one hand behind your back while coding. Why? Even if MSTest doesn't support it you can write you test in such a way that at least gets rid of the duplicate code. (just saw another typo Cashier_TwoC_Is20.. should be Cashier_TwoC_Is40) So you could delete all your other methods and replace it with just this one. And if you wanted your error code to be more specific you could change the assert part to check for a "error string"
Yes. However note that testing first starts bottom-up, meaning you only use tested components and build upon them. In short this means not only you should do that, but you should do that before you start using specific strategies. 
The same thing will happen with Sku if you're not careful. Let's pretend that a Sku is a string of length 1-15 containing only letters and numbers and the character '-'.
Now you could easily create a couple of classes to grab all of the strategies from a database, grab all of the strategy to sku mappings, and create this dictionary to pass off to the Cashier every day.
Notice that the explicit operator can throw as not all strings are valid Skus but the implicit operator can't because all Skus are valid strings.
The strategy pattern was a great choice. You went wrong when you decided to use abstract base classes and ended up with child classes that look like this.
I would rather this were a class than a struct because a 15 char string is higher than MS guidelines for struct size.
Alternative would be to use BigInteger with "/100" on implemented internally, removing slightest chance of roundoff errors.
Just what would happen if the customer wants to purchase an item that there's no IPricingStrategy for? You'll give it away for free! You should take precautions to make sure this doesn't happen.
I also see that you are hung up on having a pricing strategy for every product. And although you could do this it doesn't make much sense in the market world. The old adage "Everything has a price" comes into play on this one. From a cash registers standpoint all SKUs have a price. That should be part of your struct. However, even struct is a poor choice IMO. Struct should be able to describe a value in the end. Instead a SKU and a price is closer to key value pair. What's more, and I'm sure all store owners would agree, I wouldn't want to be able to enter in a product into my database without giving it a price, yet by default you can, and you do as is shown in your test with var products = new List<Sku>() { 'E', 'E' }; 
Well done. It's exactly the sort of thing that should be encapsulated, it's an important domain entity in this line of business. In Domain Driven Design (and other books/blogs/authors) the concept of "primitive obsession" is often raised.
This guarantees the cashier only gets one strategy per sku and gives you the memory benefit of only needing different pricing strategies where the pricing strategy is actually different.
In either case the should come from a db, feed or even text file and not be hardcoded. Like this you need to recompile/redeploy each time a new strategy is created *(even if C# 6 has Roslyn).
That's insane. Insane. These values should be specified by the client code. This is exactly what constructors are for. Don't get so caught up in new syntax sugar that you write badly designed code. Make the SaleStrategy class a regular (non-abstract) class and give it a constructor that takes in these values. Also, while you're at it, do you really think that you're only ever going to have one sale strategy? No, you're going to have all kinds of different pricing strategies for items on sale, Buy One Get One, X% off, etc. So, give this one a better name.
Back to using a struct for a SKU. You can simplify your Equals methods greatly by implementing IEquatable<Sku>. By doing so you can easily see a that checking for null is not needed.
but that results in a compile error because structs can't be null! which means that by you checking for null you are wasting cycles. so delete your null checks and cast the object as a Sku leaving you with 
Now to address the final part of the system that both this and the other systems missed. Are you telling me that the ONLY way to put in discounts into the system is to rebuild and redeploy your entire checkout process???? that to me seems more absurd than having to write out individual pricing strategies for each sku.
Now you're free to create as many pricing strategies as you need. Maybe your store wants to offer a "Buy 5 Get One Free" sale, or a "Buy One Get One" offer. You can do that without modifying any existing classes. Everything is closed to modification at this point.
Some discounts in real world are multiplicative, some additive others just apply highest one and for some they apply if 2 or more different items are bought together. It seems harder to implement.