If you're doing this because you want to expost knuth function only, put your functions in a module and export only the functions you want to expose. Something like this : module Homework2 ( knuth ) where. 
I can see two possible ways to speed it up.  You use exp in the definition of costs, which is more expensive than the 2 multiplications required for cubing suggested in the article.  Also, the calculation of extras doesn't stop after it's impossible.  Since after finding that words i through j won't fit, all of the rest of them won't fit either, you could avoid calculating everything after the first negative number.  If you have 500 words to wrap and an 80 column limit, figuring out whether you can fit words 1 through 200 on a line is a waste of time.  
path j i = let (x, p) = c ! (i-1) in (lc ! (i, j) + x, i:p) is also hard to read, mostly because of naming.  It uses 6 names, of which lc is the only one with more than one character, and only i and j have obvious meanings.  I'm going to call x costSoFar and p pathSoFar.  I'm also going to change the let into a where and break it into 2 lines.
You spend a lot of effort making lists which have to match up to arrays.  This is harder to follow than defining each array element with a function (which is possible for these arrays), and it sets you up for off-by-one errors if you're not careful.  
The names c and lc are horrible, these arrays are central to the algorithm, and their definitions take up most of the function, but there is nothing to tell us what they are in the program.  The linked article says that the c array represents cumulative costs, and lc[i][j] is the cost of a line containing words i through j, so I would suggest the names cumulativeCost and lineCost.  However, the c in your program also adds the p array from the article, so cumulativeCost doesn't quite cover it.  cumulativeCostAndPath is a bit long, but not too bad.  
Lack of comments, type information, and good naming makes this code much harder to read than it should be.  
With these name changes, the first confusing line of the program, (_:ixs) = reverse $ snd (c ! lls) becomes (_:ixs) = reverse $ getpath (cumulativeCostAndPath ! n).  
The costs function could use a comment explaining what each of the 3 possibilities means.  If extras were extracted to be its own array, it would allow costs to be rewritten more cleanly, as well as potentially simplifying the definition of lc.  Before figuring out the details of what's going on, that deep pipeline of functions was hard to reason about.  
And If you're doing this because you want to close over fixed inputs such as m, just don't. If you use consistent and/or meaningful names for common parameters then it won't be a problem. 
There is too much nesting in the code. Any function doing anything of interest should be top level. So it could be tested individually or developed in the REPL etc, but functions defined in where clauses cannot be tested. 
Also not I added i < j in the definition of lc, even it wouldn't give any performance benefits, but now I can be sure I will not be iterating on the cases (i>j), for which cost is trivially infinity, when defining c. Also I am now sure I won't be accessing lc!(j,i) instead of lc!(i,j), or similar typo or off-by-one errors.
Another cut-off strategy that can improve performance could be takeWhile (j - i < maxWordsPerLine). maxWordsPerLine = 1 + lineWidth/spaceWidth could be a safe bet. This strategy would decrease time complexity significantly for n >> maxWordsPerLine, from O(n^2) to O(n*maxWordsPerLine); though which is never the case IRL either. Of course, if your program would be run against n >> maxWordsPerLine, nXn monolithic array would not be the best data structure.
The definition of c is not compared to yours because the one above doesn't contain path building code.
Above c is dependent on the particular lc and above lc is dependent on the particular cost function only by accident; you can pass lc and cost in as parameters respectively... (The same is true for your knuth function: You shouldn't need to recompile it in order to use exp extra instead of extra^3 as cost. Also you should be able to run knuth with different cost functions and compare the results.)
with actual examples and with special emphasis on using the same language as your requirements (within technical limitations).
Another problem with the code is its opaqueness. Your code should speak the language of your requirements
lls is not descriptive, and the s at the end makes it sound like a list of something, when it's just a number.  Since n is not used for anything else, I'd go with that.  
This can be a very significant improvement for large n. If your function will be run against huge inputs (as is case with programming competitions). However IRL you word-wrap one paragraph at a time, where n~50. Another concern is now your implementation would be tied to this particular cost function again. Although it is safe to assume costs will never be more than (1/0), cost function shouldn't use Infinity to disallow any other kind of line break. You should put your assumption lc[i][j] == Infinity => lc[i-1][j] == Infinity in the documentation for c (which is another sign that c should take lc as a parameter).
First of all I agree with @MichaelShaw on most points. So I won't repeat the "use meaningful names and types" part, as he covered it well enough. I will also touch upon the problem I see with nesting; and on readability, I will second his comment
As for performance, you can do some cut off in the calculation of c[j]. I think this is also the improvements suggested by @MichaelShaw. But his wording 
Since we're only ever interested in either the cost or the path from cumulativeCostAndPath (though they're calculated together), I'd suggest getpath = snd and cumCost = fst as ways of being clearer about what you mean (you could also separate the pieces, but that would be more work).  
It is not obvious what extras is trying to do, even with the article as a reference.  It would be much easier to follow with a comment explaining the formula for extras[i][j] in the article, what extras is meant to represent, and mentioning that the scanl1 call in extras and the tails call in go interact to create the last term in extras.  
The problem with the naive implementation cost is that it takes \$O(n^3)\$ to fill its results in an array. But it can be optimized back to \$O(n^2)\$
suggests, even if it may not be what he means, "f i..j doesn't fit i..j+1 won't fit either", but that requires using mutable arrays I guess. Instead you should think "If i..j doesn't fit i-1..j won't fit either". And that means you should iterate is in decreasing order.