Is user type 3 a combination of types 1 and 2? I would expect to be able to do bitwise comparison of values with such a scheme. If you don’t intend this, I would modify 3 -> 4 (100). I’m a little unclear on your intention, so ignore this if I’m wrong. 
One of the projects I'm working on requires logging a huge amount of information (basically, every function call). The problem is obviously that logging a lot of information has a few side-effects, notably high disk-use (both IO's and amount); tends to require lookup-tables if you're trying to keep things small (i.e. an "integer to page" conversion, etc.); often isn't atomic, that is, concurrency can often become a high target-factor for threaded logging.
Ultimately though, I would consider pulling in a dependency on a serialization library like Protobuf. 
To fix some (most) of this, I've worked up a binary encoding for our logs. Basically, it allows us to store a huge amount of information in a tight format, and also allows us to do so atomically and without any concurrency issues. As a result, we can have high-performance logging that doesn't bog anything down. It has a small drawback: encoding of names and some values are "lossy", that is to say, we don't take the entire thing into account.
We can encode most of our data in less than 500 bytes, and much of it can be encoded in less than 200 bytes. By using the MD5 hash of the names / values, we can guarantee that there is not lookup or contention over storing them to any sort of "persistent" format, and it means we can build the lookup-table on-the-fly, so-to-speak. (We can store name + hash in the database, but it's no longer required for the logger to do it's job. We can fill it on a regular basis.) We use an MD5 hash for the speed, and the fact that, realistically, there are so few collisions on my use-case that it's not a big deal. Close counts, here.
At a quick glance, I could nitpick about how I think K&R (Java) style braces are cleaner for type definitions or that hex literals are better than binary literals, but that’s really my own personal preference. For an explanation on why hex is better than binary see this answer on a question of mine.
This shows us what the function writing a log would look like (the writeLogMessage part), and what reading a log looks like (the readLogMessage part).