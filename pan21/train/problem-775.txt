Whenever you want to delete an object, the factory pushes the object in a buffer that is cleared the next frame. Delayed destruction is very important in most scenarios.
Instead of queuing events in a buffer, queue up deletions in a buffer. Delayed-deletion has the potential to massively simplify the logic; you can actually free up memory at the end or beginning of a frame when you know nothing interesting is happening to your objects, and delete from absolutely anywhere.
(In this specific situation, my usual approach is to have the monster set a 'dead' flag on itself, and have the World object -- or something like it -- test for that 'dead' flag once per frame, removing those objects from its list of objects in the world, and either deleting it or returning it to a monster pool or whatever is appropriate.  At this time, the world also sends out notifications about the deletion, so other objects in the world know that the monster has stopped existing, and can drop any pointers to it that they might be holding.  The world does this at a safe time, when it knows that no objects are currently processing, so you don't have to worry about the stack unwinding to a point where the 'this' pointer points at freed memory.)
The events are not queued, they get dispatched immediately. This causes the Creeper object to get deleted somewhere inside the call to postEvent. Something like this:
Also consider sending all messages with a delay of one frame. There is only a couple of exceptions where you need to send immediately, that vast majority of cases however just 
One solution is to queue the events into a buffer and dispatch them later. Is that the common solution in C++ games? It feels like a bit of a hack, but that might just be because of my experience with other languages with different memory management practices.
Because the Creeper object gets deleted while the kamikaze method is still running, it will crash when it tries to access this->location().
In C++, is there a better general solution to this problem where an object accidentally deletes itself from inside one of its methods?
Deleting an object while one of its member functions is still on the stack is begging for trouble.  Any code architecture which results in that happening ("accidentally" or not) is objectively bad, is dangerous, and should be refactored immediately.  In this case, if your monster is going to be allowed to call 'World::handleEvent', do not, under any circumstances, delete the monster inside that function!
Let's say my game has a monster that can kamikaze explode on the player. Let's pick a name for this monster at random: a Creeper. So, the Creeper class has a method that looks something like this:
I would suggest implementing a factory that's used for all game object allocations in the game. So instead of calling new yourself, you would tell the factory to create something for you.