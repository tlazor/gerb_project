That saves you having to do indent calls to your stream.  You also may want to make the indent character (\t here) a constructor option.  
What would happen if writeString were called twice in a row?  Consider adding logic to auto-close the element only if one is open rather than every time writeString is called.  It should also check if it is currently in a context where a string can exist.  
OK, these two vectors (along with the count variables) are used to implement stacks.  Here's the thing though, why not just make them std::stack?  You can even have the stack implementation use std::vector as the storage medium.  That way, you don't have to worry about managing the stack variables as you do here.  
The exists function is useless and doesn't belong here. It should be replaced with a function error that checks whether an error has occurred.
You do three things to implement a pop operation on your stack.  If openTags was a stack variable, you could just say 
What you should be doing is to check if writeCloseTag is called when the stack is empty.  If you use the stack variable, this looks something like 
The pop() will trigger any resizes that may be necessary.  You don't have to manage the number of open tags yourself.  
This function must take two arguments: the name and the value of the attribute. Right now it is useless because the caller of the function must escape the strings and build the resulting string. This is exactly the thing your code should do.
I'm going to second guess a bunch of decisions that you made.  I don't know that you made them all incorrectly, but I think that alternatives deserve consideration.
It's possible that I've missed things, but this all looks pretty good. The things that I'd highlight are that you have functions that can fail that are returning void. So for your    
If I had these variables, I'd call these something like openTagCount and openElementCount respectively.  When I see a plural variable, I expect it to contain multiple things.  That is, I expect plurals to indicate collections.  These don't hold the open tags and elements, just the counts.  
I'd call this current_indent for readability.  Otherwise, one might guess that it reflects the overall indent rather than a value that changes over time.  
I'd make them either int or bool, depending on how you're feeling, and if you fail to open the file, or the file is already open, return a fail code, else return success, and have this in place of your cout << error message. If it turns out that there are enough cases where there's multiple reasons for failure, then you can return different error codes, so I'd lean towards an int return type.
The writeString function is even worse. I expect that I can pass arbitrary strings to that function and that your class still generates well-formed XML.
You should also consider what should happen if writeCloseTag and writeEndElementTag are called in the wrong order.  I don't see how your code would even notice.  Perhaps open tags and elements should share the same stack rather than having two different stacks.  Rather than storing them as strings, you could store them as objects of classes which extend the same class.  That way you could know what is supposed to come next.  
You shouldn't resize a std::vector by 1.  It's an expensive operation, so if you're going to do it, do it up large.  A typical expansion is more like 50% or 100%.  It's not evident that this program would need to make a vector smaller at all.  Either the stack is going to grow again or it will end and the entire data structure can be released.  
Why not make this an ostream instead?  Then you could output to things other than just a file.  An ofstream is a limiting choice here.  My quick read is that the best choice would be to have both an XmlWriter and an XmlWriterFile which extends it.  
This seems unlikely enough to not be checked.  You already check that the file opens in the open method.  It shouldn't close itself arbitrarily often enough that you would need to check it in each write function.  