Having said that, it took me several iterations and seeing good examples in the Unity demos to feel like I understood them properly. For now, go with what makes the most sense. But set aside some time to experiment with coroutines. 
Coroutines allow us to program objects as if they run on a separate thread ( but they don't. ) Using "yeild return" we can tell Unity to continue the execution of this method later.
I have to agree with Ben. You can do things in Update but once you start having to manage many different objects changing simultaneously it is much nicer to do it with CoRoutines.
We start out defining what scales we'd like to lerp between, then enter a loop. Here we scale using Vector3.Lerp and we increase the lerp fraction by the delta time / 2 ( so this takes place over two seconds. ) We use yield return null to tell Unity to come back next frame so the rest of the game isn't blocked. Do this until the object is fully scaled.
I find this much nicer and easier to understand than managing a bunch of state in the update method.
Coroutines are very useful for actions like these. When programming a game you've probably found yourself wishing each object was independent with the ability to do things over time without blocking other objects from executing. To achieve this normally, we'd need a new thread for each object that exists in the game world ( which is is impractical for several reasons. ) 