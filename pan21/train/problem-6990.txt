Also, if you are new to monad transformers, I recommend you stick to the transformers library whenever possible and try to use the mtl only sparingly.  This means using Control.Monad.Trans.Class instead of Control.Monad.Trans and Control.Monad.Trans.XXX for the monad transformers.  The need to manually lift things might seem off-putting at first, but you gain the ability to equationally reason about your code.  That might not seem like much to you now, but as you become a better Haskell programmer you will value that a lot more, so it's a good habit to build early on.
I'm trying to implement a lexer in Haskell. For easy console input and output, I've used an intermediate data type Transition Table.
I want to take input from the user for all the states and transitions. I do not want to take the total number of states before hand. I want it to keep taking input for the transitions of each state until the user types "--" . If the user types "---", the current state is discarded and the input terminates.
To understand the trick I use for breaking out of loops, I recommend you read this post explaining how you can use MaybeT and EitherT to easily break from loops on the fly the same way you would in an imperative language.
If you don't know very much about monad transformers, the best starting point is this paper.  Don't be put off by the fact that it's a paper.  It's written towards beginners and it's very readable and understandable.
The following is how I would actually write it in my own code, so you can compare the size of the code a fluent Haskell programmer writes and compare to your favorite language:
Also, note that I use the WriterT monad transformer to collect results.  WriterT commonly arises any time you need to fold or collect data interactively.
I want to also point out the nice forM_ combinator which you can use to mimic foreach in other languages.  I show it off in the pretty printer function to write code that is almost indistinguishable from the equivalent imperative code.
I use hSetBuffering to set the output buffering to auto-flush everything.  This is an alternative to writing your own putStr function.