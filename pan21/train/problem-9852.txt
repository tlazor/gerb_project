Alternately you could just override Load and handle Texture2D explicitly to do whatever you want. You could, for instance, call ReadAsset<ObfuscatedTexture2D>(...) and then construct a Texture2D instance yourself and return that.
Probably the ideal extension point for something like this is to inherit from ContentManager. Here is a blog post (for XNA) that explains how to use ReadAsset to change the caching policy (not what you want).
The solution I'd like to go for would be serializing the image files in a single wrapper object in the obfuscation code, and deserializing it when the game is loading. However, Content.Load<Texture2D>() will only take the asset name as parameter. Is there a workaround, or am I looking at this problem the wrong way?
I'm obfuscating spritesheets. I've already encrypted the .txt file dictionaries. Now I'd like to perform binary serialization on the image files. Texture2D does not allow for this though, probably because it's coupled to the ContentManager and by extension the Graphicsdevice.
What you probably want to do is inherit from ContentManager and override OpenStream. Then simply implement obfuscation at the stream level (ie: obfuscate the entire asset file).
If you're creating the texture yourself, you'll need a graphics device to load it onto. It can be accessed through the ContentManager.ServiceProvider property. Like so: