My recommendation is to make the ConfigurationLoader an internal class and have your thing doing the injecting manage one instance of it for the lifetime of the application. Does that work for you?
You can also add in the stuff to get default values but not sure whether this makes sense on an interface or perhaps as part of a ConfigurationStore base class.
I think a couple of Role interfaces would really help here. You need to do two things with your configuration
What led me to my recommendation was thinking about how to do unit testing. You have a tradeoff. On one hand, you can test the model much easier if you don't have to execute the ConfigurationLoader's SaveConfiguration every time by changing your code to inject an instance of it along with the markers in the model constructor and mocking the SaveConfiguration method. On the other hand, ConfigurationLoader ends up with behavior more indicative of an internal class and if you don't make internals visible to your test project you lose the granularity of being able to run tests directly on the methods.
I really disagree with the view model saving itself - it reminds me of active record (which I've never really liked). It gets the job done but I think your code would work better if the TodoListSettingsModel class was just a wrapper around some data and you had another service to have the responsibility of saving the model. This service would almost certainly depend on both IConfigurationReader and IConfigurationWriter.
Well, I'm convinced the model is the right place for saving the configuration. I think your cause for concern comes from the static nature of the ConfigurationLoader class, which I looked over and didn't see any design problems with.