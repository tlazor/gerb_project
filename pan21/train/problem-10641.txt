Having an Item component with a DoSomething() method where the healing ones just happen to heal whatever the target was for use is still entirely functional and they can look like whatever their rendering component wants them to and adhere to any usage flags that are general across all item components.
Do be wary of making a system that is 100% generic at the top (eg. a bunch of components, each doing absolutely anything) and 100% specific at the bottom (eg. specific components that the owner must understand in order to use in a very individual context). In trying to convert a generic 'use' action into specific 'heal this person in these ways' actions you can end up writing a whole domain-specific language in components. Personally I prefer much coarser-grained components to avoid needing to worry about all these architectural dilemmas, in exchange for accepting I can't have a fully data-driven design.
Through the public interface of the component base class. Don't over-think it -- that's a trap lots of people fall into with components. Designing them is no different than designing any other subsystem. If the interface of your item components is thus
I'd choose option 1. I don't see how this is tightly coupling mechanics at all - you can have your item Components all implement a Use() function which determines how they act when the item is used, but only the HealingComponent needs to actually do anything in that function. It will need to understand what the StatAffector components do and apply them.
Reducing components down to too fine of a level leaves you with the programming language you are working in, because at the end of the day the value to heal a stat with is actually just a small integer component.
Then that's all you should enforce -- and if you want to enforce other things, encode that into the interface as well. There is no need to, for example, enforce that Use implementations actually affect stats -- what if you wanted to make a "booby-trapped healing potion" that instead of healing anybody when used, set off a bunch of explosions? 
Having individual components for stat modification seems granular to an extreme, and is essentially taking you down the path of shoehorning your component composition system into a domain-specific scripting language. Rather, I might consider abandoning some of these overly-granular components for a simple "script" component instead, which simply executes some Python (or Lua, et cetera) code of the author's choice, passing an interface to a script API for the component/entity in question that allows it to do things like affect statistics or create explosions or whatever.
This is kind of a dangerous question, as Kylotan commented. Of the three options you've posted, the first sounds the most ideal to me based on how I've interpreted what you wrote (which may be wrong). However I would advocate in fact for an option you haven't listed when you actually have fewer components that accomplish a broader range of functionality.
I would actually caution you against breaking components down to that fine level of detail. This is always a hard judgement call as to where do you draw the line in breaking things into smaller components but, especially with items, smaller isn't always better.