It works fine, it does not store an auxiliary list, so it does not consume twice as much memory, like itertools.cycle. But I'm not sure about the possible caveats when it comes to handling attributes. And yeah, I had to implement iterator within the InfiniteList class itself, so I had to redirect the calls to iterator's methods (like __length_hint__) to the saved iterator self.it.
itertools.cycle is cool, but it has an internal "storage" that uses up memory. And I wanted to practice "tampering" with built-in methods of classes, which is a new field for me. I tried to implement a class which mostly behaves like a list, but when we try to iterate over it (with for loop, for example), it would jump back to the beginning when it reaches the end, therefore cycling indefinitely. Here's what I've come up with:
In short, unless you have a very specific use-case, most of the time your InfiniteList will have the exact same memory footprint than itertool.cycle with worse performances.
Is unnecessary. Not only it doesn't add any value over the default constructor of lists (which accept any iterable to initialize a list from it) but it prevent from building an empty list by using a constructor without argument, such as empty_list = list().
Contrary to __getattribute__, __getattr__ is only called if the lookup already failed. So you are assured that, if self.it has already been initialized, __getattr__ won't be called to access it. You also don't really need to store the iterator directly. You know that, given the use cases of your class, __getattr__ will most likely be called when trying to access an iterator method. You can thus build on that to create an iterator on demand and try to access its methods:
Building an InfiniteList out of an iterable will inevitably create memory to store the list and, as such, is no different from the memory used by itertools.cycle. Even building an InfiniteList out of an existing list will duplicate memory.
The only "advantage" being that you could build the list from scratch using append or extend and not use as much memory than itertools.cycle. However, such approaches are generally better handled using a list-comprehension or a generator expression. And feeding the generator expression to either itertools.cycle or InfiniteList will give the same memory footprint.
Is overly complicated as implementing __iter__ that returns self and having a __next__ method can be simplified to turning __iter__ into a generator most of the time: