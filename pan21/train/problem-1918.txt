-the ball is getting simulated independently all the time, which suits the simple ball physics of pong
This creates roughly 0.3 to 0.5 KByte/s of traffic at 60fps and the players have no lag in their perception, but only if the ping is below a certain threshold, because the balls new position needs to be transmitted.
UDP is generally the correct choice as well, certainly for any client/server model. TCP might be practical for a peer to peer game, but even then UDP might be a better choice. Basically, UDP handles less for you, which means more effort but also more control over how you deal with faults.
-if the ball flies past a paddle, the player who missed it contacts the other one with an increase score message and the ball is reset [TCP]
Each update interval have each client send its paddle position to either the server, or to each client (peer-peer). Have the server also send the ball position and a velocity vector. Each client can run the same screen drawing code as it does in single player so the movement of the ball will be smooth. In multiplayer though you have only the server send the position/velocity updates for the ball at a regular interval (and if you like each time it hits something).
-if one side hits the ball they decide about the balls new velocity and position and send that to the other one [TCP]
Have a configurable update interval (so you can tweak and try 5 packets per second or 20), and each frame see if it's time to send an update. You might be ok with a simple game sending packets for each event, but in a more complex game this isn't practical. Also keep in mind that there is a packet overhead so if you are sending a bunch of small packets you are going to waste bandwidth.
A pong clone is actually a bit tricky, because unlike most games you can't (as a developer) cheat by having one side see a hit and the other not.
For Pong the choice I would make is client/server, being that it is an action oriented game. One thing to note here, even though you say that one player "is the server", you are best off structuring your code such that they are essentially running a local server and connecting to it as a client.
Client updates should be limited as well, though one per frame will likely be far too much if your client is running at a decent frame rate.
Also cheating is easy with this system and there's a high possibility to go out of sync with a very lossy connection, but who cares about cheating in pong?!
Have the ball position updates reference a gametime across all clients so you can discard out of order packets and even make the interpolation of the balls position more accurate (you know the position and velocity at a specific time in the past so you can interpolate the new position).
The first decision to make in the network code for your game is whether you want a client/server setup of a peer to peer arrangement. Most games, with RTS probably being the only notable exception, are probably using a client/server architecture. The main advantage being that this arrangement is more fault tolerant and provides more control over what data each client receives. Peer to peer allows to send far less data, but requires each peer to fully simulate the world precisely as every other peer does. If one peer lags or desynchronizes, everyone must either wait for them to recover or they are simply lost.
With this model with a laggy game you might see the ball move backwards at times or jump around a bit. But with a decent connection it should be pretty smooth. 
If so, for fairness in synchronization you may want to make response somewhat laggy for the local player, or what most games do - let the player do whatever locally and then snap back if the server's result diverges from the locally simulated.
You definitely don't want to be "spamming" updates in any direction either. One update from the server per frame is all that is needed, and your server should be running at a fixed frame rate. What that is is up to you, but there is no need to go overboard. A 50ms frame (20 FPS) is plenty to get nice smooth game play. To keep things smooth on the client, you want to make use of interpolation. The client should be constantly transitioning between server frame snapshots, this could easily be the topic of a separate question though.
As for something generalized, one technique I've heard of but haven't found necessary (may be for action games though) is to keep actions with their true timestamps (receive time - ping/2), and have the server roll back (snap) if an earlier-time event comes in, and then reapply later actions. That way, everybody is consistent locally unless there is some conflict due to different players' interactions. The only danger is the ability to 'roll back time' if they fake a laggy connection.