Function #1 has a root within the interval, but the OP function bisection() fails because it does not check for a precondition of the bisection algorithm, namely that the function being evaluated is not non-zero and opposite signs at the interval endpoints.  If the preconditions are not met, either return a separate error code / error condition, or return NAN for the returned containing end points.
Function #2 has a root at 0.8, but the OP function bisection() erroneously reports it as being in the interval [0.0, 0.0625] because the expression f(a) * f(b) is equal to 0 due to floating point underflow.
Unless you know the bisection() function will be used only in rather protected circumstances, it is a good idea to check its input parameters early in the function.  Here is one example that passes the function f as a parameter, checks parameters for validity before continuing, avoids some other overflow exposures, avoids redundant calls to evaluate f (in case they are expensive) and returns an interval of length zero if an exact zero is found:
Function #3 has a root at 0.0, the end point.  Note that using a condition of (f(a) < 0.0) == (f(b) < 0.0) fails this test case if checking the endpoints for zero function values is not done before entering the loop.