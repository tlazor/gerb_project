It's that basic a mistake; you do not want to be responsible for finding out how else they turn out to have screwed up.
It's like a bank discovering that the company that prints the physical bills delivered several million bills all with the same sequence number, or a car manufacturer learning that the latest batch of license plates all had the same plate number on them. 
Seriously, a MAC address is absolutely fundamental to the way that the IEEE 802.3 networks work.  With multiple devices on the same physical bit of Ethernet cable with the same MAC, each receiver will respond with a "that's me" when an ARP packet flies by.
In their defense: This was the first networking product ever and R&D hadn't exactly thought the production ramifications through.  
(The application knows how long it normally takes to download and flash. It there is too much time between the first TFTP transfer and the upload of the confirmation file the operator is notified hat the device is probably faulty. Build-in quality test for the network stack.)
After that the device reboot, comes up with the full flash-image which does DHCP for it's ip-address. When the dhcp address is acquired it uploads a small file with it's own mac-addres to the TFTP server as confirmation that it is done.
PS. The DHCP server provides a custom DHCP option to identify itself to the device. In a customer LAN the DHCP will obviously NOT do that so when our devices see a "normal" DHCP server they just continue booting without attempting to upload the confirmation file.
Return the entire batch, demand your money back, and find someone competent to supply your networking hardware.
The PC controlling this runs a DHCP server and a TFTP server. And a control application that prepares the file with the mac-address.
So, yes, VLANs will do the trick.  However, you do need to grant unique layer 3 (IP) addresses to your devices, and this may be a challenge, as you won't be able to use DHCP.
So, basically:  when you put your devices with the same MAC address on the network, anything trying to talk to those devices is going to get confused when multiple devices say, "That's me!"  It sounds like you're trying to get around this with the VLANs, but... 
I'm serious. This isn't even an amateur hour mistake, this is dangerous levels of utter incompetence.
(Later it turned out we needed to do this anyway because after some bugfixes had been done by R&D each device needed new firmware to be flashed as well.)
After the device has successfully uploaded it's confirmation file the control-application gives the operator the thumbs up to plug in the next device and it writes the next mac-address to the file.
The standard firmware got a very basic minimal boot-loader that would boot a TCP/IP stack with a hardcoded fixed ip-address. This would startup and attempt to TFTP the full firmware image from another hardcoded ip-address. When done a second file containing the unique MAC would be pulled from the TFTP server and flashed in the device.
(If SystemA is in California and SystemB is in New York, it finds a route that sends the packet over to New York, and the router/switch connected to SystemB needs to know SystemB's MAC address so it can send the packet over.  So the MAC address is still being used, but SystemA doesn't need to know about that.  SystemA just needs to know the MAC address of its own router.)  
It had to be implemented anyway so we might as well use it to deal with the "how to get the initial config in there" issue.
Rather than tell you you're an idiot--even though you said it's okay--I'd rather tell you why you shouldn't put things with the same MAC on the same network.  
So, you have to maintain separate physical bits of wire.  You mention VLANs.  These operate in layer 2, which is the same place as Ethernet MAC addresses (albeit in the Logical Link Control, or LLC, sub-layer).
SystemA wants to talk to SystemB.  SystemA gets SystemB's IP address and tries to determine a route between the two of them.  If SystemA and SystemB are on the same network, SystemA needs SystemB's MAC address to send SystemB the packet.  SystemA gets this information with a broadcast ARP message and caches this information in the ARP table.  