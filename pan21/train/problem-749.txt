You might be able to make it much simpler if you reduce its applicability to POD types at which point you can go back to using things like memcpy and realloc for the implementation. However, if you do that, my request is that you do a static assertion to make sure that T, indeed, is a plain-old data type with trivial constructors and destuctors and post compiler errors if the collection is used against anything else.
However, it's fundamentally flawed. You can't erase elements like that from the middle and just leave them in the data array, try to destroy them at the time of removal, and then destroy them again when the container is destroyed. To avoid the linear-time removal of the data, you'll have to mark it some way or keep another data structure, like another vector of ints, like vector<int> m_FreeIndices;
I rolled an own vector-like construct with improved performance and got it reviewed. Here is the updated version.
As for whether you use vector or not to implement it, I actually don't care if you unit test this well and make sure it works in all possible cases, including edge cases, and that it does actually properly support non-POD types of T, properly invoking their constructors and destructors as needed, and being exception-safe.
If you do it this way, then in your destructor (and you need a manual destructor), you can sort the free indices and then skip over destroying the elements at the sorted freed indices which have already been freed in linear time. Shrinking can clear the free index array.
It's an interesting idea though you should not make the mistake of thinking this is a generalized improvement to vector whatsoever. To the contrary this is much more narrowly-applicable since it slows down the common case usage of vector for most people in favor of a rare case scenario where there are many insertions and removals from the middle or beginning. Nevertheless, it might be useful for some exotic cases.
The user Frank came up with the idea to implement my container by using stl_container, so that's what I did. The main problem comes with some big performance differences through different systems. Under a Ryzen 5 1600x CPU the performance of both implementations is close to equal, under an I7 6600U on the other hand, the std::vector<T> implementation is much slower.