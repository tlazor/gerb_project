In fact, I'm even more confused: PhoneNumber doesn't override ToString() or any of the identity methods (GetHashcode, Equals, operator==, etc). Why not?
Which prompts me to say: code to the interface, not the implementation. If a method can return IList<T> then that's preferable to returning List<T>.
This aggregation strategy lets you down (and so does your test suite) when I pass null for codeline. Instead of the ArgumentNullException or ParseException which I would expect, I get a NullReferenceException from Regex.Match.
Another issue I see with the aggregation strategy is that the code repeats itself a bit: TryParseInternal checks exceptions.Any() to decide how to handle the out parameter, and then its caller checks esr.Any() to decide how to handle the out parameter. If you are attached to the aggregation (I personally don't see the point) then this might be simpler if the inner method returned ParseException instead of List<Exception>.
I'm confused. The existence of TryParse tells me that there are important validity constraints on the number, but there's a public constructor which doesn't validate its arguments. It seems that I could easily make an instance of PhoneNumber for which Parse(phoneNumber.ToString()) doesn't round-trip.