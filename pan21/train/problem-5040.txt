The integer returned from componentProperties is a dense representation of the components properties in form of a bit list, that is each bit represents one boolean property. For example, if all properties are true, the resulting integer (in binary) would be 1111, if only hasOneChannel was true, the integer would be 1000 and so on. This has the advantage that you don't have to create a large amount of methods or classes, but still cleans up the inferCategoryID method quite nicely. The downside of this method is that it is arguably the most cryptic (while I also find the multiple-class approach relatively cryptic :D).
Here's an example of creating the mapping programatically.  It is for illustration purposes only, I don't recommend using it -- better to either put the map into a config file or a database.
Personally, I wouldn't use that approach, because of the amount of boilerplate code and complexity it introduces. Adding N+1 classes, where N is the number of conditions, just seems like overkill to me.
This doesn't seem like an improvement - there is still an if per case, and an extra jump for the for loop. It might be better to factor out parts of the ifs that are in common, giving something more like:
It doesn't remove any ifs, but the number of them that will be tested is now O(log n) instead of O(n), which is an improvement! The major downside is that this is a pain to read and mentally track the flow of, not to mention being more idiomatic of C-style programming.
Since I said that adding lots of classes introduces too much complexity to be really worth it (in this case), I can't say that the last solution is any different in terms of adding unnecessary complexity, so I probably wouldn't use either of them for the use case at hand. I just wanted to give you an idea of a different approach that, in my opinion, is preferable to creating a class per condition :)
I would do it just the way the video presented it. It gives very loose coupling to the classes and it provides extensibility without needing to later open a class and modify it. The 'single responsibility principle' is a great guideline for building robust and easy to maintain code and this methodology lends itself to the SRP well.
One value is what you want to return, the other value is the distinct value you get by using your 4 (5?) booleans as a bit pattern.
Last but not least, in cases where lots of boolean conditions are used, bit-lists are often applicable. The following code isn't tested, but it should give an idea of what I mean:
You basically have two values, that have a one to one coorespondences.  I would take advantage of that.
First off, I don't think that the method at hand must necessarily be refactored. I agree that is not a terribly "nice" method from a aesthetic point of view, but the amount of complexity it contains might not justify a refactor. Often, a bit of reformatting is already a good approach:
If that is not satisfactory, my next approach would've been to simply used separate methods for the conditions. This doesn't imply creating lots of classes, but still clean up the inferCategoryID substantially. While I'm not a fan of giving names like isCat24, I will use it here since the example refactoring technique using classes does so too and I can't infer more useful naming from the conditions: