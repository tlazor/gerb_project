The question did not specify that 62,570,250,000 needs to be stored as a direct number.  The first thing that could be done is to try square-rooting it, and seeing if the result is an integer.  The result is an integer, and so there is a perfectly valid solution available.  This solution successfully permits storing some numbers as large as 549,755,748,352 (which is equal to 8,388,607 * 65,536, a.k.a. 8,388,607 * (two raised to the 16th power)).  One of the numbers that this system can accurately represent is
The idea here is that there's no need to store "output" as a large number, when you know that this number can easily be represented as a power of two.  The value of 62,750,250,000 is effectively being stored, and the way it is represented is by storing a smaller number along with a power.  Essentially, we are storing data which, if combined with a known formula that we specified, allows us to store this particular number.  (This formula reasonably might end up being useful for storing other numbers, in a situation where people are often dealing with squared numbers.)
Using a technique similar to the common IEEE floating point assembly, these bits could get interpreted as:
I might have largely ignored the "using low and high" part of the question.  I wasn't very clear on just what the question is asking.  However, this system does use different bits for different purposes, and so that exponent section of the data could be considered "higher" bits than the other bits placed at a lower position.  So, the question "How can we represent this" is directly answered by the bold sentence, and explained further with the rest of this answer.
That's okay, though, because the question didn't require storing all possible smaller numbers.  The question simply wanted a way to represent the number 62,750,250,500.  That is perfectly doable.
The simple, straightforward answer to the question is: storing a smaller number along with a power.  That's the answer, condensed into a small number of words.  That answer probably requires some explanation, which is why I provide the remainder of this text.
Note that bits 2 through 8 and 10 through 14 are leading zeros.  That's 7+5=12 bits that aren't being very effective in this case.  If positive numbers are assumed, that's 13 bits that may be a bit ineffective/inefficient for this particular case, so there could be potential that these could be used differently.  (Remember earlier I said we needed 19 out of the 32 bits.  13+19=32.)
This was throwing off some of my calculations.  If we assume a typo, and correct for it, then I can provide this answer for 62,750,250,000.
Actually, this way of thinking is quite similar to how an x86 CPU (80387 and newer) keeps track of floating point numbers, using some bits as a Significand.
Note: This system is somewhat similar, but is NOT the same, as IEEE's floating point system which I've seen discussed in a University Assembly class focused on x86 Assembly.  Here is a hyperlink to an online converter for IEEE floating point which you could use for that system.  In that system, the bits for the exponent specify what power of 2 is used to multiply the remaining bits.  However, that doesn't fit this case, as 25,500 is not a power of two.  Trying to use IEEE's floating point system, we could find that 62,750,250,000 divided by 16 is 3,921,890,625.  So we could represent the number as 3,921,890,625 times (two raised to the fourth power).  Still, we would need 36-bits, which is larger than the 32-bits asked about (and larger than the 24 bits that Intel's coprocessors use for storing the non-exponent version of the number).