Basically, if the length is 0 or 1 return true. Then keep checking first and last index recursively. Another way could be basically reversing the number and checking if they are equal.
You don't want to find all pairs with a palindromic product, only the largest one. So you don't need to check pairs (i, j) where i*j is less than the largest palindrome that you found so far. But you can take even better advantage of this by checking large products first. And since the order of i and j doesn't matter, you can assume that i >= j. 
For your isPalindrome function, you can test different ways to find if a number is a palindrome. You could convert the number to a string and do a string palindrome test.
You could first look for palindromes >= 900,000 then for palindromes >= 800,000 etc. This has the advantage that you know which is the smallest digit, which makes the test faster. And smallest digit = 9 means i and j must both be odd. Last digit = 8 means j must be even if i is odd. Not that important for 3x3 digits, but assume you are asked to check for the largest palindrome from 8 digit numbers...
You could also make a bet that there is most likely a palindrome >= 800,000 and let largest = 800,000 initially. So you would multiply 999 only with numbers from 999 to 801, for example. This would likely be faster again; if it fails to find any palindrome you have to do the full solution. 
There are several improvements that can be made to answer this question. You could start your loop from the largest possible number which is 999 and come down to 100. Once a palindrome is found, you can break. This should increase your speed.