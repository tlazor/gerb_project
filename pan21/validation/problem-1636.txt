For instance, let's say you want to build some AI for the ghosts in Pacman. You want them to follow Pacman if they see him and stop following him when they lost sight of him. So, in a behavior tree:
I would tend to create a Scene object that all the various game states inherit from, and just create a variable called "currentScene" in the Main object. Then instead of a switch statement in the main loop, just call currentScene->Update(); each Scene would know what it specifically needs to do for input handling and rendering. To switch the game's state just switch which Scene is in currentScene.
Note that a lot of logic really should be common. There's little reason for each level to have its own input handling, since good non-irritating games generally have only one play style.  Of course exceptions abound, especially if you implement menus had a game state.  Even then, though, abstract things away: have a menu handler that runs for any active menu state, a gameplay handler for game play states, etc.
Why is that so significant? Because now you can blend between states. Now, if you want a Ghost to run a "scared" animation whenever he sees Pacman powered up, you simply evaluate the Ghost's "brain":
The first step really is to just move the contents of your switch statements to data files.  Level layouts and such should be in map files.  Special level logic can be moved to scripts, or at the veryeast moved off into their own functions/classes.  You can register these data files or C functions at startup with a level manager, and your switch statements then turn into m_CurrentLevel->update().
Bj√∂rn Knafla explains in very easy terms what is involved with this system. I'm currently implementing this on my internship. The advantage to a behavior tree is that you're making a decision instead of setting a state.
Have a look at the Boost Statechart library. I recently started using it after many years of trying out slightly different ways of implementing FSMs, and it's definitely my current favourite! There are some oddities that stop it from being perfect (see 'state' class vs. 'simple_state' for example), but it provides some very useful features, and allows you to write state machines that are far more compact and expressive than the equivalent switch-based code.
The trick is that the behavior tree gets evaluated every frame, but it only affects behavior. So, in the case of the Ghost AI, it only determines where to walk to, but it doesn't actually walk to anywhere.
Yes, there is also something called a behavior tree, which is used for AI. If you want to research them, I would suggest starting here: