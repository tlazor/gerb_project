An even more compact representation would be to interpret the list of player and box positions as an integer written in base B, where B is the number of passable tiles on the board, and store that integer.  For example, the number:
Of course, as noted in the other answers, in practice it's probably much more efficient to rewrite your solver algorithm to avoid the need to store quite so many versions of the board state to begin with.
encodes the board state (46;3,8,11,13,28,31) in base 56.  Using this encoding, no state of your example board can exceed the number 567−1 = 1,727,094,849,535, which can be stored in just 41 bits, saving a whole bit over the 6-bits-per-tile encoding.  Of course, it also slows down encoding and (especially) decoding even more.
Note that, to make comparing board positions simple, you'll want to always sort the positions of the boxes in some consistent (e.g. ascending) order.  That way, you won't need to worry about the same example position sometimes getting represented as, say, (46;28,3,11,31,8,13) instead.
The only way to solve Sokoban is to use BFS (breadth first search) search, or, if memory is a problem, iterated DFS (depth-first search).
A simple solution is to sequentially number the passable tiles (including the goals) on the board, and store the numbers of the tiles containing the player and each of the boxes.  For example, your example board state above could be represented as (46;3,8,11,13,28,31), where the first number is the tile number of the player and the remaining numbers are the tile numbers of the boxes, with the tiles numbered in top-down, left-to-right order starting from zero.
To answer your literal question, first note that a Sokoban board contains both fixed state (the positions of the walls and the goal squares) and mutable state (the positions of the player and the boxes).  For a solver, you should have only one copy of the fixed state.  Thus, no matter how inefficiently you store it, the space cost of the fixed state is negligible.  All you really need to worry about is compactly storing the mutable state.
This representation is still not quite the most compact one possible, since some numbers in the range from 0 to BN+1−1 correspond to invalid board states (with two boxes, or a box and the player, on the same tile) and others to non-canonical encodings (i.e. where the box positions are not listed in increasing order).  If you really wanted to squeeze things as tight as they'll get, you could encode the box and player positions using the combinatorial number system, and then also encode which of the N+1 positions is the player.  In principle, this would let you encode each board state using a number between 0 and (B choose N+1) × (N+1) − 1 inclusive, with each number in the range corresponding to a distinct valid (although not necessarily reachable) board state.  For your example board, with B = 56 and N = 6, the maximum possible state number using this optimal encoding works out to just 1,623,421,799, which fits in only 31 bits!*  But, of course, the encoding and the decoding would be even slower than with any of the other methods above.
If you use a single byte for each position, you can handle boards of up to 256 tiles, and only need N+1 bytes for a board with N boxes.  Using two bytes per position would let you have a board with up to 65536 passable tiles.  In general, unless you're really strapped for storage space, I'd recommend this format as the likely "sweet spot" between compactness and ease of access.
If you really need more space, you could always use a smaller number of bits per position.  For example, your example board only has 56 passable tiles, so six bits would be enough to encode each tile number, allowing you to squeeze the board state into 7 × 6 = 42 bits, or 5.25 bytes.  But this extra space saving will come at the cost of slower encoding and decoding.
*) The fact that the combinatorial encoding saves about 10 bits over the simple base 56 encoding isn't really that surprising, since there are 6! = 720 possible ways to shuffle the 6 boxes, and this number is pretty close to 210 = 1024.  So, compared to the optimal encoding, the base 56 system wastes about 10 bits redundantly encoding the order of the boxes.