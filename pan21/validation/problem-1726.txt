In addition, your code code use some documentation. There is a section about these so called documentation strings or docstrings for short in the style guide. They are basically short descriptions of what your functions do """enclosed in triple quotes""" immediately after def function_name(...): or class ClassName:. Especially if the code becomes even more complex you will be grateful for any hint your IDE can give you about the code you have written a month ago. Following the style as recommended in the Style Guide (and basically found everywhere in Python code) will allow not just Python's built-in help(...) to pick up your doc, but also most of the IDEs. This documentation might also be used to convey type information to the user.
The code itself has some serious tendency to do deep nesting. IIRC, the most extreme case was like ten (10!) levels deep. Your class also has a significant number of lines of code (around 600). Where about ~220 of them are the taken up by the parser of the daily bulletin. It might be worth to consider moving the whole bulletin parsing ouf of Inspector into a separate class which is then used by the Inspector.
The thing that caught my attention in the first place where all those _List and _Boolean suffixes on variable an function names. They are very, very uncommon to be seen in any serious Python code. Usually you would choose your variable name to be as explicit as possible about its content, but care less about the type. If you really wanted to use "typing", Python 3 now offers so called type hints as a "standard" way to convey type information to users and tools. So instead of def are_multi_lines_w_nations_Boolean(list): you would have def are_multi_lines_w_nations(list_: list) -> bool:. The keen observer will see that I also changed the parameter name from list to list_. This is because list is the typename of Python's built-in list type (think []). There are other names like this that should be avoided, e.g input, file, and open to name a few.
Note: I used a tuple because they are immutable. This prevents you from doing things like ALL_NATIONS[0] = "Foo".
A function that takes all of its input via arguments, and returns its output, without modifying any other state - a 'pure' function - is easier to understand and easier to (re)use. For example, compare check_documents_expiration_date() with is_document_expired(document, current_date): with the former, it's not immediately clear which documents it inspects, or against which expiry date. The latter clearly checks the given document against the given date. It's doing less, but can be used as a building block for other functions, or in small expressions like expired_documents = [doc for doc in documents if is_document_expired(doc, current_date)].
Parsing bulletins would be much easier with the help of a few well-chosen regular expressions. Consider creating a list of pattern-function tuples, such as ('Allow citizens of (?P<countries>.+)', allow_citizens), where allow_citizens is a function that takes a match object. You can fetch the countries with match.groups('countries'), which can then easily be split on comma's. Be sure to strip() leading and trailing spaces from each individual country name. Now, for each line in a bulletin, your receive_bulletin function would walk through this list, calling re.match for each pattern until it finds a match, which it passes on to the associated function. To handle the similarities between document and vaccination instructions, you could order the patterns from most to least specific, or use look behind assertions, or perform additional checks in the associated function.
The good news is: there are a lot of tools out there that can help you to keep a consistent style even in larger projects. They start at tools like flake8 and pylint which can basically perform style checking on your code. The next step are tools like yapf or black that can even auto-format your code while you write it. pylint or more specialised tools like mypy can also perform static code analysis to judge program complexity and look e.g. for type hints and the like.
Your overall style is quite good. You seem to follow most of the guidelines presented in the official Style Guide for Python Code (the infamous PEP8). However, there are a few things that might need a little tweaking.
Other than that, there is quite a bit of code repetition. Especially the list of nations is repeated a lot. You should put them into "constants" right at th beginning of the file and use them where appropriate, e.g.
It's probably easier to store document and vaccination requirements per country, rather than per document type. That means that once you know where someone is from, you immediately know which documents are required, instead of having to check every document type for the persons country.
Since this is a lot of code, this answer might expand over time or leave parts to other capable members of this community.
Another stylistic choice to take is how to format long lists and dictionaries in a consistent way. You have several:
There is quite a bit of repetition in the bulletin parsing code code.  For example, a check is made to see if "Accept citizens of" if in a line in four (4) different places. Each of the update_xxx functions loops over all the lines in the bulletin and checks to see if the line contains a certain word or phrase (e.g. 'Accept' or 'Wanted').  If it does match, then some action is taken. Because there are only a few different kinds of bulleting lines, this can be simplified to only loop over the lines once, like so:
In inspect, you're calling a lot of functions twice. First to see if the entrant should be detained or rejected, then again for the actual response. That's a waste of work. Just call these functions once and store their result in a local variable, then check that variable and return it if necessary.
Instead of iterating over the words in a line to see if they match a country name, it might be easier to iterate over the country names and see if they are in the line.  That way you don't have to handle 'United Federation' specially.
Most nested functions are reasonably named, which makes it easy to get an idea of what your code does. However, a lot of them depend on local state in their 'parent' function, which makes it difficult to understand how they work. There's also a fair amount of (almost) duplicated code and special-case handling that could be removed with more robust general-case code.
Choosing the right data structure can make a big difference in how simple or complex the code is.  For example, because self.actual_bulletin["allowed_nations"] is a list, you need to check to see if a nation is in the list before you add and delete it.  If you used a set() instead, that check would not be necessary, because set.add() and set.discard() will take care of that.  Similarly, if  vaccines_required_for_nation and entrant_has_vaccines are both sets, then vaccines_required_for_nation <= entrant_has_vaccines is False unless the entrant has the required vaccines.
For requirements, I would use a defaultdict, from the collections module, with the set function as default factory. This means you don't need to worry about initialization: you can just do required_documents[country].add(document) without having to check whether required_documents even contains that country key.
Inspector! Why did you allow Gregory Arstotzkaya, a Kolechian spy, into our glorious nation? Or Ilyana Dbrova, whose documents were perfect forgeries, except for a gender mismatch in her ID card? And why did you fail to apprehend Karl von Oskowitz?
That's all for now. Maybe I can spare some time tomorrow to talk a little bit more about some specific details.
However you choose, it's best to stick with one of them. Over time I have come to the conclusion that I like the last one best.