That said, a common trick to update a process' environment "from the outside" (and practically the only way) is to attach a debugger to the process and call the corresponding function that modifies the environment as seen by the program itself:
It doesn't even do that. It modifies the environment block of the child /bin/sh -c "export..." process that system() invokes, and the modifications are immediately lost – they do not propagate 'upwards' to the Python process either. (Check os.environ["PS1"] if in doubt. In fact, why aren't you setting os.environ directly?)
This will actually work with PS1 because Bash carries its own implementation of getenv() and putenv(), overriding the usual libc version. That custom implementation doesn't actually update environ, instead it updates the corresponding shell variable. Calling putenv("PS1=foo") through a debugger will therefore update the shell prompt.
(Besides that, Bash has a separate set of "shell variables". There's significant overlap between the two – environment variables are imported during shell startup, and shell variables can be marked for export to child environments – but the key point is that even if you update Bash's environment block "from the outside", it won't actually update the shell variable $PS1 that Bash really uses.)
But it's quite frankly a horrible solution to the real problem. If you want the shell prompt to always show the current IP address, just make the prompt itself check what the correct value is.
That's it. You don't need to go through all environment blocks to do this – each shell will automatically re-read the file the next time the prompt has to be displayed. For example:
Bash allows you to include literal expansions such as $var or even $(cmd) within $PS1, and they will be expanded every time the prompt is shown. For example (note the \$ being escaped):