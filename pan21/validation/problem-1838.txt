Remove __attribute__((always_inline)). Compilers these days are very good at optimizing, and overriding their decisions will almost never lead to better code. With these functions, the compiler will almost always inline them anyway, but there may be rare occasions when it determines that it is faster to produce code with function calls.
It is a programming error to remove more slots than actually exist in the data structure. This will be compiled out when optimizing, but may help find bugs while debugging.
Firstly, both peek and pop give the caller access to locations on the stack, rather than copying stack data back to a variable in the caller's scope.  This is not robust as the caller could easily stack something else and thereby overwrite these locations. 
Your new_stack function is odd to me; it doesn't allocate content, and in fact allocates an object on the heap whose size is known at runtime when it may be more appropriate to allocate it on the stack! I'd pass it more parameters than just element_size, and have a separate init_stack function that initializes a stack that is passed in by reference in case the stack structure is allocated on the stack instead of the heap.
Why add the parentheses in your macro constants? This provides no benefit and may cause typos to compile (e.g. (fabs MULTIPLIER - 5) / EXPANSION_AMOUNT; when you meant to write fabs(MULTIPLIER - 5) / EXPANSION_AMOUNT;).
You may want slots to be a derived value instead of a primary value, and instead store the size of the buffer in bytes. As it is,
Actually, I would rename all of the functions in this library; since C has no namespaces, function names in a library ought to have library-specific names: stack_new, stack_push, stack_pop, etc.