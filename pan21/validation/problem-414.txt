As far as how the zero vector would get passed to this function in the first place; the cross product of parallel vectors is zero. So, assuming you understand how to obtain the list of possible separating axes by finding every possible cross product between the object's edges, if any particular axis was obtained from the cross product of two edges that happen to be parallel (one edge from object A and one edge from object B,) it will be  the zero vector.
In plain English, this means that if you produce a zero vector from the cross product, there is no point testing that vector, and should skip it.
A better solution would be to zero test the vector outside that function, and also test it for being undefined. if either test is true, don't even call the function, and skip to the next axis to be tested.
This makes sense, as attempting to obtain penetration depth would produce a spurious minimum penetration axis.
Intuitively, the zero vector has no direction, and so can't be used to determine a line on which to project your vertices. The zero vector in this case could be thought of as a single point, and obviously the projection of anything on to that single point will only ever be that point, so all vertices projected on to that point can be said to yield segments that intersect.
Degenerate EE is the special case of either Edge-Vertex (EV) or Vertex-Edge (VE), which in turn may be a case of Vertex-Vertex(VV).
However, I still feel the code is incorrect, as there is no guarantee that the cross products will produce a "zero" vector, in the truest sense. the glm maths library, for example, will produce undefined results if two parallel vectors are crossed.