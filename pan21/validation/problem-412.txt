Altogether, the two sections of the regex itself make sure to match only a character that you've specified, followed by a line break.
The $1 replace statement (again, making sure to add a space afterwards) will take what we matched in the regex itself (the last character on that line that is followed by a line break) and place it back on the line (this is so that we don't remove the character as would otherwise happen without this statement). The space is simply there to make sure that when the lines are pulled together, the words are still distinct and don't merge together.
Finally, by using the parentheses around the grouping (which applies to all variations provided above), this value can be placed back into the string using the $1 placeholder, which is discussed further down.
The square brackets are used to essentially say "allow/disallow the following characters" (disallow is specified by adding the ^ character just after the opening square bracket). Square brackets also allow the above syntax of A-Z which, as you can expect, allows anything between the two provided values. 
([^.!?"]) will group any character that is not ., !, ? or ". If you actually wanted it to allow any alphanumeric character, you could change this to ([\w]), which will match any character from A to Z, either upper or lower case, any number, or an underscore (_). If you're really set on only allowing A to Z, you could use ([A-Za-z]).