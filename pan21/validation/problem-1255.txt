sweepline, you sort the objects by the X or Y coordinate of the center and then check the objects in the range point.x-maxRange, point.x+maxRange
You can also consider a grid-based approach. For each circle, add an entry to all the grid locations that the circle overlaps with pointing to the detector object. When an object is added or moves, determine which grid locations it interacts with, find the set of all detector circles registered with those grid locations, and signal them. If your world is particularly large, you can consider a hash-based sparse grid rather than a 2D array.
A BVH is just a tree of nodes containing one or more bounding volumes (e.g., circles/spheres) that are grouped together into a large bounding volume encompassing the children.
If all of your objects have the same range (say r), then the problem is to find all object centers which lie inside a given circle. In other words you can think of your original point (let's call this the target) as a circle of radius r centered at the target and your original circles (let's call them objects) as points, at their centers.
If you have different object ranges, I would suggest defining range buckets (e.g. close range, mid range, far range), and building different kd-trees for those buckets. The range search should be pessimistic, i.e. it should use the largest r in the bucket. You have to perform the search on the kd-trees of each bucket and consider the union of the results.
In this case you can build e.g. a kd-tree from the object centers. To find the set of object centers which lie inside the circle of radius r centered at the target (the query circle), you can traverse the kd-tree, and prune the subtrees which completely lie outside the query circle.
There are several ways to construct a BVH. Some are intended to produce optimal trees from a known set of objects while others can dynamically construct the BVH as objects are added, removed, moved, or resized (and this kind of dynamic BVH is probably what you need).
I need to store big number of object that every object have range, then I need to find objects that the point are in their range.
The classic resource that will cover this algorithm in detail (and many others) is [url=http://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323]Real-Time Collision Detection by Christer Ericson[/url]. Every game programmer should have a copy of this nearby for reference, IMO.