You are using the default member of the Range object. What's this? Using specifiedSheet.Range() or specifiedSheet.Cells(,) instead of specifiedSheet.Range().Value2. In the first you're implicitly using it to get the value of the cell, the second it's explicitly shown. You can see this in the Object Browser, shown by pressing F2 in the VBE. Making sure hidden members are shown and navigating to the Range class then to Default. The teal icon indicates it's the default member.
Private Function GetTruckInformationForRow(ByVal sourceSheet As Worksheet, ByVal checkNode As String) As Variant
    ReDim tempArray(LBound(checknodes) To UBound(checknodes), lowerBoundColumnTransfer To upperBoundColumnTransfer)
Private Function GetTruckInformation(ByVal sourceSheet As Worksheet, ByVal checknodes As Variant) As Variant
    Set populationArea = truckSheet.Cells(PR_row + 1, 1).Resize(UBound(truckInfo), UBound(truckInfo, 2))
In the Options dialog>Editor tab>Code Settings group>Require Variable Declaration ensure it has a check mark next to it.
Rewritten as topLeftCell.Resize(numberOfRows, 1). It uses the Range.Resize property to resize the range selection and get it in a single step. Instead of picking up 1, 5, 100, or 10,000 cells you get a single range object. Much faster.
These were caught after my refactoring with https://github.com/rubberduck-vba/Rubberduck, of which I'm a contributing member:
You can also create a specific function and return what it's named. This lets you break down the steps into small modular pieces. An example follows.
Taking all the above into consideration I came up with the below code. The variable names are descriptive and let you know what they are for. There are subs that are specialized to do one thing, and only that one thing.
Private Function GetNamesOfTrucksToCheck(ByVal firstTruckCell As Range, ByVal numberOfTrucks As Long) As Variant
Be sure to limiting the information that's provided to these function to only what it actually needs to know in order to achieve the task. This takes a bit of refactoring and examining what the code is or should be doing but in the long run helps clear things up a lot.
An example of this is the ambiguity it causes with named ranges. Is Range("Start.Nodes") scoped to the worksheet that is active or is it scoped to the workbook? I can't tell from the code itself. My refactoring is going to assume that they are scoped to a worksheet.
Your future-self will thank you for doing so. This mandates you declare any variables Dim foo as Long before you can use them anywhere in your code foo = 10. You will save yourself so much frustration by doing this.
You are missing Option Explicit at the top of your code module. Add it. From the menu Tools>Options to display the Options dialog.
You're using unqualified Ranges objects. This leads to a two-fold issue. First what is an unqualified Range? Range("Foo") instead of specifiedSheet.Range("Foo"). By not fully qualifying the sheet the range is using whatever-happens-to-be the ActiveSheet to get that Range. This is a problem because you then need to use Worksheet.Activate method to first activate the sheet then hope/pray/wish that another sheet doesn't get activated while your code is running. Activating a sheet is a liability and isn't needed.
When you have contiguous ranges that span multiple rows or columns don't pick up each one individually. Think of a bag marbles on the counter top and picking them up one at a time. That's what you're doing. Since you know the start and end rows you ---can--- should get the entire range all at once and store it in a variable. The example refactoring above shows just this. You originally had
If your curious why Value2 is used read up on TEXT vs VALUE vs VALUE2 â€“ Slow TEXT and how to avoid it by Charles Williams.
Application.WorksheetFunction.Transpose is used to transpose the array from a 2D array to a 1D array. Where this function is used you provide arguments to the parameters.
As I'm not sure about your named ranges I assumed they were on specific sheets. If that's wrong and they're scoped to the workbook then ThisWorkbook.Range("foo") will get them working.
Comments should say why somethings done that way. The what should be apparent by using adequately descriptive names. This applies to all names whether they are for a variable, Function, Sub, etc. A clear name that states what it is, or is doing makes your code self-documenting. You have an example of this with your variables. Dim startRow as Long states that it is the start row. Then you also have q, k, j, s, nrows, etc. That's not helping readability at all.
You use underscores _ in variable names. This is the convention that you use when an object implements an interface done by using the Implements statement.
Your Sub statement for Sub Perform_Rating_Check() doesn't have an access modifier. Because of this it is implicitly public.
    namesOfTruckSToCheck = GetNamesOfTrucksToCheck(ratingSheet.Range("Start.Truck"), ratingSheet.Range("Num.Trucks").Value2)