The beauty of this is that it works on any number of items, and any amount of different items/colours.
While I basically agree with Nathan's answer, I wanted to emphasize that (a) another reason to find all the matches at once is for presentation purposes: it just looks better to blow them all up together â€” and in the more-than-one-dimensional case, it can be relevant because not all matches will stay matches after partial destruction (think of a plus shape on a 2d match-3), and (b) if this is like most match-3s, you'll probably need an outer-outer loop for handling the 'nested' matches that appear (imagine a situation like RGGGRR).  What's more, in the 1d case you can actually get by with a single loop through the interior and some careful tests.  My structure would look something like this:
This should find all the runs of 3 or more.  I wrote "mark elements for destruction" rather than "destroy elements" because it's simpler to find multiple runs this way, since you don't have to worry about the loop indices changing due to destroying a bunch of elements in the middle of iteration.  You can go back through in a second pass and actually destroy them.
I think this can be done amazingly easy with regular expressions (provided you can provide the gameboard as string).
Use two nested loops.  The outer one will loop over the array and will be treated as the beginning position for a possible run.  The inner will look for the end of the run by starting at the current beginning position and iterating as far as it can on the same color.
If it's possible to have more than one set of three at once in a single row (e.g. 3 reds then 3 blues), you'll have to run the loop multiple times until it doesn't destroy anything.