On Windows, moving to the same drive and partition will act just like Unix's mv command and rename the folder or change its parent. However, if you were to move it to another driver or partition, it would copy and delete file by file, hence why it is more efficient to use a tar file or a zip file with no compression to move files faster across partitions and hard drives. If you were to cancel it, it would simply stop where it is. I would believe the same is true for Unix but I did not experiment enough with it to be 100% sure. It is just a matter of changing the inode, but if it is on another partition or drive, then it needs to be copied to sectors on that partition or drive. If you were to cancel it during the transfer, it would already have moved some files, and the file that was being transferred will see it's destination file removed and the source file kept (transaction cancelled, but your original file still exists).
If you are using ACLs on the source filesystem, but not on the destination, mv on Linux will copy the source and then - because of the inability to set the ACLs on the destination - stop. So you end up having the file on both sides. The is no switch in mv to prevent that behaviour so in this case cp && rm is preferable.
In Windows, at least, move is simply a more automated Copy&Delete. I believe mv moves each file individually, meaning ^c-ing won't lose any files, you'll just end up with your files split between two places - unlike Windows Explorer, which will un-move everything when it cancels.
Update: If you were to cancel a move and wanted to resume it, just re-issue the order to move. It might warn you that the destination folder already exists, but the files will not be overwritten (unless they existed before the original move, or got added in between the two move orders) since as soon as they are transferred, they are deleted from the source (if on a different partition or drive).