The primary difference in performance is going to come from the fact that the googled code calls a subroutine to perform the comparison and your code performs the comparison in line.  To properly compare the two approaches, you should race your code against the googled code with inlined comparisons. 
Change Math.floor((beginning + end) / 2) to ((beginning + end) >> 1) means the same thing and is much quicker:
Your code won't generate a false negative as suggested by Brian; 'end' always points at an element that is considered greater than the value to be found (treating past the array as a logical element).
Your code can reference the element past the end of the array, however. E.g. If the length of the array is zero, you will dereference arr[0].  In javascript, this might be acceptable, but for a C programmer, it looks weird.
Apart from the use of parseInt, the performance difference between the different approaches is likely to depend most on the Javascript implementation.  
Honestly I've never been a fan of while(true).  In my opinion its best to put your main conditional there for readability and style.  Here is the version I wrote a while back for kicks, if it helps - my goal here was mostly fitting it in a tweet - but I beautified it for this example.  Notice I am using Math.floor instead of parseInt - my tests indicated Math.floor was about twice as fast when there was a .5, and just a tiny bit faster when done on an integer.  This version may look weird (the ternary upperbound is assigned to -2 when match found) but again it was a byte shaving experiment.