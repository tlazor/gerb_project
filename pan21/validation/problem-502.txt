Also you are mixing unique_ptr with raw pointers. Consider using weak_ptr or shared_ptr where necessary.
Note that std::unique_ptr<T>::operator bool() const is defined as returning true if there is an underlying object or false if get() would have returned nullptr.  This is used above to simplify the code.  Also, the passed parameter node is used within the function -- there is no need to declare and initialize another copy.  
Note that in this particular example, I've chosen to have a BinarySearchTree<std::string> instance instead of filling the tree with ints.
This code requires three #includes which are missing from the code and are required in order to compile.  They are:
The iterative_inorderVisit() function mentioned above would be more useful if it took a reference to a unary predicate.  That is, instead of hardwiring the printing routine into the function, why not let the user decide what to do for each member?  One could code that like this:
Why did you give your private methods the prefix private_ ? Looks code noise to me. Also these methods use cout. You should consider using an ostream-parameter (that may, or may not be defaulted to cout) instead. This way you could let the caller of the method decide whether he wants the output in a console, or a file, or sent to the international space station.
A binary search tree typically does not allow duplicate keys, but this implementation does not prevent us from adding duplicate values.  To maintain the uniqueness of keys, the code should refuse to allow adding a duplicate.
When a C++ program reaches the end of main the compiler will automatically generate code to return 0, so there is no reason to put return 0; explicitly at the end of main.
I rarely ever use nested classes, but your case here seems like it's worth an exception. This inner class is only used inside the outer class and has no sense whatsoever outside of the class. So making it an inner class seems like the way to go.
Many places in the code use raw pointers rather than the smart pointers already defined within the program.  As an example, consider this rewrite of iterative_inorderVisit:
One of your methods is called inorderVisit. Consider calling it visitInOrder as method names should generally start with a verb.
Also, it's a good idea to use size_t isntead of int for size, because it'll be more consistent with STL. What's more, you can implement some iterator-semantics, it'll benefit your check function too.
The size variable V is an odd and unintuitive name.  Similarly, checkBST is a member function, so the BST part of that name is implicit.  Instead, it could be check or maybe, verifySanity.  As others have mentioned, the private_ prefix for some of your member functions is not very useful either.
This uses a single pointer rather than two and also only uses the < operator.  This means that only that comparison operator needs to be defined for the T type.  Additionally, it returns a boolean value.  Given those, it is very easy to construct an insert: 
The insert function actually does two things.  First, it looks through the tree for the passed key, and then it adds the node.  It would probably make more sense to separate those into separate functions.  Here is a suggestion for how one might implement find:
First, use the more modern initializer style for the constructor, and second, use make_unique.  A revised form would look like this:
This find returns either a matching TreeNode (that is, an existing node which contains the searched-for val) or the TreeNode that is the last actual node searched before the search failed.  The next thing needed is a function to insert a value at a particular place in the tree: