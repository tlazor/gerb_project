I guess that instead of blending a bunch of transformed cosines (like the dot products in perlin noise give you), you could blend several monotonic functions that start at f(0)=0, like f(x) = x, or 2x, or x^2, etc.  In fact since your domain is limited to 0=>1 you could also blend in trig functions that fit the bill within that domain like cos(90*x+270).  To normalize your methods to end at 1, you can simply divide the weighted sum of these monotonic methods starting at f(0)=0 by f(1).  Something like this should be fairly easy to invert as well (which I gather you want from the bit about stateless real functions versus programming functions).
Thinking out loud, and admitting calculus is not my strong point... is this perhaps not possible? To avoid any obvious pattern, the average of the noise function over any change in x must be close to zero, and to guarantee monotonicity the amplitude of noise over that change in x must be smaller than the change in x, as any larger amplitude could result in a lower value at x' relative to x. But that would mean that as you reduce dx towards 0, such a function must also reduce dA (where A is amplitude) towards zero, meaning you get no contribution from any compliant noise function.
I can imagine it being possible to formulate a function that gradually decreases the noise contribution as x approaches 1, but that will give you a curved function that decelerates as x approaches 1, which is not what I think you want.
This can be extended to 2D by generating these values for both X and Y.  You can increase N to get any granularity you want.
The usual way of generating an increasing sequence of N random numbers from [0,1] is to generate N random numbers in any range, then divide them all by their total sum, then sum them one-at-a-time to get the sequence.
You can end up with a function that performs your animation on the fly, by making use of an uniform rand function. I know this isn't the exact mathematical formula, but there's actually no mathematical formula for a random function, and even if there were one, you'd be coding a lot to achieve this. 
Considering you didn't specify any smoothness conditions, the speed profile is $C^0$ continuous (but since you're not dealing with robots, no need to worry about discontinuous acceleration profiles).
In @teodron's similar answer, you cited efficiency concerns with large time-scales.  Without knowing the actual problem you're facing, I can't tell if that concern is valid; but another option would be to generate for small N, and simply smooth the result.  Depending on the application, this may actually give better results.