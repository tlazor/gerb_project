When your projects get bigger, a clear separation between individual parts of your code becomes more important. Reduce interdependency, limit the scope of your variables, keep things local and well contained. All this facilitates reasoning about and understanding of your code as well as debugging, testing individual parts, reuse and more.
The properties and methods needed to store and update a custom date are a good fit for a custom object type, a class.  
It is equally helpful to separate your model from the way it will later be represented on the screen. Formatting a date depends on the user's language and locale. Integrating a formatted date string into the user interface should be part of the view layer of your application.
You would start with modeling a simple date. A concise representation of a date is given by the seconds passed since 1888, similar to a Unix timestamp which counts the seconds passed since 1970. All other variables such as minute, hour, day, month or year can be computed from that timestamp, given we know how many seconds there are in a minute, hour, day and so on. 
  constructor(timestamp = 0, secondsPerMinute = 2, minutesPerHour = 60, hoursPerDay = 24, daysPerWeek = 7, daysPerMonth = 30, monthsPerYear = 12) {
Here is one possible way of encapsulating a custom date within a class and some formatting functions:
It is a good idea to hide the logic which derives these dependent variables from the timestamp behind getter and setter methods. This would allow you to e.g. introduce leap seconds later on without having to substantially change the interface of your date class and thereby the code which interacts with these dates.