For the best performance, we usually want indexes that have leading columns that match the predicates in a query.  For example, for a query like this:
Also note that if you include an ORDER BY clause in the query, then MySQL may be able to make use of an index to return the rows in the specified order using an index, and avoiding a "Using filesort" operation. To get that to happen, the leading columns in the index need to match the columns in the ORDER BY clause.
For this example query, if we had only indexes on each individual column, MySQL will (usually) use only one of the index columns (MySQL 5.0+ can do an index_merge operation, using more than one index, but this rarely performs better than an access plan that makes use of a more suitable index.)
If MySQL uses only one index, say it chooses in the index on the a column, then MySQL can identify every row that has a value 123 in column a using the index, and that works fine. But then every one of those rows needs to be looked up from the pages in the underlying table, and the other columns have to be checked, to determine whether the row needs to be returned or not.
In summary, usually, the addition of an index on each individual column is done without regard to the actual queries that are going to be run. On large tables, it's better than not having any index, and performance of some queries will be improved. But you also pay a price in performance for INSERT, UPDATE and DELETE operations, when those indexes need to be maintained, which is a lot of extra work (cpu, memory and disk) to maintain indexes that aren't useful.
(Obviously, you need an index on the primary key. You need an index on every set of columns you want to enforce a unique constraint on. And you want each foreign key column to be the leading column in an index.)
The equality predicates on a and c mean that we want to have those as leading columns, followed by b, so that a range scan can be done. By including the column d in the query, we can make it a "covering" index, so that the query can be satisfied from the index without a need for access (lookups) to the underlying data page.  (The choice for the leading column, whether a or c should come first for this particular query really depends on cardinality  (if there are only two possible values for a, half the rows with each of the values, and if the condition on a will match half the rows, but only 5% of the rows will satisfy the condition on c, then having c as the leading column would be preferred.)
For optimum performance, a much better approach is to actually examine the queries that need to run, and create indexes which are ideally suited to those queries.
If the index were instead on columns a and c, then MySQL can "do the check" on both of those columns, and have fewer rows to lookup from the pages in the table.
Creating a separate index on each individual column usually creates more indexes than are needed (and actually reduces performance). And when I run across that, I find that indexes that would actually improve performance are absent.