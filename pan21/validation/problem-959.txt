If this where C++ renderSprite would probably contain api specific calls (DirectX, OpenGL), but being a html5 game, it probably contains only canvas calls. Having a render system then is only a choice of code organization.
Now, in each of your entities, there is no need to make a call to its own special draw function because you have one generalized function. Simply call drawSprite and pass the proper arguments. 
To call these, you can pass your renderer object into your objects (polymorphic) "draw" function. Instead of the objects drawing themselves, they just pass off the relevant information into the renderer. What information that is, depends on the kind of object.
Consider refactoring your code so you have a more "templated" design. Rather than having all these different functions drawPlayer(), drawMonster, drawTree(), etc., consider analyzing the similarities between these functions and turning them into a single function. One way to do this is to store all the information that would be different per entity (position, sprite reference, rotation) in the entity itself. Then, you can have one function in your renderer that looks like this:
I've read that it's better to not let entities draw themselves but instead put all the drawing functions in the renderer. After coding for a bit, I realise that this does have its advantages. For instance, I can have a list of helper functions in my renderer system, like drawRotatedImage(), getSprite(), setFontSize(), plus the context variable etc.
Also if you have some object which doesn't need rendering (say it is a game-logic object), then you can just have it have a "noop" rendering method.
The Tree "class" then share the same prototype of the sprite "class" but define its own render method. In javascript this does not look so unnatural, I remember doing something like this:
A render system, if used, must be very generic. I don't think a method called renderATree() should be in the renderer. The sprite representing a tree must contain the data that you need to pass to a render generic function to produce a result that looks like a tree.
Also note that with the second approach sprites and entities are the same thing. I called them sprites because it was 2D game. In the first approach sprite was a "structure" that contains data for the renderer renderSprite function and a separate entity "class" that refers to a sprite was needed.
Also, how would i easily map the entity objects to their corresponding draw functions? Would i have to do an if (entity.type == 'monster') this.drawMonster(); else if (entity.type == 'tree') this.drawTree(); kind of thing?
If you still need a method like renderTree or renderMonster then I would make them part of the sprite or entity.
With some clever inheritance or composition, you should find yourself writing very little rendering code after you take care of this.
Edit: I'd also like to point out that this has the advantage of decoupling rendering code from entities. You may find this useful for drawing things out of the game's context, like rendering your main character's sprite next to the title at the main menu, or showing item graphics in an inventory.
We use render code separated from other game code with the intention of change graphic api at any time without having to touch anything except the renderer implementation. But, for html5, do we need this? Canvas is already all the multi platform it can be. The browsers are already responsible of implement the platform specific part.
When using the "Each sprite know how to render itself" approach a render system became unnecessary. Then I ended with a main loop that used functionality of the scene "class" to efficiently cull the scene and then loop through a sprite array representing the visible part of the scene calling each sprite render function. As sprites are allowed to contain render code, anything can be an sprite including a health bar that needs no image data and is renderer only with lines of different colors (easy done with canvas calls).
However, wouldn't this lead to a very bloated renderer class, with functions like drawTree(), drawMonster(), drawPlayer(), drawBall() or whatever entity?
It would appear that you're implementing this design pattern in a way that causes new issues. The good news is, you've observed the problems with your implementation!