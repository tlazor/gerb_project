In MySQL 5.5, InnoDB uses the system tablespace, which places all table data in a single OS file. This means that individual internal table data allocation, as well as handle management, happens inside MySQL (which is to say, completely in RAM as you have no swap space), with no assistance from the host OS (Ubuntu 12). 
If you're running this in Docker, make sure to also increase the memory you allow Docker to allocate from the default 2. I have mine set to 8 GB. Hope this helps someone.
The innodb_file_per_table option is enabled by default as of MySQL 5.6.6, so you'll have to enable it on your 5.5 server:
Not your issue, but I had this same problem and my issue was that innodb_buffer_pool_size was too large. I was running it inside Docker, and I had it set to 16G, which is how it's set in production, but Docker was killing it early because it was asking for too much memory. Lowering that setting to 6G fixed the issue.
This allows MySQL InnoDB to use more OS and disk resources for table management, hopefully reducing heap usage and memory management thrash.
You may want to start with either a clean install (no pre-existing table data), or at least shut down MySQL and delete the ibdata* and ib_log* files in your datadir, since MySQL will not convert existing tables to the per-file format. MySQL will rebuild the missing ib* files on startup, expect to see related error messages.
Using innodb_file_per_table, MySQL stores individual table files (.fmt and .ibd) in subdirectories of datadir, where each directory is a mysql table_schema. If you are putting all of the 30k tables into one schema/folder, you can have the same problem at the OS level, as Ubuntu tries to load the entire directory index into memory. If possible, organize your tables into several separate schema/folders, I would try to keep the number of tables per schema no greater than 1000. 