draw is not well laid out at all. Instead of just plain printing arguments, use str.format. That would make it easier to adjust how they're arranged, instead of just sticking with the default result of using print with commas. This is how you could do it:
9 in here is what's known as a 'magic number', that's a value that's used without making it clear why. Instead of 9, you should use len(board) so that it's obvious why it matters. If you don't want to call len each time, then set it as a value when you initialise board. Also testing for a in range(0, len(board)) is a bit silly, instead use 2 less than operators. Python allows you to compare three values at once, so you can do this:
You can also use all for this looped test. all will basically run a test on all elements of an iterator and return True if they all turn out to be True. Which is basically what you're doing with your count value. What you need to do is pass a generator expression to all. Generator expressions are like for loops but collapsed into a single expression. Here's how yours might look:
In check_board you're using for a in range(9) and then accessing board[a], but you could instead use for cell in board, where cell (or whatever you choose to name it) is now directly assigned to the value of each element of board. This is faster, easier and more idiomatic.
To explain, str.format will replace each {} with arguments passed to it. * is the unpacking operator, that means that all the values from board are being unpacked and passed. So you're actually passing the nine elements of the list, not the list itself.
Instead of board[n] == "X" or board[n] == "O" you can use board[n] in "XO". The in keyword tests for if a value is in a string, list or other collection. It's often an easier way of testing equality for multiple values.
Initialising board as containing integers that will then be replaced by strings is a bit off. You're mixing types needlessly when you could just make these strings. It has no functional difference but it's good to be in the mindset of keeping data consistent unless you have a good reason to deviate.
You could do 0 <= if you prefer, but I like using the same operator on both sides. Also a isn't a great name, consider using value or choice.
It's good you're doing rigorous input testing in choose_number. However it has 2 while True loops for no reason. Just having one does exactly the same job. Also you don't need to call continue in either of the places you've used it. In both cases one iteration is about to end and it will start a new iteration even if you remove those lines so they make no difference.
Instead of storing end then immediately using it once, just use the returned value from check_board directly. Also don't use == True. Just test if value, it's more idiomatic. If you want to explicitly test that it's a boolean then use is True instead.