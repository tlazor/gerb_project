You can show that by keeping the details of the internal state private, it is possible to swap out different implementations without needing to change the code that uses the data structure.
Given principle #1 (which I have not yet justified), we opt for the Point object.  So, before we continue with Rectangle, we go back and create a constructor for Point.
We are almost ready to blow everything up.  I go back to Geometry, create a Rectangle, and then... modify its area!
I give this lesson high marks, historically, for squelching both public instance variables, and de-facto public created by unfiltered getters and setters on the same variable. Instead, I have found that students generate much more thoughtful object designs.
.... right here, I stop, and ask the class how we should create our two points.  This is when I get to the Motivating Principle #1: it is the responsibility of an object to care for and ensure its own variables.  Which leads to the question: who should directly set the actual x and y values in each of the two points, the Point object, or the Rectangle?  
Students always default to wanting everything to be public, so I provide a motivating example for why this is a bad idea.  The entire set of steps is rather long, but I will create the setup and give a broad outline of how I proceed from there.
Looking at principle #1, we discover that, though the fault probably likes with Geometry, the real responsibility here lies with Rectangle.  This immediately motivates a series of cascading changes:
Many of the analogies in the answers so far can help students learn "how they work", but I wonder whether they break down at some point in explaining "when" to make something public or private, and therefore the "why".
My children and grandchildren, however, who live next door, think nothing of walking into the house and getting anything they like out of the refrigerator. In our house, the refrigerator is protected; my family can directly access it, but the general public cannot.
Not everything in our family is protected, though. My kids know that going upstairs, finding my Visa card, and charging a new book at Amazon, isn't permitted. My Visa card, and the contents of my wallet, are private. No one else can access them directly; they have to make a request."
What follows is a series of short Object-design tasks in which I tell them to sketch out, for a series of theoretical private instance variables, appropriate getters and setters.  After each one, we put a student's answer up and I let the kids discuss/critique/defend what is up on the projector.  This gives us a chance to practice our three principles together, and really drives the point home.
It is the reason that, from where I sit, Java is an excellent choice of second, or third language, for students that have already done enough programming to appreciate the need for data abstraction and information hiding, because they've tried to write fairly complex programs without those tools.      
And finally, I bring them to my Warning Principle #3: getters and setters are how we grant access to a shielded variable, but if you've created an unmodified (straight/unfiltered) getter and an unmodified setter on the same variable, you are doing it wrong, and you have just made a public variable.
Here's an analogy that I've used for several years, and that students seem to understand. It doesn't focus on the rules, but why we have public and private and protected.
I don't introduce package private and protected in the same lesson as private and public, because there are 3 principles that I want them to absorb that ultimately motivate the entire system.  My lesson introduces a few more ideas than just permissions (it's really how I get started with Ojects), but the key ideas of encapsulation also lie therein.  The lesson works roughly like this:
I next create a Geometry class into which I put my public static void main(String[] args).  I create a point, and show them how to use direct access of public variables: myPoint.x and myPoint.y.  At this point, we have basically created a struct.  When it comes time to print out a few of these points, I create a toString() 
It is, however, a poor choice of language to teach first, because it requires students to "accept on faith" many principles of OOP that they have no motivation, reason, or background to understand yet.
It becomes easier to see if you have an abstract data type such as a Dictionary with keys and values that allows insertion and deletion, where it can be implemented (internally) in many different ways: linked lists, hash tables, balanced lookup trees.
I am fully aware that this is an iconoclastic point of view, and "fighting words" for many of the OOP true believers.   I'm fully prepared for the backlash. :-)
In the follow-up discussion, we get to Motivating Principle #2: always provide the least permissions that you can get away with.  This is what prevents trouble, and helps Objects to guarantee their part of Principle 1.
But, of course, this is a much more sophisticated example.   It requires more understanding of "where we are headed down the road" then students are typically equipped to understand, or teachers are in a position to explain, if/when students encounter Java as a first programming language.
Before we resume this narrative, the astute reader will notice that the seeds of our destruction are already present in those public variables!
The fact that OO languages support public and private methods and data members is a crucial, important design choices.   
Unless this is an honors programming class, access modifiers may be difficult to understand. I usually start with public vs. private and provide a simple case. For example, it is usually a bad idea to make an instance variable public:
The problem here is that in this class, given that the getters and setters simply provide direct access to reading and writing a primitive value, it is very difficult to argue that they add any value.     To come up with a justification for why name and idNum are private, we have to use arguments that are not very convincing.
And to get a full, deep understanding of how OO programming works, it is crucial to understand both how they work, and when you'd want to use them, which is another way of explaining why they are in the language.
"Most of you know that I live down at the beach. If you find yourself riding past my house, and it's hot outside, you might come to my front door, knock and ask if you could have a soda. I don't live in a gated community, so anyone can come to my front door and knock. My front door is public. However, you can't open the front door, walk right in to my kitchen, open the refrigerator door, and help yourself to a soda! My refrigerator door is not public.