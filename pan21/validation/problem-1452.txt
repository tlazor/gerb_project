Before approaching, I find it works extremely well if the opening dialogue starts 'this is nothing personal, but...'. Psychologically, people think it's reverse psychology and thus terrible, but when you point to the code, this helps reinforce it's actually not.
I have always enjoyed the fact that as a programming teacher I have almost no need to invest time into building up authority (at least not when teaching young adults). Unlike many other fields we always have a computer at hand that will tell us about the mistakes we make, and as soon as we are talking about more complex topics like code design there is always an explanation why something is considered good or bad style.
Joey has a couple of choices here. He can consider you've got a fair point, and might go for it, or, better yet, Joey will present the list of arguments as to why he has it on a single line (maybe 'no-one else will see my code' or 'I'm doing a contest on fewest bytes used on code gold'). At which point you can either explain why not building it for other people in mind is bad, or concede there is a reasoning behind it.
The solution I found for myself is to avoid arbitrary rules. Don't tell students what they "have to do" unless they actually have to do it in order to get something to run. Otherwise they will immediately see that what you are telling them is factually wrong, since they didn't do it your way and it still runs, so apparently they didn't "have to do" it.
At which point you sidestep the approaching argument, and simply return to matter-of-fact and a clean exit:
My biggest victory in this regard was when I figured out how to teach about coding style.  I could not for the life of me figure out how to present it as something with intrinsic value.  The code that we worked on was all short enough that it hardly mattered, the kids were perfectly able to understand their own code, and my protestations aside, the kids couldn't see any good reason to put thought and effort into indentation, variable names, function names, clean organization, etc.
If it's not about code design but about things like architecture illustrate it with a reasonable change request that would be more difficult to implement with the "bad" architecture you want to argue against.
This is where real problems begin. It's not because Joey has made an error, but if he continues with the error, stuff will catch on fire, the world is going to end and goto loops will become fashionable again. As a result, you're required to put your foot down.
You can help reduce the sense of it being a personal failure (the main driver of being defensive) by either indicating it's a common problem or that it's a hard problem to spot. Joey might still get defensive, however: trick is to not rise to the argument.
As for the classroom context, I believe that the two most important things have already been said by Peter and Buffy: keep the focus on the code, not on the student, and make sure that you have a warm relationship with your students.
Instead try to illustrate the upsides and downsides of their solution and your alternative solution. In most cases it's easy to come up with a simple test that allows you to demonstrate the benefits of your suggestions. For example if it's about code design have the student rewrite a short paragraph according to your suggestions and then ask someone who doesn't know the code and wasn't involved in the conversation to summarize what the code does. Usually the improvement will be quite obvious.
How do you encourage students to benefit from code reviews you give them, rather than being discouraged or responding defensively?
Of course tests like these will fail sometimes and the "improved" code will not work better, but if that's the case and you don't see a flaw in the way your suggestions were implemented, then this may actually teach you that your advice isn't as powerful as you thought it was, and reflecting that to the students in a mature way will even improve the respect the students have, because you are demonstrating that it's not you against them, it's all of you against the hard facts.
If you want to be really hands off, there is one question that will get most people to reconsider a piece or line of code that doesn't require explanation:
I find some people hate being told what to do, and will spurn it even if it's the most logical choice. By alerting Joey to the problem, the solution, the reasons for that solution and the fact there might be other solutions, allows Joey to see the problem as an impersonal thing for him to solve (he didn't create the mem alloc error: he has to solve it), he has one known solution, and the freedom to research other unknown solutions.
Joey can either see your solution as the easiest, might devise his own solution (which might be surprising - as a student, he should be learning, not merely copying), or might just choose to ignore it, in which case he suffers the consequences (bonus points if you can create a scenario that causes the error), including any subsequent markdowns on program's performance.
This approach I find is excellent in team situations because the suggestions aren't forced, and it allows people to argue for/against a particular criticism. A dialogue occurs, instead of an argument.
The criticism should be kept short, matter-of-fact 'if this happens it will do this' (if this has no try-catch and it throws an exception, the stack is going to crash and the system will go boom). Explain what-why and how to fix it.
But for students getting something to run and do what they want it to is often a huge achievement, not just subjectively but also objectively. If the code doesn't do what they want they will be open for suggestions anyway, so this question will most likely be about situations where the student may argue that "it's working, so why bother listen to your advice?".
I outlined how I eventually solved that problem here.  By the time I finally had it sorted out, the kids started to see intrinsic value to clarity in their code, so the suggestions I gave to help them achieve that end were no longer met with resistance.
If your advice was good and you communicated it the right way the student will be proud that they were able to improve their code, since the whole demonstration revolved around the code the student rewrote and the reaction they got. You and your authority (i.e. the things that might trigger pride and make the student eager to prove you wrong) are out of the equation.
What little piece I would add would be that, given the above, if the things you are asking your students to do have self-apparent value, then the resistance never appears in the first place.  If they don't have self-apparent value, then asking the question "how can I make sure my students are receptive to what I have to say" is the wrong question, something more fundamental is missing in the presentation.
I think the first port of call would be to bring up the subject of handling criticism as a dedicated class session, including how to extract useful feedback from poor criticism, and how to make criticism (which they would be expected to do in the event of a code review, both reviewer and reviewee). They're adults, bring them on the level of both giving and receiving, and they should understand both sides.
On subjective criticisms, I find making 'speculative' recommendations passively works best, especially with reasoning listed. So say Joey forces all his code onto a single line, you'd say:
The result is that I don't see any need to express negativity in my code reviews. I know that good programmers will think of sub-optimal code as horrible mistakes, that's what drives us to improve our code constantly and not be fine with anything that works.
Feedback can be intrinsically threatening, and people are open to feedback only under the right conditions.  Here is an excellent article that discusses the psychology of feedback.  In their summary, feedback can be received when: