What I find helpful is to bring in (far) more fields than are needed in the first pass in order to clarify the relationships between the tables and also the cardinality of the result sets - then you pare it down to the minimum needed for your desired result - and if you run the SQL above on the tables below, you will find the orders whose status is as required. Try running the inner SQL statement on your the data and understand where the result is coming from...
Instead of trying to find all orders with invoices that are a) 'approved' and 'closed', or b) 'approved' or 'closed' ... just look for orders that have no invoices with a status other than 'approved' or 'closed':
I created a few tables using PostgreSQL (don't have a running MySQL instance), the basic concepts should be readily transferrable between the two.
I then ran a query which runs fine - you have to make sure you use a SELECT DISTINCT(...) FROM ... because the joining tables between orders and invoice have more records than those tables - naturally enough, order_line and invoice_line will have at least 1 record (and likely more) per order and invoice.
I "translated" your query so it would work with my tables (the only time I use a plural table name is for orders - everything else is singular) and I use table_name_id as my PRIMARY KEY, not just id - better for debugging - you know where the problem has come from! 
I had a look at this - the design of the system seems strange - why you have to go from orders-> order_lines -> invoice_lines -> invoices strikes me as strange. 
Your SQL gives the same result as mine - so I'm just wondering if there are fields and/or other issues with the schema as described? I don't see how (with my schema), you could possibly get any orders with a status other than 1 or 2 - which correspond to 'Accepted' and 'Closed' in my schema.
You should have a correspondance between invoices and orders. An extra level of complexity could be added by deliveries - with many orders being fulfilled by many deliveries, partial-billing based on fulfillment and various other factors.
You can just take the INSERT statements and CREATE TABLE statements out - the data is consistent! The SERIAL stuff won't work for MySQL obviously!