Obviously you don't need to shuffle the entire list. You can write your own partial Fisher-Yates shuffle (basically swap your choices to the head of the list), that stops once enough of the list is shuffled. This is definitely a good choice if you're going to do this for large collections of words with only a small list to choose.
You should create only a single instance of Random, and use that for all iterations of the loop, rather than creating a new instance of Random for every iteration. The reason is that Random's default constructor seeds its random number generator by the current system time, which on many platforms is updated infrequently enough that it will be the same for all iterations of the loop, causing you to draw the same random number many times.
Your choice of algorithm is nearly perfect as long as the number of elements selected is significantly smaller than the size of the wordlist (Otherwise, the number of duplicates starts to dominate the runtime, and you would be better off doing a partial sort on a copy of the array, as bowmore suggests).
If you don't care about it being a list but still want them in order, you could use a LinkedHashSet which maintains addition order.
Secondly your approach is ineffective for larger numbers, and especially if the number of words to choose is closer to the number of words available. The odds that a word is not already among the chosen words can become so small it can take a long time for your code to complete. Imagine picking 1.000.000 words in random order from a list of 1.000.000, getting the last word is a 1 in a million chance to get right.
While we are on the subject of redundant code, type parameters provided to a constructor can usually be inferred by the compiler, so there is no need to specify them.
A simple but more efficient approach is to shuffle the words and then just take the head of the list :
Next, advancing and rewinding the loop variable in different statements makes it needlessly hard to understand the loop. I'd find it clearer to only modify the variable in one place. Same for removing and readding the same word to the result list.
As a matter of style, it is redundant to compare a boolean with true. That is, whenever you find yourself writing expr == true, you might as well simply write expr, but it has exactly the same meaning.
By doing this you make it very clear that you're adding to a list that requires uniqueness until you reach a threshold. Then you can keep your List requirement by creating a new list from the set.