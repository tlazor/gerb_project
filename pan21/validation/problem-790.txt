This would, based on your table, presumably include the non-clustered index that's implementing your primary key. Imagine that you're performing a query against the table, and the primary key index is used. There's no way, having used this index, to find the remaining data for the table. So that couldn't possibly be the way things work.
I suppose this is a round-about way of asking: Is the nonclustered index's pointer back to the table based on the clustered index or the primary key? I assume the clustered index RID is what is used.
Since neither of these are a good fit, it's hopefully obvious why non-clustered indexes store the clustered index key, rather than anything else.
Every non-clustered index that isn't the primary key index stores the primary key. If the primary key index is non-clustered, then it contains some magical other value (e.g. the clustered key). But that then means, than any query that uses a non-clustered, non-primary key index must now perform twice as many index operations - once against it's own index, and a second one against the primary key index. And we'd also need two separate implementations of non-clustered indexes.
If the PK is a clustered PK, then the PK will be included in every index that you create, except for a unique nonclustered index.  If you need the PK column on the unique nonclustered index, then you will still need to include the column.
You can test this yourself by making two identical indexes, one with INCLUDE(ClusterKey) and one without, and compare the sizes.  They will be identical, even on hundreds of millions of rows.