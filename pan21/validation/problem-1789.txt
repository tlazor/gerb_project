It's definitely possible to add a deeper pass to do pixel vs. pixel tests after the AABB pass if you need it.
All of these reach the game and then use a simple quadtree-like space partition system to do their testing vs. one another.
What tool are you using for authoring your sprites? If you're using GIMP or Photoshop, you can easily have the artists paint hit areas as a separate named layer. You would then write a tool as part of your content pipeline to:
The artist/designer-facing tool, which aggregates all the sprites and a bunch of metadata, will help you with the collision box.  In automatic mode it will simply snap the collision box to the "outermost non-transparent pixels" in a given sprite frame.  In manual mode you can tweak the box however you like.  There's a "magic wand" button for snapping it back to the outermost non-transparent pixels again.
This may be much heavier than you need, but here's how we do it.  We stick to AABBs for simplicity...  (The terrain is more arbitrary than AABBs, but almost all objects stick to AABBs.  They might be bigger or smaller than the sprite, but it works quite well with some tuning!)
I would use an aabb-point test to single out which model(s) that I'm potentially hitting, and then do a pixel-test on those models. 
Each of these boxes is per-frame, per-animation.  If they don't change across an entire anim we only store them once with the first frame and a note that they repeat.
(Note: it's also useful to track a "reference point" for sprite placement -- you can treat your character coordinates as bottom-center, or maybe you're dealing with a button and you want to place based on the center of the sprite, etc...  Helps with setting up UIs and uniformity in moving characters around -- characters are usually hauled around by bottom-center.)
Of course, you could always have the artists export the layer manually to a standard file format that's easier for your tool to read, but we all know how artists love having manual processes forced down their throats :)
This info is exported into an intermediate xml-based format, and then baked by a subsequent tool into a binary format appropriate for the target platform.