It seems to me, that haystack_search is really at least three fundamentally different kinds of things, all rolled into one.
In my experience, when you want to kill threads, it's often easier and cleaner to just push some "tasks" that basically tell each thread to kill itself. In most cases, individual tasks should be small enough that it's all right to let a thread just finish a task once it's started it. In most cases this improves speed quite a bit--once it starts executing a task, the thread doesn't have to do any locking, access atomic variables, etc. It just executes the task until it's done.
Side note: chances are that with some testing, you'll find that std::list is a poor choice here. For a queue you usually want std::deque. For a stack, either std::deque or std::vector usually works quite nicely.
Anytime I see a lock_guard/unique_lock and an explicit unlock, I start to get worried. Unlocking should normally be handled automatically via RAII. That's the whole point of using a lock_guard/unique_lock in the first place. Sometimes you add a scope just for this, so something like this:
This particular one is handled by the previous suggestion to create a thread safe queue/stack, but there are still some that can be cleaned up this way.
I would start by separating "requests" into a separate thread-safe queue (or stack--I didn't check how you use it). A really simple version might look something like this:
The thread pool class should normally be (mostly) agnostic to the kind of task the threads are being asked to execute. In fact, it should normally be possible (and easy) to push several different kind of tasks into the thread pool simultaneously. A thread then basically just grabs a task from its input, executes the task, and repeats (along with a few bits and pieces like exiting at the right times and such). The thread pool manager is responsible for things like starting up threads, shutting down threads, and so on.