In C/C++, it could make sense to change long blockIds to an array of bytes/shorts/pointers, and remap each four-bit value in the table according to bits = 7 - bits.  I haven't profiled it, though, so packing everything into a long may still be faster.  Finally, in case of a non-zero air blockId, it's reordered so that in case of a large domain of blockIds, no overflow occurs.  Wouldn't happen in the code above, since I'm using ints to store blockIds which are bytes, but it's something to consider.
(To be 100% clear, I contribute this method to the public domain and waive liability according to the full license described here: http://unlicense.org/)
..and assuming that blockIds is a long whose bytes each correspond to a corner, from most to least significant, 0, 1, 4, 5, 3, 2, 7, and 6.  (In terms of inclinations XYZ, the ordered values are 000, 100, 010, 110, 001, 101, 011, and 111.)
UV mapping does look like the correct way to go with this. I believe this answers your first question (but I may be wrong). About why Blender won't UV map this for you is because it's trying to unwrap it as one giant lump-thing. You need to add seams to the model so that Blender can split it appropriately - look at Blender's Official Guide to UV Mapping to see how to do this.
So this doesn't provide details to every problem you'll encounter with your approach, but, if you want to map each vertex to the closest non-air voxel in order to scrape information from it (such as which texture to sample), here's a proof for the efficient method I came up with:
Here's my implementation in Java, assuming corners and edges are indexed as described in Paul Bourke's popular article (corner zero being -X -Y -Z):