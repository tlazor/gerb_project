Why is there an attr_reader :config?  Is it important to expose the configuration as part of the DockerDNS object's interface?  (For that matter, do #domain, #reversezone, etc. need to be exposed as well?)
That lazily constructs a Resolver the first time it is needed, and keeps the same object around for subsequent uses.
… but that method is not as useful as it could be.  What you really want is to simplify the resolver = Dnsruby::Resolver.new(dnsserver) calls that you have all over the place.  So, instead of #dnsserver, it would be better to have
In #run!, the Docker::Event.stream block needs to be indented another level.  The if event.status == … checks would be better written using a case expression.
When retrying after an error, it would be a good idea to add some delay.  Otherwise, you could be retrying an operation furiously and making a bad situation worse.
The error will show up on screen, but the rest of your program (#dnsAddOrUpdate) has no idea that anything went wrong, and proceeds happily with other operations.  I suggest just letting the exception propagate — perhaps all the way to the run loop.
Why does the constructor have @domain = domain, @reversezone = reversezone, etc.?  Only @ttl is ever used.  Furthermore, the call sequence feels backwards.  The job of the constructor is to initialize the object, as its name implies.  What you have done, rather, is partially construct the object (@config = config), then call a helper function (#ttl), which in turn calls the attr_reader (#config), to let the constructor cache the value in an instance variable (@ttl = …).  The simpler way would be: