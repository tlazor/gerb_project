Thirdly, by adding/changing goals, you add/remove features. In your case, you limit the input/output to a 100 characters by not having a while loop around the fgets(), and you introduce a possible case related to flushing of output buffers by using printf(). 
It's possible that the magic number (numerical constant rather than symbolic constant) 100 is a bad choice. Memory is allocated by word size which is always going to be a power of 2. Depending on the computer this can be either 4 bytes or 8 bytes (4 chars or 8 chars). It's not critical in this particular instance, but if the array is within a struct it could affect memory allocation.
It's a bad habit to declare all of the variables on one line. Each variable should be on it's own line to make it easier to find the declaration.
This program can be and probably should be expanded, it will only process a single line of text. The while loop you have in the program should be moved into a function that processes a single line of text, in the main program you should have a loop that reads lines until there are no more lines. A getchar() version of this program may not have this limitation.
Note I do not think this is a true trim, since you will still have at least one space at the start and end, I believe trim would remove all preceding and trailing spaces.
The answers by pgs and pacmaninbw has their good points regarding code style and issue with your code, so I'm going to follow up on the "possible duplicate issue" and your statement: "any thoughts on the baseline algorithm and how well I'm following best (syntactical) practices."
Secondly, although not a lot, your code requires more memory than the goal expresses. As the other (somewhat duplicated question) shows, there is almost no need to store anything besides the current character read, and a flag variable to indicate whether previous character was a space or not. Your code requires two 100 byte arrays and several looping characters. If this had been on a memory restricted device, it would have been catastrophic.
Skip checking if the input character is a space, instead check if it is NOT a space, if so, add it to the output and increment k.  This method would also allow you to do this trim in place, allowing you to drop having to use the output buffer (if desired).  
It's a bad practice to use single character variable names. using i, j, k etc. is a throwback to Fortran that allowed undeclared integer variables starting with those letters. Using meaningful variable names makes the code easier to read, understand and debug. It also reduces the number of comments necessary.
It has implemented a lot of functions such as isspace(), isdigit(), isalnum(), isupper(), islower(), toupper(), and tolower() as macros. This should be more portable than that the check you have for ' '.
Let me finish off by saying, that in general your code does look good with proper indentation and a good brace style. Maybe a little too much commenting on obvious stuff, but also some good and vital comments to what happens where in your code. 
(And if I remember correctly, if you're really unlucky you could get issues by combining fgets() and printf() which uses different system calls for reading and writing. Most likely not an issue in your case, as you use one for input and one for output... If however, you'd use fputs() and printf(), or fgets() and scanf() at the same time, you could end up on a heap of trouble.)
Given the current code you can't walk off the end of the array because fgets() terminates a line of code with '\0', that may not always be the case. Indexing past the end of the array can produce unknown results. A slightly safer version of the while loop is
When reading the exercise goal and your implementation I thought of two common principles applied to programming: the KISS principle, and Occam's Razor. Your code is overcomplicating the exercise goal, and implements stuff which are not required by the goal. In general, this is something one as a programmer should try to avoid. (NB! I do see that it is interesting as a learning experience, but you'd be surprised to see how many overengineered code solutions there exists in the real world)
So to summarize, overengineering a solution or extending it beyond the goal could be a bad thing to do. In your case, for learning purposes, it can learn you something else. I would however then have extended the goal beforehand, and emphasize why you've extended it and what your new goals are. For example, to read line by line stripping away extra spaces for a faster handling of larger input scenarios.
First of all, your solution adds side effects to the original goal. Your solution reequires a line to be ended, before outputting anything. If you type less than a 100 characters, or don't end it with return/line shift, it won't output anything.