There's an easy trick for half-up rounding when dealing with integer-casting in programs, the trick is to add a half-unit to the source value before doing any calculations, and then truncating the result as an integer. For example, to half-up round a float value n to an int, you do int(n + 0.5) You can use this in your code quite nicely.
I would also reverse the logic you have in your toDegrees function... convert everything to seconds (half-up rounded in int) and then extract the values from that. Note that you can express the location in total seconds, total minutes, and total degrees, and then get the "remainder" (modulo) to get just the incremental part:
Similarly, for the ToDecimal function, I would keep most of the calculation in integer space... Your code is not to bad, but can be improved:
The second issue is that the rounding is inaccurate if/when the location is something like 59.8, which your code will round-up to 60. This is a problem, because it should round up to 0, and the minutes should be increased (and, worse, if the minutes is 59, you need to round up the degrees... for example, rounding the value 8째59'59.8" should be 9째 0' 0" seconds - but your code gives 8째 59' 60")
There's two things in there, firstly, the comment is a lie ;-) The code does nothing with 8 or 9 decimals... it rounds "half-up".
Your code converts the float64 positions to 째'" in order to add an adjustment of minutes and seconds. There is no need to do that. Just have the adjustment in the format of a float64 and apply it directly. For example, for the seconds, have:
Your code relies on the global values lat and lon. These should be declared in a struct, and your methods should be on that struct:
You have a couple of bugs in your code which will crop up occasionally. The first I noticed is this: