Why does it not just return CreatedThreads.Count - 1 rather than iterating through the whole list? At that point there's no need for a method for it; Start can just do int currentIndex = CurrentThreads.Count - 1;
This doesn't actually work as intended. You're using the CancellationTokenSource as a bool to decide whether to re-invoke the callback. That's not stopping a thread; that is not re-invoking the callback when it returns. The only reason why it appears to work for you is:
So I did a simple class which does use one of the most performant and better alternative to Abort(). The class is named as CThread.cs which would stand for CleanThread.cs.
Since I want to make everything clean, I accept any suggestion to improve this, also small suggestions for the code to make me able to pass one, two or more parameters and for cross-threading too (the Control.CheckForIllegalCrossThread = false; alternative way - so using delegates with Invoke() or BeginInvoke()).
Finally I assume the only reason why you are calling Console methods in the CThread class is because you're using it for testing. Otherwise you definitely should not be doing that.
Well, as you can see I'm not able right now to start threads using multiple parameters, but I didn't need to pass parameter to my thread.
I was working on the last days with threads and I didn't want to use ugly methods like Abort(), etc.