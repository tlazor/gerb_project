I think using these kinds of protocols is a better approach than the less-scalable (and more discrete - what happens in edge boundaries?) local mesh concept.
Point (2) above is - in my opinion - the key here. As long as not all peers can affect each other immediately in the game world, having high latency between them is less of an issue. A FPS in a small arena is a poor candidate here, but a massively-multiplayer online game is a great candidate.
The main idea of gossip protocols is that each client sends a message to a small number of peers - let's say log(n) - and whenever a client receives a message it sends it against to log(n) peers. This creates redundancy (a client can receive a message more than once) which is good for reliability but bad for you - but on the other hand, this can lead to very fast broadcasts.
So, how do you choose which peers will be connected to which? What you want is to build a small world network (also called small world graph). You can find some algorithms used to create it (see Harari Graph), as well as algorithms that will allow you to change it on-the-fly according to user data (I recall something involving darknet which can change links according to location). I wouldn't just use a plain Harari Graph - instead, you're probably better off with a variation that takes super nodes into consideration, I'm just not familiar with any.
One idea, borrowed from distributed communication models, is to use a gossip-like approach. Gossip protocols are mostly concerned with scalability and reliability. The nice thing, however, is that they all use a very low bandwidth, which is crucial for P2P systems. The cost is latency, but read on, it might be solvable.