In modern C++, constexpr implies that the value can be derived at compile time, so anything that can be constexpr reduces to essentially zero runtime overhead.  That's a huge "win" for performance, so it should be something you strive for.
Note that as the array is constructed, each successive entry in the final version of the array is the answer for that size grid.  So we can use that by writing the answer function like so:
Use int when you need an integer type.  Use std::size_t/ptrdiff_t for sizes and indices.  If you need an integer type of fixed-size, use the appropriate type from <cstdint>. In every expression evaluated in the context of operator[], the result of the expression is converted to std::size_t for C-Arrays and the C++ containers.
If we think about the algorithm carefully, it's possible to do everything in a single array of length n rather than using an n x n grid.  Here's one way to do it in the constructor of the Grid class:
With this same basic algorithm, we can move almost all of the calculation to compile-time.  The way we can do that is to use constexpr and recursive templates to calculate values for all sizes at compile time and then the entire program reduces, effectively, to a runtime lookup in a static table.  I'll leave this final optimization step to you, but this compile-time sieve of Eratosthenes might inspire you and give you ideas on how to do that.
There will be a day that you or someone else is going to maintain some code, they'll open the file, and they'll see something like your code.  You can't unit-test main(). Whatever you have main() doing should be kept simple. Delegate to other functions and objects you can unit-test.
This is essentially the same algorithm, but reduced to a single in-place array.  More on that in the next suggestion.
The std::array is just as efficient as a plain C-style array, but has the considerable advantage that it can be used with all of the standard library algorithms.  In this case, it seems prudent to make a templated class, so the first few lines of the Grid class are these:
The printf function needs to evaluate the format string at runtime and then apply the result, while something like std::cout << n; already knows at compile time what kind of thing that n is.  The result is that the C++ version can be faster.  It's a common misconception that C++ iostream operations are slower than printf (measuring is the way to go!) but in this case, it's only used once, so it probably doesn't matter.
The at function will throw an exception if the index is out of bounds, so that that's one less consideration that we need to write code to handle (except perhaps at the caller's end).
If you want to be technically correct, indexes should be std::size_t. But unsigned works well enough if you know you're not going any higher than 20. unsigned short is useless except for storage, because any operations you do on it get promoted.
The effect of declaring short everywhere its used in this program is ... absolutely nothing!  The reason is that there are integral numeric promotions being applied to promote from a short to an int.
Since you're writing in C++, let's use objects!  In this case, we might wrap everything up into a Grid object and have a const function that returns the answer.  My rewrite on a 64-bit Linux machine has this for main:
Always initialize variables.  When you declare p, the values within ps extents are all indeterminate values until they are set.
Names are important and you should call things what they are.  Select names that provide context, denote relationships, and/or promotes understanding.  What is p?
Once again, once you've bought into unsigned short, you keep using it everywhere. But aside from the assignment, every single operation in this statement is promoting all your unsigned shorts to unsigned ints. Even the comparison. You might as well have just used unsigned from the start to save yourself a lot of typing:
But I don't understand why you chose to use unsigned short for all your indexing calculations. Any operations you try to do on it will automatically promote it to unsigned int. You're not really gaining anything.