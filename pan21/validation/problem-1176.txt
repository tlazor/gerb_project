But if you run them with &&  in between them, then if the first is an error, it won't run the second.  It's based on the idea of boolean algebra If A is true and B is true then A AND B is true.   So to find out if A and B are true, you could check A and B, or you could be "lazy" or efficient rather, and just check one and if it's false you know the whole expression is false. And if it's true then you have to check the one other.  So A && B  checks A and only checks B if it has to check B, so only checks B if B is true. But that boolean algebra concept is applied to commands, so it runs the first one, the first one might return an error or it might not, and if the first does return an error then it won't try running and checkin the second one,  and if the first one doesn't return an error then it will try to the second one.  No doubt the expression itself would return true(no error) if both are true and false(error) otherwise.
If you do dir asdfsss & blah   then it will run blah  regardless of whether the first command (dir sdsdf) returned an error or not.
The second command will only run if the first command was successful. i.e. if the first command didn't return an error.
If you did dir filethatexists && echo a   then you will see the first command runs successfully and then echo a runs.  Similarly echo a && echo b