On Nintendo and Sony hardware we sometimes polled the input at a higher rate than we drew frames; use a timer-driven thread to look at the controller I/O at 120hz, for example, even when we were rendering at 30hz. By "a timer-driven thread" I mean there was a hardware timer that poked an interrupt that caused a particular function to get called in realtime. On these system the controller appeared as memory-mapped I/O, so you'd simply load a word out of a particular memory location and that would have the position of the joystick's X-axis at that moment. You'd save that off somewhere in main memory, and then when your main game loop ran it would have a history of 4 or 8 or however many samples of input data at a consistent time interval. 
This wasn't to detect button-mashing, but to get crisp intraframe timing for fighting games where it mattered (because you were allowed to queue up inputs "before" a critical trigger frame in the animation, and the animation rate might not be as stable as we like, so we needed to distinguish whether you'd hit the button before the frame boundary or on it).
I don't know if it's possible with GFWL. DirectX's input system is pretty tightly bound to the render cycle, and there's a heck of a lot of operating system between you and the switches in the USB gamepad. 