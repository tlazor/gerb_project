One challenge I plan on assigning is to create a class to model a student in high school. What variables are essential? What are key methods for student behavior? What might be public or private? It is completely open-ended and will force students to begin thinking in an object-oriented manner. It will be less of code and more of computational thinking in the OO-context.
That said, I have found teaching with an "objects first" approach in Python to be helpful. Generally, one semester of CS leaves them less capable than a functions first approach. But in a second semester they pick up faster and are better off by the end.  They are much better object oriented thinkers.
While the syntax is important to teach, I see the introduction of objects as a great vehicle for "unplugged" activities that teach the object-oriented mindset.
My planned approach for AP CS A next year is to have students begin thinking about how to model the world around them using objects. Coming off a year of C programming, the jump to OOP is more a conceptual than a syntactical challenge. 
I think an easier, more natural motivator for objects is aggregate objects. This means you can approach discussion with encapsulation and reuse, and also decomposition of a problem.  A classic is a deck object containing card objects.
After students have explored java's string and math classes I introduce a group project called "Mathey".  Each group is to write as many math functions that they can think of and assemble them into their own class.  Students seem to like this and are very competitive in coming up with useful math functions and enjoy showing off their work and creativity when demonstrating their class to their peers.
After doing this, inheritance will become much clearer. It's one thing to have a Students class, but it is also valuable to create a class for each grade level and extend the superclass accordingly (or to have subclasses based on elementary, high school, college, grad school). The possibilities for design become endless, and effective program/software design can truly begin here.
This is still very tricky when you have strong programmers. You want to show how decomposition with objects makes the problem simpler, however, if they are very good procedural programmers it can be tough to have them see value.
I'm a big fan of using real-world data in as many class assignments in APCS A as possible.  Small example:  I was trying to prove to a group of people just how bad the weather had been in Denver in May 2015.  Bad meaning an abundance of precipitation.  Off I went to NOAA's website to gather weather precipitation data for Denver for all years on record.  Found an Excel file.  After cleaning it up a bit, I had two columns, one for date and one for units of precipitation.  Started to write a program to read that data in from the file.  I had a choice to make.  Would I want to create two parallel arrays - one for the dates and one for the units of precipitation?  Easy enough to do, but what if i accidentally sorted one array and not the other?  Then my data would be corrupt.  That brought me to my second option:  create a Weather object that has two fields, date and precipitation. That way I could create one array of Weather objects with no chance of the dates and units of precipitation going askew.  Simple example (no need for inheritance or polymorphism).  Powerful result.  