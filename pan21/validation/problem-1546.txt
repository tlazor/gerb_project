As simple interface the has the standard insert\update\delete and queryable methods. It is worth noting that I am referencing BaseEntity which is a simple entity with an public int Id { get; set; } property.
This is a simple Json text file that we can parse and load our settings (however I just did it manually in the example). Your implementation can be done any way. The important thing to note for the DataProvider.SqlServer the DataConnectionString is the database connection string and DataProvider.XmlFileStore is the root location to store the xml files.
Now the fun begins. Basically at this point we know our data access will be through the use of the generic interface IRepository<T>. We will use our ApplicationSettings class to dicate the provider and the connection string. From here we adapt our Unity Registration methods to register one instance of the other. 
The class above is really used to override the OnModelCreating method to add my Fluent configurations for entity mapping (out of scope here) and to Initialize my connection Factory. You will also note the ApplicationSettings constructor parameter.
This can get quite confusing however all we have to do is remeber our application will be using the interfaces to work with the data layer and not the actual implementation.
First off I am using the interface IRepository<T> to access the data layer. This can be connected database through EntityFramework or Xml through serialization. This repository is simple.
We will get to resolution and setup of Unity shortly but given this we now have a two generic data access repositories. One for EntityFramework and one for Xml File Store.
So far we have setup our Contexts and Repositories for access both connected databases (via EntityFramework) and Xml file storage. The next step is to put it together and register everything in our Unity container. This is where the application settings come in handy.
Now this is a very simple class that connects to my Data layer via entity framework. (We will talk about the constructor shortly).
Alternativly for the DataProvider.XmlFileStore type we register the dependency type XmlContext and then register the IRepository<T> dependency as XmlRepository<T>. Where XmlRepository<T> has the XmlContext dependency registered earlier.
Now for the XmlRepository has its own context that is used to load the xml files and save the entities to xml files. This is a very basic (not thread safe) example.
Now that we have gotten this far we can answer the question. Finally moving back up to the Main method we can now call _container.Resolve<IRepository<TestEntity>>() which regardless of our data storage type gives us the same common interface.
Now back to the EfRepository it has a constructor parameter DbContext dbContext this is required as we need access to the underlying data context and connections. Now this is actually an injected class of type EfDataContext which has an initializer and a few overloads (plus dependency injection).
So for your Unit of work you would resolve IUnityOfWork interface instead. Now here is a quick example I put together. It is by no means a finished or tested product (and the xml side is very fragile) but shows how this can work.
Following the strategy above and leveraging your IoC container all you need to rewrite is your IRepository<T> implementation to your different storage type. For example you could easily write a JSON serializer similar to the XmlRepository<T> and XmlContext. You could change your EfRepository<T> to directly call sql queries.
If the type is DataProvider.SqlServer we simply setup the EfDataContext with the Initialize() method and then register the DbContext dependency as EfDataContext (which requires the ApplicationSettings dependency already registered. Next we register the IRepository<T> dependency as EfRepository<T>. Where EfRepository<T> has the dependency DbContext which has been registered as EfDataContext.
What we are looking at is a long tutorial on Inversion of Control and dependency injection. Basically at the most simpilest form you will be looking to abstract your data layer from you application layer and provide interfaces for your IoC container to deliver to the application.
To walk through the RegisterContainer method we simply pass in the instance of the ApplicationSettings. We then register the instance of the ApplicationSettings (essentially a singleton). Next we then determine which type of provider we are going to load. 
This simple class uses the built in XmlSerializer to read\save files to disk by naming the files {Type.Name}.xml. You will also notice it has the ApplicationSettings constructor parameter.