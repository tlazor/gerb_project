If it is the latter that is not surprising. You are unlikely to be join and aggregation compatible. If you are doing something to trigger the movement through your update / delete then we could look at that - although a concrete example would be helpful.
That said, this could well be down to indexing. What is the actual code that you're running? Do you have indexes in place to help find those records you're expiring? You do still need to apply some of the standard tuning techniques of applying non-clustered indexes to rowstore tables. The fact that PDW doesn't support primary keys often seems to mean people forget to index their natural key, so don't find yourself in that boat...
Use CTAS against the dimension selecting only the rows you want to keep, union in any new rows and use CASE to pick up any changes (converting the UPDATE into a transform within the CTAS). Once complete you can then use a pair of RENAME OBJECT commands to switch from the current table to the new table. This gives you the added benefit of having a historic view of your table - which you can drop at your leisure.
Then, for the rows you need to delete or update, CTAS the entire partition into a new table, using LEFT JOIN and COALESCE to get the appropriate (i.e. new) values for updates from the changed rows while keeping the rows you want and excluding the ones you don't.
Are you saying that there is movement whilst you update and delete this table or did you just see movement when you changed the table from replicated to distributed? 