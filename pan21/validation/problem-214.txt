The way to generalize your for-loops is to determine what varies â€” namely, the number of days in each month and the day of the week that each month starts on.  Then, you want to extract the magic numbers into arrays so that your code is data-directed.
The second argument to findDay() does not make obvious sense.  Considering that January 2015 starts on a Thursday, why would you call findDay(jan, 0)?  I would expect something like findDay(jan, 4), give or take 1 depending on your numbering convention.  Better yet, make your numbering convention clearer by defining an enum.
You are, of course, doing this as a beginner's exercise.  I'd like to note, though, that you would not want to deploy this kind of code into production, since it hard-codes many magic numbers that make it work only for 2015.
When dealing with datetime issues, you'll always want to use a library, since the computations are always tedious and tricky to get right.  Here is a way to do it using the standard C library functions.  The part that actually performs the day-of-the-week lookup is the %A format specification in the call to strftime().  You need go back-and-forth between two representations of time: a struct tm (a structure which stores the year, month, day, day of the week, etc.) and a time_t (a count of seconds since 1970).
findDay() is misnamed and poorly designed.  It doesn't just return the result: it also prints it (with a leading space and a trailing newline!).  Printing the result limits your ability to ever reuse that function for anything else in the future.  (Normally, returning a string from a C function could be a tricky proposition.  In this case, you'll be returning constant strings, which is fine.)