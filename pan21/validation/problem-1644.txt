In user mode, the kernel maps memory where RAM starts at address 0 and it can only go as high as the amount of memory allocated to it.  The kernel controls the memory mapping of all processes and manages what memory is free and in use.  The kernel can pick free 4K byte pages from anywhere and arrange them so they look continuous to the user mode process.
Let's take 32-bit x86 CPUs as an example, simplifying a bit for illustration.  Some of the below is a little inaccurate on purpose to deliver the concept.
So while you have a 32-bit address space you can't just use all addresses willy-nilly under a user process unless something is mapped there.
You have 2 levels of execution - user mode and kernel mode.  Kernel mode needs to be identity mapped because it manages the system and other processes.
Now - if a process is dormant, the kernel may purposefully mark some pages as "bad" if it determines those pages haven't been accessed in a while, and write them to disk.  When the process wakes up, it will try to access these bad pages and trip a kernel exception.  Instead of "segfaulting" the kernel will retrieve the pages from disk, stick them back in memory (possibly in a different physical spot but mapped to the process's same logical spot) and then resume the process.  This is how a swap or page file fits into the mix.
The instructions that let you load and store memory will take 32-bit arguments.  So you have a "32 bit address" space.  This means you can "talk to" 4Gbytes worth of RAM or whatever else happens to be there.
The mapping mechanism can cause a "page fault" if the user mode page accesses an address that has an invalid page.  If the user mode application tries to access more memory than it has, it will hit "bad" pages and trip a kernel exception.  Then the kernel will kill it with a "Segmentation fault" error.  Kernel APIs allow the application to ask for more memory - the kernel will then map it some free memory if possible, and release it when it's done.
Both modern Windows and Linux kernels provide a facility called mmap where this mechanism is used "on purpose" to allow a file to be accessed like it's part of memory.  The user space process can pick an address to put it - and the kernel will respond to "faults" by loading in or writing the right parts of the file on the fly.  It uses this paging mechanism to allow that.  On 64-bit systems with a very wide address space, very large files can be accessed as though they were in memory, which simplifies some programs.
Virtual memory lets us map one address (a logical or virtual address) to another address (the physical, actual address).  The default state is "identity mapped" where each logical address is set to its virtual address.  Mapping happens on a 4KByte "page" level.