I'm facing exactly the same problem as you in a project now. The way I decided to tackle it is by having a "ColliderComponent" which holds the body from the physics engine. The bodys are defined externally (shape definitions which are loaded at runtime) and then added to the physics-world and to the game-entities they belong to.
So the thing that happens when a collision occurs is the following: The ColliderComponents which were part of the collision will send a message out to their owner-object (the game-entity) which in turn will broadcast that message to all its components.
I'm using Box2D where you can attach a "collision-listener" that will get notified by the collision. Since I add a pointer to my "ColliderComponent" to the bodys user-data, I can get my two ColliderComponents that were part of the collision. 
For 3D, Bullet is free (probably the best free one you can find). Havok and PhysX are famous for being used in lots of triple A Games.
Then in your collision component tell the collision system to cast a ray from point A to B and respond if it collided or not.
Every component can then react to that message, so your "health-component" could remove 5 points from health, etc.
Normally game engines use a 3rd party library to detect collisions between entities. In that scenario one creates or register those entities that have the PhysicsComponent into the "physics" world. And whenever it detects a collision between two entities (A and B), it would normally call a callback to entity A informing that it has collided against entity B and the same for entity B, informing that it has collided against entity A.