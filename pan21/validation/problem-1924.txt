removeNextPages is private since no other class needs to call this method. It is called from inside the addUrl method since that is the only time we ever want to remove any pages from our list.
First step: renaming the Model class to something different. My first thought would be something like BrowserHistoryBinding but this name is open for suggestions.
And now that I think about it, every time we change the URL we also want to update the forward and backward buttons. So why not put those inside the loadURL method instead?
Let's start at the top with the loadURL method. This method is only ever used inside this class, so we can make it private. Other classes probably shouldn't call this one directly anyway. We also encounter our first problem. Namely that we didn't provide a way to make the BrowserGUI actually show a certain URL. So let's start by adding that method to the Â´BrowserGUI` class:
Although static fields have their uses (strongly discouraged though) the i and j variables in the History class should not be static. Just remove the static modifier. (Note this breaks all references but we'll fix those later). A good example of static fields is when they are constants, these are also final and follow different naming conventions. (See the BLANK_PAGE constant in the example bellow). 
For that same reason your setFrame method should be renamed to initFrame since this method is used to initialise the frame on construction.
Now that we reduced the class to it's essential state, let's also look at what we need to provide to get information about this state and add new pages to the history.
The main difference is that I take a "view" as the GUI (in your case the Browser class). I have the History as the "model" (which in MVA is NOT coupled directly to the View). And finally I have some binding class that provides the coupling between a View and the Model (which I "wrongly" called the Controller and from which you probably got confused). So let's fix it while providing more tips to improve your design.
For simplicity's sake I just commented out the history.removefromList lines. You could provide a method in the history class to clear the history and call that one history.clearHistory() to achieve the same result as you got now.
First I must apologise for calling it MVC in my answer to your original question. After reading gervais.b's answer I realised that what I call "MVC" isn't the usual way to implement it. After some searching I found out that what I tried to explain is better known as MVA (model view adapter).
Finally there's the historyAction method where we get into a bit of trouble. Here we actually want to use the list of pages in the History but at the same time I told you that we don't want to make the state of any class public. So let's solve this by providing a getter in the History class to retrieve the entire list of pages:
Problem 2: BrowserGUI should have no references to the History class. Just remove the History parameter from the constructor (it isn't used anyway). And replace the initBackward and initForward methods with the following 2:
Since we're cleaning up the History class we might as well look at what state it should and should not have.
This may look silly since we still just give access to our internal list right? But there's a good reason for it. Previously I kept saying that whenever we want to change the implementation it should only change that specific class right? Does that still hold? Well, let's say for example that instead of 1 list with the full history we would split it up into 2 lists. The previousPages that now only contains the pages before the current page. And another list nextPages that contains all the pages after the current page. We then change the implementation of this getter to:
But enough with the nitpicking. These minor details should be pointed out to you by using a decent IDE. For example, I use IntelliJ. Another popular one is Eclipse, both free to use, but there are also others so your choice which one to use.
To be even more obvious let's also rename Browser to BrowserGUI, which again is also open for suggestions (even keeping it Browser could be OK, you can always refactor class names later on if you can think of a better name).
Lastly, the variable i could also use a more meaningful name. From what I can tell it represents the index of the current page so let's call it currentPageIndex instead.
The variable j represents the number of items in the history. We don't need this variable since list.size() gives us this information already. So j can be removed completely.
Note that checking the logic whether or not these 2 buttons should be enabled is not the responsibility of the browser class itself. Someone else will check the logic and then tell the Browser to enable or disable these buttons.
goBack and goForward check if the input is valid. I have chosen to just keep the internal state consistent and return a blank page. An alternative solution could be to throw an exception instead. I have added the required method comments to tell the person using these methods what he can expect.
Notice how the signature of this method did not change. Meaning any class that already used it before can just use the updated version without ever knowing that the internal representation has changed.
The variable previousPages isn't used. This can also be removed completely. On the other hand, the name previousPages actually fits the intention of the variable list a lot better. So let's rename list to previousPages.
Notice how I renamed the initX methods to setXEnabled. This was probably also my fault for not being clear about the naming convention on my other answer. initX is reserved for helper methods used during construction (or delayed initialisation) of the class. Here we're set-ing new values during normal use of the class. So set-ers are the default names for these methods.
Notice how the display.setPage(url) might throw an exception but that we're not interested in handling that exception here. Instead we just let the entire method throw in to the caller and have them handle it. With this method added we can continue in the binding class.
And everything should work again. Note however that it would actually be better to let the view handle showing the user this list of previous pages. But that's something for a next update.
Notice how I'm now telling the history to goForward instead of accessing it's state and updating that directly. The History class itself will handle everything to keep it's state consistent and will return the next url in the history. Our binding class doesn't need to know how it does that.
No other class has access to the state of the History except through the public methods. Other classes don't even know that the history is stored in a list and that it keeps track of the current page using an int. If we ever want to change the implementation to something else only this class needs to change.
Problem 1: There are public fields. Just like in the History class, we don't want any other class to know about how we store the state of this class. Any public field means we can't change it afterwards without also touching other classes. Let's just make these private for now and fix the remaining BrowserHistoryBinding class when we're done with this one.
Same thing for enabling the forward and backward buttons on the browser. We're now just telling the browser to enable it's buttons based on the given information. At the same time we're retrieving that information from the history because the binding class doesn't have to know what it means to "have a previous page" or a "next page". That's something only the History class should know since it's information about our Model.
I hope this rather long post provided you with a better insight in how I would implement this browser application. As gervais.b has shown this is not the only possible way. There's advantages and dissadvantages as always. So it's worth studying other ways as well and try to find out which implementation is the best fit for your program. At least the general consensus is that it's a good idea to try to separate GUI code from business logic.
Finally let's look at how to fix the binding class. Since we made the state of the other 2 classes completely private we broke most of this class.
Notice also that I let my IDE change the == to Objects.equals( ... ) instead. String equality shouldn't be checked with ==.