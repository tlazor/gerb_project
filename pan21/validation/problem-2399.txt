For Events, you can use either database, text files or whatever storage, it's basically a logging mechanism.
The beauty of this is that all your game state is consistent to the exact point of the fork 'snapshot'. You are essentially making the OS do all the hard work for you of keeping dirty bits etc. You will not get into a situation where some of your objects got modified after you had begun saving the game, while others didn't.
(1) Only save the really important bits, (2) only save them when they have changed since the last time they were saved, (3) save them individually, and (4) save them via an asynchronous system.
If your MMO server is running on a Linux/Unix OS, you might be able to take advantage of the inherent copy-on-write properties of vfork(). This trick is used by some database software such as Redis to make consistent point-in-time snapshots without stopping the server.
Base your game around Events, and log every single tiny Event. Whenever you need to load data or something, just iterate over the related Events and woila everything's back.
Then you can cache current Event state before moving Events to backup for like 1-3 times a day on a separate server or when the load time is less than X%. Caching works like restore point - if the player had 12313 Events in last 3 hours, that's a lot of loading time the next time he comes online, so, when it's cached, it would read the cached state from memory and log new Events, that would later also be re-cached and so on and so forth.
To avoid data loss in case of a crash, I've been periodically serializing the world to disk. The trouble is, this object can be quite large, so when the server starts writing, there's noticeable in-game slowdown for a few seconds, which I'd like to avoid.
Once you call vfork(), your parent process can continue to operate as normal, and your child process, which is a clone of the game universe at the time of vfork(), should no longer process the game and instead take all its time writing out all of the object states. It can possibly use lower priority, throttle down the IO, etc. Once it finishes, it should exit.
This trick was used in the original Ultima Online, as some of the devs mentioned it in this discussion.
When you call vfork() the OS makes a clone of your process, however it does not copy the memory of that process. The clone will still share the same memory pages, as long as they are equal. The OS will create copies of pages as needed when they are modified by either of the process. Page sizes are usually 4kb in linux. If you think about it, this is your delta compression, except you don't have to write any code for it. The OS already does the dirty work for you (utilizing the hardware MMU, etc).
I'm working on an MMO. All of the player and environment data lives on a server and is kept in memory. There's a "world" object which keeps track of all of the maps, characters, etc. and their relations to each other.