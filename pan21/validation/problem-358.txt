This method avoids the complexity of threads (although it does involve the complexity of events, which are thread synchronization primitives, so it's not totally trivial), but doesn't require you to set up a full-blown message pump and window (and thus lets you stay in an otherwise pure "text-based" environment you are presumably already familiar with).
The Windows API includes "character mode" functions, which deal with consoles and console input at a lower level than the C++ standard library functions. You can make use of these to create a real-time text-based game loop (there are also useful functions in the API for drawing large blocks of characters at a time, which is helpful for creating smooth animation in text-based games).
The main function you'll want to concern yourself with is ReadConsoleInput, which allows you to create a simple game loop as follows:
This is the first step towards a real-time loop. In this basic form, however, update will block if there are no events. There are also some events you will miss (mouse movement events) unless you configure the console input handle accordingly. 
For many purposes, the blocking nature of the function is acceptable, but if it isn't, you can have a full real-time loop by using a wait function, supplying the console input handle (inputHandle above) to the function. The wait function will block until input is available or until the specified timeout occurs. You can use, for example, WaitForSingleObject with a very low timeout and check the return value, which indicates if the wait timed out or if the event was signalled. If the former, you process a frame of game updates without player input and wait again (if the latter, you process the player's input).