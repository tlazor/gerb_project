So we can see that $HOME/bin is first in $PATH, so whatever I put in ~/bin will run. I have a demonstration script called ~/bin/findme:
If a script requires additional resources that can be found relative to its own location (not uncommon) then the envvar $BASH_SOURCE is used. $BASH_SOURCE always contains the absolute path to the currently running script itself, regardless the value of $PWD.
Your current directory only matters if the scripts assumes you are in the same folder as it. I would assume most scripts don't do this and you are save to run it like above.
As for knowing whether or not a script will find the files it needs, there is no good answer, other than looking at the script to see what it does. As an option, you could always go to the script's folder in a sub-process without leaving your current folder: 
The solution I've consistently seen is to have a $HOME/bin directory and put it first in $PATH (via ~/.bashrc if it isn't already there; on some systems ~/bin is first in $PATH by default). Dropping scripts in there for execution or symlinks to scripts/executables elsewhere is the simple way to deal with path issues that shouldn't affect the system or other users.
If you have scripts lying around that you need to run often, and they depend on their location for finding resources you can easily do this by just combining commands in an alias like this.
sh /path/to/script will spawn a new shell and run she script independent of your current shell. The source (.) command will call all the commands in the script in the current shell. If the script happens to call exit for example, then you'll lose the current shell. Because of this it is usually safer to call scripts in a separate shell with sh or to execute them as binaries using either the full (starting with /) or relative path (./). If called as binaries, they will be executed with the specified interpreter (#!/bin/bash, for example). 